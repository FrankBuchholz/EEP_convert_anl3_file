<!DOCTYPE html>
<html lang="de">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Inventar zu einer EEP-Anlage-Datei (.anl) anzeigen</title>
<meta name="description" content="Dieses Programm nutzt die Javascript-Funktion DOMParser um eine .anl-Datei von EEP, die aus XML aufgebaut ist, zu interpretieren und in das Document Object Model (DOM) umzuwandeln. Anschließend wird der Inhalt ausgegeben.">
<meta name="author" content="Frank Buchholz">
<meta name="keywords" content="EEP,.anl3,Inventar" />
<meta name="language" content="de" />

<!-- 
Table Filter Library 
https://www.tablefilter.com/ 

Filter Operators
https://github.com/koalyptus/TableFilter/wiki/4.-Filter-operators

Data types, column operations
https://www.tablefilter.com/data-types.html
-->
<script src="https://www.tablefilter.com/tablefilter/tablefilter.js"></script>
<link href="https://www.tablefilter.com/tablefilter/style/tablefilter.css" rel="stylesheet">

<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
<script> // Load file
function loadFile(file) {
	var fr;
	if (typeof window.FileReader !== 'function') {
		e(null, "p", "The file API isn't supported on this browser yet.");
		return;
	};

	if (!file) {
		e(null, "p", "Please select a file before clicking 'Load'");
	}
	else {
		fr = new FileReader();
		fr.onload = processFile;
		fr.readAsText(file);
//		console.log(fr.result);
	}

	// process file (local function to get access to local variable fr)
	function processFile() {

		// Create parser
		var parser = new DOMParser();
		// Parse xml into DOM
		var xmlDoc = parser.parseFromString(fr.result, "text/xml");
		fr.result = null; // we do not need this data anymore

		// Hide header
		document.getElementById('header').classList.add('hidden');

		// Show main area
		document.getElementById('container').classList.remove('hidden');

		// Show file name
		document.getElementById('filename').textContent = file.name.substring(0, file.name.length -1 -1 -3);

		// Process root node (documentElement always represents the root node)
		process_node(xmlDoc.documentElement);
	}

}
</script>

<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

<script src="EEP_Signale_Daten.js"></script> <!-- Lade Zusatzdaten zu Signalen: Name, Signalstellungen -->

<script> // process_node

function process_node(sutrackp) {
//console.log(sutrackp.nodeName);

	// EEP: Static texts
	const GleissystemText = { 			// GleissystemID
		1 : 'Eisenbahn',
		2 : 'Strassenbahn',
		3 : 'Strasse',
		4 : 'Wasserwege',
		5 : 'Steuerstrecken',			// nicht in EEP 9
		6 : 'GBS',						// nicht in EEP 9
	};

	const Gleisart = { 					// clsid
		'2E25C8E2-ADCD-469A-942E-7484556FF932' : 'Normal',
		'C889EADB-63B5-44A2-AAB9-457424CFF15F' : 'Weiche',
		'B0818DD8-5DFD-409F-8022-993FD3C90759' : '3-Weg-Weiche',
		'06D80C90-4E4B-469B-BFE0-509A573EBC99' : 'Prellbock',
	};

	/* Gleisstile:
	http://up.picr.de/33875489iu.pdf
	http://bahn.hersacher.de/splinekatalog/spkat_intro.htm
	*/
	const unsichtbar = [			// unsichtbare Gleisstile
		17, 						// Wasser, Steuerstrecke
		28, 34, 562, 1346, 5100,	// Gleis
		35, 						// Strassenbahn
		36, 						// Strasse
		5145, 5146, 5147,			// Farm track
		5602,						// Fence
		100000,						// Kamerafahrweg
	];

	// GleisData
	const GleisDataText = {
		1	: 'Oberleitung',
		2	: 'Weichenlaterne verstecken ',
		3	: 'Oberleitung, Weichenlaterne verstecken ',
		4	: 'Weichenlaterne rechts',
		5	: 'Oberleitung, Weichenlaterne rechts',
		8	: 'Weichenlaterne links',
		9	: 'Oberleitung, Weichenlaterne links',
		16	: 'Weichenlaterne als Immobilie/Straßen-T-Kreuzung',
		18	: 'Doppelkreuzungsweiche',
		19	: 'Oberleitung, Doppelkreuzungsweiche',
		20	: 'Straßen-T-Kreuzung',
	};

	// Weichenstellung
	const WeichenstellungText = { 	
		1 : 'Durchfahrt',
		2 : 'Abzweig',
		3 : 'KoAbzweig',
		5 : 'Spezial',
	};

	// Groesse der Anlage (alle Positionsangaben in m statt cm)
	const Schandlaft 	= sutrackp.getElementsByTagName('Schandlaft')[0];
	const Area = {
		min : {
			x : Schandlaft.getAttribute('posX') / 100,
			y : Schandlaft.getAttribute('posY') / 100,
		},
		width  	: Math.abs(Schandlaft.getAttribute('posX') * 2 / 100),
		height 	: Math.abs(Schandlaft.getAttribute('posY') * 2 / 100),
	};

	// Verwendeter Bereich der Anlage
	const usedArea = {
		min : {x : 0, y : 0, z : 0},
		max : {x : 0, y : 0, z : 0},
	};

	// Variable für die Ausgabe
	let div;
	div = e(null, 'div' );
	div.classList.add('Intro');
	
	const Version = sutrackp.getElementsByTagName('Version')[0];
	if (Version) {
		const EEPversion = Version.getAttribute('EEP');
		if (EEPversion && EEPversion >= 16) {
		e(div, 'p',
				`Die Anlagedatei aus EEP Version ${EEPversion} wird von den Programmen EEP_Gleisplan und EEP_Inventar noch nicht unterstützt.
				`
			);	
			return;
		}
	}

	// EEP Version = 15, Anzahl Objekte = 733, Breite = 1007 m, Tiefe = 607 m
	if (Version) {
		e(div, 'p',
			`EEP Version = ${Version.getAttribute('EEP')},
			 Anzahl Objekte = ${Version.getAttribute('No3DMs')},
			 Breite = ${Area.width.toFixed(0)} m,
			 Tiefe = ${Area.height.toFixed(0)} m
  		`
		);
	}

	// Maps for direct access
	const GleisMap = new Map();	// Verwendung: Gleis = GleisMap.get(GleissystemID).get(GleisID))

	// Sortable arrays
	const
		Weichen 	= [], 	// ID (der Weiche), Gleissystem, Gleis
		Signale 	= [], 	// ID (des Signals), Gleissystem, Gleis, Name, Meldung
		Kontakte 	= [], 	// SetType, Gleissystem, Gleis, Kontakt
		Zugverbaende = new Map(),//[], 	// ID (des Zugverbandes), Name, Gleisort, rollmaterialien
		Gleisstile	= [],	// Gleisstil, Datei, Anzahl
		Routen		= [],
		Sounds		= [];

	// Extract data from Gleissystem
	for (const Gleissystem of sutrackp.getElementsByTagName('Gleissystem')) {
		// Use attribute TrackSystemNumber instead of GleissystemID if available
		let GleissystemID 	= Gleissystem.getAttribute('TrackSystemNumber');
		if (!GleissystemID) {
			GleissystemID 	= Gleissystem.getAttribute('GleissystemID');
		}
		GleisMap.set(GleissystemID, new Map());

		for (const Gleis of Gleissystem.getElementsByTagName('Gleis')) {
		
/* Beispiel bis Version EEP 15:
<Gleis GleisID="1" clsid="2E25C8E2-ADCD-469A-942E-7484556FF932" data="0" scale="1" ElectSideS="0" ElectSideE="0" stil="1353" gsbname="\Gleisstile\Gleise\Beton2_Sch_C_LW1.3dm" LockEd="0">
	<Dreibein>
		<Vektor x="-12359.88" y="-1854.389" z="30">Pos</Vektor>
		<Vektor x="0.699066" y="-0.715057" z="0">Dir</Vektor>
		<Vektor x="0.715057" y="0.699066" z="0">Nor</Vektor>
		<Vektor x="-0" y="0" z="1">Bin</Vektor>
	</Dreibein>
	<Anfangsfuehrungsverdrehung Wert="0"/>
	<Charakteristik Kruemmung="0" Torsion="0" Fuehrungsverdrehung="-0" Kurve="0" Laenge="2580"/>
</Gleis>

Beispiel ab Version EEP 16:
https://www.trendverlag.com/Schema/EEP.xsd
https://www.trendverlag.com/Schema/Common.xsd
https://www.trendverlag.com/Schema/traxML.xsd
https://www.trendverlag.com/Schema/Train.xsd

<Gleis GleisID="314" clsid="2E25C8E2-ADCD-469A-942E-7484556FF932" data="0" scale="0.6" ElectSideS="0" ElectSideE="0" OneWay="1" stil="2263" gsbname="\Gleisstile\Strassen\Asphaltstrasse_01_RE1.3dm" LockEd="0">
	<Frame>...</Frame>
	<Interval near="0" far="20.34561"/>

gefolgt von einer der Varianten:

	<Curve>
		<EEPCurve Kruemmung="0" Torsion="0" Fuehrungsverdrehung="-0" Laenge="1768" Kurve="0" Anfangsfuehrungsverdrehung="0">
			<Frame>...</Frame>
		</EEPCurve>
	</Curve>
	
	<Curve>
		<Line>
			<VectorBundle>
				<Position x="0" y="0" z="0"/>
				<Vector dx="1" dy="0" dz="0"/>
			</VectorBundle>
			<Vector dx="0" dy="0" dz="1"/>
		</Line>
	</Curve>
	
	<Curve>
		<Arc>
			<VectorBundle2>
				<Position x="0" y="16.40503" z="0"/>
				<Vector dx="1" dy="0" dz="0"/>
				<Vector dx="0" dy="16.40503" dz="0"/>
			</VectorBundle2>
		</Arc>
	</Curve>
	
	<Curve>
		<Helix a="100.4987" b="2.017408">
			<VectorBundle2>
				<Position x="0" y="0" z="0"/>
				<Vector dx="1" dy="0" dz="0"/>
				<Vector dx="0" dy="1" dz="0"/>
			</VectorBundle2>
		</Helix>
	</Curve>
	
	<Curve>
		<Rotator a="7.933316E-02" b="-0"/>
	</Curve>

und abgeschlossen mit
	
	<Twist>...</Twist>
</Gleis>
		
mit

<Frame>
	<Position x="268582" y="-155050" z="29.99999"/>
	<Vector dx="1" dy="0" dz="0"/>
	<Vector dx="0" dy="1" dz="0"/>
	<Vector dx="0" dy="0" dz="1"/>
</Frame>
			
*/
			const GleisID = Gleis.getAttribute('GleisID');
			GleisMap.get(GleissystemID).set(GleisID, Gleis);

			const Laenge	= Gleis.getElementsByTagName('Charakteristik')[0].getAttribute('Laenge') / 100;
			const PosX		= Gleis.getElementsByTagName('Dreibein')[0].getElementsByTagName('Vektor')[0].getAttribute('x') / 100;
			const PosY		= Gleis.getElementsByTagName('Dreibein')[0].getElementsByTagName('Vektor')[0].getAttribute('y') / 100;
			const PosZ		= Gleis.getElementsByTagName('Dreibein')[0].getElementsByTagName('Vektor')[0].getAttribute('z') / 100;

			// Verwendeten Bereich der Anlage anpassen (mit zusätzlichen Platz in der Ebene für die Position der Endpunkte)
			usedArea.min.x = Math.min( usedArea.min.x, PosX - Laenge );
			usedArea.min.y = Math.min( usedArea.min.y, PosY - Laenge );
			usedArea.min.z = Math.min( usedArea.min.z, PosZ );

			usedArea.max.x = Math.max( usedArea.max.x, PosX + Laenge );
			usedArea.max.y = Math.max( usedArea.max.y, PosY + Laenge );
			usedArea.max.z = Math.max( usedArea.max.z, PosZ );

			// Weichen
			const WeicheID	= Gleis.getAttribute('Key_Id');
			if (WeicheID) {  // Ist das Gleis eine Weiche?
				Weichen.push({
					ID				: Number(WeicheID),  // sort field

					GleissystemID 	: GleissystemID,
					GleisID 		: GleisID,
				});
			}

			// Signale
			for (const Meldung of Gleis.getElementsByTagName('Meldung')) {
				// get potential sort fields
				const SignalID	= Meldung.getAttribute('Key_Id');
				const Name		= Meldung.getAttribute('name');

				Signale.push({
					ID				: Number(SignalID),  // sort fields
					Name			: Name,

					GleissystemID 	: GleissystemID,
					GleisID			: GleisID,

					Meldung 		: Meldung,
				});
			}
			
			// Kontakte
			for (const Kontakt of Gleis.getElementsByTagName('Kontakt')) {
				// get potential sort fields
				const SetType	= Kontakt.getAttribute('SetType');

				Kontakte.push({
					ID				: Number(SetType),  // sort fields
					
					GleissystemID 	: GleissystemID,
					GleisID			: GleisID,

					Kontakt 		: Kontakt,
				});
			}
			
			// Gleisstile
			// <Gleis stil="1353" gsbname="\Gleisstile\Gleise\Beton2_Sch_C_LW1.3dm">
			const StilID 		= Number(Gleis.getAttribute('stil'));
			const Dateiname		= Gleis.getAttribute('gsbname');
			
			if (StilID == 0) { // What should we do if there is no value?
			}
			
			const index = Gleisstile.findIndex(function (element) {
				return (element.ID == StilID && element.Name == Dateiname);
			});
			if (index == -1) {
				Gleisstile.push({
					ID				: StilID,
					Name			: Dateiname,
					Anzahl			: 1,
				})
			} else {
				Gleisstile[index].Anzahl = Gleisstile[index].Anzahl + 1;
			}

		}
	}
	
	// Verwendeter Bereich der Anlage anpassen (nicht größer als die Anlage selber)
	usedArea.min.x = Math.max( usedArea.min.x, Area.min.x );
	usedArea.min.y = Math.max( usedArea.min.y, Area.min.y );
	usedArea.max.x = Math.min( usedArea.max.x, Area.min.x + Area.width  );
	usedArea.max.y = Math.min( usedArea.max.y, Area.min.y + Area.height );

	// Extract data from Fuhrpark
	const Fuhrpark = sutrackp.getElementsByTagName('Fuhrpark')[0];
	for (const Zugverband of Fuhrpark.getElementsByTagName('Zugverband')) {
		const ZugID		= Zugverband.getAttribute('ZugID');
		const Name		= Zugverband.getAttribute('name');
		const Gleisort	= Zugverband.getElementsByTagName('Gleisort')[0];
		const Rollmaterialien = [];

		const ZugverbandRollmaterial = Zugverband.getElementsByTagName('Rollmaterial');
		for (const Rollmaterial of ZugverbandRollmaterial) {
			Rollmaterialien.push({
				Rollmaterial : Rollmaterial,
			});
		}

		Zugverbaende.set(Number(ZugID), {	// Zugverbaende.push({
			ID				: Number(ZugID),  // sort fields
			Name			: Name,

			Zugverband		: Zugverband,
			Gleisort 		: Gleisort,
			Anzahl			: ZugverbandRollmaterial.length,
			Rollmaterialien	: Rollmaterialien,
		});
	}

	// Extract data from Options
	/*
	<Options RouteItems="4" SoundItems="0" RouteId_0="1" RouteName_0="Strecke" RouteId_1="2" RouteName_1="Rangieren" RouteId_2="3" RouteName_2="Tausch" RouteId_3="4" RouteName_3="Weiterfahrt" FavTrainCB="0"/>
	*/
	const Options = sutrackp.getElementsByTagName('Options')[0];
	const RouteItems = Options.getAttribute('RouteItems');
	for (i = 0; i < RouteItems; i++) {
		const RouteID	= Options.getAttribute('RouteId_' + i);
		const RouteName = Options.getAttribute('RouteName_' + i);
		Routen[RouteID] = RouteName;
	}
	const SoundItems = Options.getAttribute('RouteItems');
	for (i = 0; i < SoundItems; i++) {
		const SoundID	= Options.getAttribute('SndId_' + i);
		const SoundName = Options.getAttribute('SndName_' + i);
		Sounds[SoundID] = SoundName;
	}

<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

	// Anzeige des verwendeten Bereichs
	e(div, 'p', 
		`Verwendeter Bereich: (${(usedArea.min.x).toFixed(0)} m, ${(usedArea.min.y).toFixed(0)} m) .. (${(usedArea.max.x).toFixed(0)} m, ${(usedArea.max.y).toFixed(0)} m)`
	);
	e(div, 'p',
		`Min./max Höhe: ${(usedArea.min.z).toFixed(0)} m .. ${(usedArea.max.z).toFixed(0) }m`
	);

<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->


	// Anzeige der Weichen
	div = createTable({
		id		: 'Weiche',
		title 	: `Weichen (${Weichen.length})`,
		caption	: `Weichen`,
		content	: function(thead, tbody) {
		
		Weichen.sort(orderByID).forEach(Weiche => {
			
		const WeicheID		= Weiche.ID;
		const GleissystemID	= Weiche.GleissystemID;
		const GleisID 		= Weiche.GleisID;
		const Gleis 		= GleisMap.get(GleissystemID).get(GleisID);
		const Name			= Gleis.getAttribute('gsbname');
		const PosX			= Gleis.getElementsByTagName('Dreibein')[0].getElementsByTagName('Vektor')[0].getAttribute('x') / 100;
		const PosY			= Gleis.getElementsByTagName('Dreibein')[0].getElementsByTagName('Vektor')[0].getAttribute('y') / 100;
		const KontaktZiel 	= Gleis.getElementsByTagName('KontaktZiel')[0].textContent;
		const GleisData		= Gleis.getAttribute('data'); 		// Bitfeld einer Weiche
		const clsid			= Gleis.getAttribute('clsid');
		const weichenstellung = Gleis.getAttribute('weichenstellung');
		const SignalData 	= Gleis.getAttribute('SignalData');
		const NextSigFn1 	= Gleis.getAttribute('NextSigFn1');
		const NextSigFn2 	= Gleis.getAttribute('NextSigFn2');

		fillTable(thead, tbody, [
			
		{ th : `Weiche`,			td : WeicheID },
		{ th : `Gleissystem Gleis`,	td : GleissystemText[GleissystemID] + ' ' + GleisID },
		{ th : `x (m)`,				td : PosX.toFixed(0) },
		{ th : `y (m)`,				td : PosY.toFixed(0) },
		{ th : `KontaktZiel`,		td : (KontaktZiel != 0 ? KontaktZiel : '') },
		{ th : `Gleisart`,			td : Gleisart[clsid] },
		{ th : `Weichenstellung`,	td : weichenstellung + ' ' + WeichenstellungText[weichenstellung] },
		{ th : `SignalData`,		td : SignalData },
		{ th : `NextSigFn1`,		td : NextSigFn1 },
		{ th : `NextSigFn2`,		td : NextSigFn2 },
		{ th : `GleisData`,			td : (GleisData != 0 ? GleisData + ' ' + GleisDataText[GleisData] : '') },
		{ th : `Name`,				td : Name },

		]) }) 
		
		return Weichen.length;
		}
	})

	if (Weichen.length > 0) { 
		e(div, 'p', 'SignalData: Weiche ist verknüpft mit Signal/Weiche');
		e(div, 'p', 'NextSigFn1: Wenn Weiche auf "Durchfahrt" steht dann verknüpfte ID in angegebene Stellung schalten');
		e(div, 'p', 'NextSigFn2: Wenn Weiche auf "Abzweig" steht dann verknüpfte ID in angegebene Stellung schalten');
	}

<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

	// Anzeige der Signale
	/*
	<Meldung Position="1687.619" ParaOderAnti="0" fireOnPara="1" fireOnAnti="0" clsid="D180F669-DCCC-42E9-960C-B5305B29F69D" name="ShSig_Licht_EpIV_kl" Key_Id="34" Hofs="300" Vofs="300" LockEd="0">
		<KontaktZiel>2</KontaktZiel>
		<Signal stellung="2" wirkungsdistanz="1000" StopAt="0" Geschwindigkeit="0" Delay="0" ActDelay="0"/>
	</Meldung>
	
	Achtung: Fahrstrassen werden ebenfalls durch Meldungen realisiert
	Dabei gilt name="system\Route_SignalS.3ds" für den Start bzw. name="system\Route_SignalZ.3ds" für das Ende einer Fahrstrasse.
	*/
	div = createTable({
		id		: 'Signal',
		title 	: `Signale (${Signale.length})`,
		caption	: `Signale`,
		content	: function(thead, tbody) {
	
		Signale.sort(orderByID).forEach(Signal => {
		
		const SignalID		= Signal.ID;
		const File			= Signal.Name;
		const GleissystemID	= Signal.GleissystemID;
		const GleisID 		= Signal.GleisID;
		const Gleis 		= GleisMap.get(GleissystemID).get(GleisID);
		const PosX			= Gleis.getElementsByTagName('Dreibein')[0].getElementsByTagName('Vektor')[0].getAttribute('x') / 100;
		const PosY			= Gleis.getElementsByTagName('Dreibein')[0].getElementsByTagName('Vektor')[0].getAttribute('y') / 100;
		const Position		= Signal.Meldung.getAttribute('Position') / 100;
		const Stellung		= Signal.Meldung.getElementsByTagName('Signal')[0].getAttribute('stellung');
		const Count			= Signal.Meldung.getElementsByTagName('Signal')[0].getAttribute('Count');
		const SignalData	= Signal.Meldung.getElementsByTagName('Signal')[0].getAttribute('SignalData');
		const Distanz		= Signal.Meldung.getElementsByTagName('Signal')[0].getAttribute('wirkungsdistanz') / 100;
		const ParaOderAnti 	= Signal.Meldung.getAttribute('ParaOderAnti'); // Gleisrichtung 0: Ende -> Anfang, 1: Anfang -> Ende
		const KontaktZiel 	= Signal.Meldung.getElementsByTagName('KontaktZiel')[0].textContent;

		let SignalstellungText = Stellung;
		let SignalstellungenText = '';
		
		if (Signalstellung[File]) {
			// 1st try: Get texts (case sensitive file name)
			SignalstellungText += ' : ' + Signalstellung[File].Pos[Stellung];
			
			for (StellungPos in Signalstellung[File].Pos) {
				SignalstellungenText += StellungPos + ' : ' + Signalstellung[File].Pos[StellungPos] + '<br />';
			}
		} else {
			// 2nd try: Get texts (case insensitive file name)
			for (SignalFile in Signalstellung) {
				if (SignalFile.toLowerCase() == File.toLowerCase()) {
					SignalstellungText += ' : ' + Signalstellung[SignalFile].Pos[Stellung];
					
					for (StellungPos in Signalstellung[SignalFile].Pos) {
						SignalstellungenText += StellungPos + ' : ' + Signalstellung[SignalFile].Pos[StellungPos] + '<br />';
					}
				}
			}
		}

		fillTable(thead, tbody, [

		{ th : `Signal`,			td : SignalID },
		{ th : `Gleissystem Gleis`,	td : GleissystemText[GleissystemID] + ' ' + GleisID },
		{ th : `x (m)`,				td : PosX.toFixed(0) },
		{ th : `y (m)`,				td : PosY.toFixed(0) },
		{ th : `Position (m)`,		td : Position.toFixed(0) },
		{ th : `Distanz zum Hauptsignal (m)`,	td : (Distanz !=0 ? Distanz.toFixed(0) : '') },
		{ th : `Gleisrichtung`,		td : ParaOderAnti },
		{ th : `Stellung`,			td : SignalstellungText },
		{ th : `Anzahl Stellungen`,	td : Count },
		{ th : `Stellungen`,		td : SignalstellungenText, html : true, },
		{ th : `SignalData`,		td : SignalData },
		{ th : `KontaktZiel`,		td : (KontaktZiel != 0 ? KontaktZiel : '') },
		{ th : `Datei`,				td : File },
		{ th : `Name`,				td : (Signalstellung[File] ? Signalstellung[File].Name : '') },

		]) }) 
		
		return Signale.length;
		}
	})

	if (Signale.length > 0) { 
		e(div, 'p', 'SignalData: Signal ist verknüpft mit Signal/Weiche');
	}

<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

	// Anzeige der Kontakte
	/*
	<Kontakt Position="712.3505" ParaOderAnti="1" fireOnPara="0" fireOnAnti="1" Teiler="1" ActTeiler="0" TrainSide="1" Route="0" Route2="0" SetType="0" SetValue="0" Delay="0" ActDelay="0" TrainID="0" TrainID2="0" Light="2" LastTrainID="26" LastOfs="742.3113" ConnectF="2" ConnectR="2" VolDist="20" zuStellung="2" Wartender="0" AxisPos="0" AxisFilter="" NameFilter="" TrainNewName="" KontaktDist="0" TrainDist="0" LuaFn="" Group="0" AnimID="0" CheckAuto="2" SetAuto="2" SignalData="0" SigNeg="0" LockEd="0" KontaktZiel="2" Wechseln="0" clsid="5E9A3049-D465-4602-A285-6A9774DCF1BF"/>
	*/
	div = createTable({
		id		: 'Kontakt',
		title 	: `Kontakte (${Kontakte.length})`,
		caption	: `Kontakte`,
		content	: function(thead, tbody) {
	
		Kontakte.sort(orderByID).forEach(Kontakt => {  // no ID, therfore no sort

		// const SetType 		= Kontakt.ID;
		const SetType 		= Kontakt.Kontakt.getAttribute('SetType');
		const SetValue 		= Kontakt.Kontakt.getAttribute('SetValue');
		const KontaktZiel 	= Kontakt.Kontakt.getAttribute('KontaktZiel');
		const GleissystemID	= Kontakt.GleissystemID;
		const GleisID 		= Kontakt.GleisID;
		const Gleis 		= GleisMap.get(GleissystemID).get(GleisID);
		const PosX			= Gleis.getElementsByTagName('Dreibein')[0].getElementsByTagName('Vektor')[0].getAttribute('x') / 100;
		const PosY			= Gleis.getElementsByTagName('Dreibein')[0].getElementsByTagName('Vektor')[0].getAttribute('y') / 100;
		const Position		= Kontakt.Kontakt.getAttribute('Position') / 100;
		const ParaOderAnti 	= Kontakt.Kontakt.getAttribute('ParaOderAnti'); // Gleisrichtung 0: Ende -> Anfang, 1: Anfang -> Ende
		const fireOnPara 	= Kontakt.Kontakt.getAttribute('fireOnPara');
		const fireOnAnti 	= Kontakt.Kontakt.getAttribute('fireOnAnti');
		const Teiler 		= Kontakt.Kontakt.getAttribute('Teiler');
		const ActTeiler 	= Kontakt.Kontakt.getAttribute('ActTeiler');
		const Delay 		= Kontakt.Kontakt.getAttribute('Delay');
		const ActDelay 		= Kontakt.Kontakt.getAttribute('ActDelay');
		const TrainSide 	= Kontakt.Kontakt.getAttribute('TrainSide');
		const RouteID 		= Kontakt.Kontakt.getAttribute('Route');
		const TrainID 		= Kontakt.Kontakt.getAttribute('TrainID');
		const NameFilter 	= Kontakt.Kontakt.getAttribute('NameFilter');
		const TrainNewName 	= Kontakt.Kontakt.getAttribute('TrainNewName');
		const zuStellung 	= Kontakt.Kontakt.getAttribute('zuStellung');
		const Wechseln 		= Kontakt.Kontakt.getAttribute('Wechseln');
		const VolDist 		= Kontakt.Kontakt.getAttribute('VolDist');
		const SignalData 	= Kontakt.Kontakt.getAttribute('SignalData');
	
		// Kontakttyp (SetType)
		// Achtung: Bei der Anzeige werden die Variablne v, x, t ersetzt
		const KontaktTyp = { 			// SetValue
			0 	: 'Weiche/Signal',		// -	
			1 	: 'Fahrzeug +v max',	// Geschwindigkeit in km/h
			2 	: 'Fahrzeug +v min',	// Geschwindigkeit in km/h
			3 	: 'Fahrzeug +v soll',	// Geschwindigkeit in km/h
			5 	: 'Fahrzeug -v max',	// Geschwindigkeit in km/h
			6 	: 'Fahrzeug -v min',	// Geschwindigkeit in km/h
			7 	: 'Fahrzeug -v soll',	// Geschwindigkeit in km/h
			8 	: 'RollGleis x m',		// Halt nach x m
			256 : 'Sound',				// Sound_ID
			512 : 'Kamera t sek.',		// Kamerawechsel nach t Sekunden
			768 : 'Immobilie',			// Verweist auf ImmoIdx
			1024 : 'DKW/EKW',			// Verweist auf ImmoIdx
			1280 : 'Einfahrt Depot',	// ?
			1536 : 'Ausfahrt Depot',	// ?
			32768 : 'Gruppen KP',		// ?
		}

		// DKW/EKW Weichenstellung
		const VolDistText = {
			0 : 'Umschalter',
			1 : 'links-links',
			2 : 'links-rechts',
			3 : 'rechts-rechts',
			4 : 'rechts-links',
		}

		const TrainSidetext = {
			0 : 'Spitze',
			1 : 'Schluss',
			[-1] : 'GrKP',
		}

		// Spezielle Kontakt-Typen
		let KontaktTypText = KontaktTyp[SetType];
		if 		  (SetType == 0) {
			if 		(Weichen.find(function(Weiche) { return Weiche.ID == KontaktZiel}) ) { KontaktTypText = 'Weiche'; } 
			else if (Signale.find(function(Signal) { return Signal.ID == KontaktZiel}) ) { KontaktTypText = 'Signal'; }
			else { KontaktTypText = 'Kontaktziel nicht gefunden'; }
		} else if (SetType >= 1 && SetType <= 7) {
			KontaktTypText = KontaktTypText.replace('v', SetValue);			// 'Fahrzeug +v max'
		} else if (SetType == 8) {
			KontaktTypText = KontaktTypText.replace('x', SetValue);			// 'RollGleis x m'
		} else if (SetType == 512) {
			KontaktTypText = KontaktTypText.replace('t', SetValue);			// 'Kamera t sek.'
		} else if (SetType == 1024) {
			KontaktTypText = KontaktTypText + ' ' + VolDistText[VolDist];	// DKW/EKW Weichenstellung
		}
		
		// SignalData 
		/*
		Byte 1 - 2 (LSB)
			Key-ID des abgefragten Signals oder Weiche
		Byte 3 - 4 (MSB) 
			Signal- oder Weichenstellung, die gegeben sein muss, damit der Kontakt schaltet
			Signal: 
				1=Fahrt
				2=Halt
			Weiche: 
				1=Durchfahrt
				2=Abzweig
				3=Koabzweig
			EKW: 
				1=von links nach rechts
				2=von rechts nach rechts
				3=von rechts nach links 
			DKW: 
				1=von links nach links
				2=von links nach rechts
				3=von rechts nach rechts
				4=von rechts nach links 
		*/
		const SignalDataStellung = Math.floor(SignalData / 65536);
		const SignalDataID   	 = SignalData - SignalDataStellung * 65536;

		// Zugverband`
		const Zugverband = Zugverbaende.get(Number(TrainID)); // Zugverbaende.find(function(Zugverband) { return Zugverband.ID == TrainID});

		fillTable(thead, tbody, [
	
		{ th : `Kontakt Typ`,		td : SetType },
		{ th : `Kontakt Typ`,		td : KontaktTypText },	// KontaktTyp[SetType] mit Modifikation
		{ th : `SetValue`,			td : ((SetType >= 1 && SetType <= 8) || SetType == 512 || SetValue != 0 ? SetValue : '') },
		{ th : `Kontakt Ziel`,		td : (KontaktZiel != 0 ? KontaktZiel : '') },
		{ th : `Gleissystem Gleis`,	td : GleissystemText[GleissystemID] + ' ' + GleisID },
		{ th : `x (m)`,				td : PosX.toFixed(0) },
		{ th : `y (m)`,				td : PosY.toFixed(0) },
		{ th : `Position (m)`,		td : Position.toFixed(0) },	// Position
		{ th : `Auslösung`,			td : (			fireOnPara == 1 && fireOnAnti == 0 ? (ParaOderAnti == 1 ? 'in Gleisrichtung' : 'gegen Gleisrichtung') 
											: ( 	fireOnPara == 0 && fireOnAnti == 1 ? (ParaOderAnti == 0 ? 'in Gleisrichtung' : 'gegen Gleisrichtung') 
												: ( fireOnPara == 1 && fireOnAnti == 1 ? 'beide Richtungen' : '' )
											  )
										 ) },
		{ th : `Zug Zähler`,		td : Teiler },
		{ th : `Zählerstand`,		td : ActTeiler },
		{ th : `Zeit Verzögerung`,	td : Delay },
		{ th : `Zeit abgelaufen`,	td : ActDelay },
		{ th : `Zug Position`,		td : (TrainSidetext[TrainSide] ? TrainSidetext[TrainSide] : TrainSide) },
		{ th : `für Route`,			td : (RouteID != 0 ? RouteID + ' ' + Routen[RouteID] : '') },
		{ th : `für Zug`,			td : (TrainID != 0 ? TrainID + ' ' + (Zugverband ? Zugverband.Name : 'nicht vorhanden') : '') },
		{ th : `Zug Filter`,		td : NameFilter },
		{ th : `Neuer Zugname`,		td : TrainNewName },
		{ th : `zu Stellung`,		td : (zuStellung > 0 && Wechseln == 0 ? zuStellung : (Wechseln == 1 ? 'Umschalter' : '')) },
		{ th : `SignalData`,		td : (SignalData != 0 ? `ID=${SignalDataID} Stellung=${SignalDataStellung}` : '') },

		]) }) 
		
		return Kontakte.length;
		}
	})

<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

	// Anzeige der Zugverbände
	div = createTable({
		id		: 'Zugverband',
		title 	: `Zugverbände (${Zugverbaende.size})`,
		caption	: `Zugverbände`,
		content	: function(thead, tbody) {

		Zugverbaende.forEach(Zugverband => { // Zugverbaende.sort(orderByID).forEach(Zugverband => {

		const ZugID			= Zugverband.ID;
		const Name			= Zugverband.Name;
		const Anzahl		= Zugverband.Anzahl;
		const GleissystemID	= Zugverband.Gleisort.getAttribute('gleissystemID');
		const GleisID 		= Zugverband.Gleisort.getAttribute('gleisID');
		const Gleis 		= GleisMap.get(GleissystemID).get(GleisID);
		const PosX			= Gleis.getElementsByTagName('Dreibein')[0].getElementsByTagName('Vektor')[0].getAttribute('x') / 100;
		const PosY			= Gleis.getElementsByTagName('Dreibein')[0].getElementsByTagName('Vektor')[0].getAttribute('y') / 100;
		const Position		= Zugverband.Gleisort.getAttribute('parameter') / 100;
		const ausrichtung 	= Zugverband.Gleisort.getAttribute('ausrichtung');
		const RouteID 		= Zugverband.Zugverband.getAttribute('Route');
		const LastDir 		= Zugverband.Zugverband.getAttribute('LastDir');
		const Geschwindigkeit = Zugverband.Zugverband.getAttribute('Geschwindigkeit') * 3600 / 1000;
		const sollgeschwindigkeit = Zugverband.Zugverband.getAttribute('sollgeschwindigkeit') * 3600 / 1000;
		const autopilot 	= Zugverband.Zugverband.getAttribute('autopilot');
		
		fillTable(thead, tbody, [

		{ th : `Zugverband`,				td : ZugID },
		{ th : `Gleissystem Gleis`,			td : `${GleissystemText[GleissystemID]} ${GleisID}` },
		{ th : `x (m)`,						td : PosX.toFixed(0) },
		{ th : `y (m)`,						td : PosY.toFixed(0) },
		{ th : `Position (m)`,				td : Position.toFixed(0) },
		{ th : `Ausrichtung`,				td : (ausrichtung == 1 ? 'in Gleisrichtung' : 'gegen Gleisrichtung') },
		{ th : `Name`,						td : Name },
		{ th : `Anzahl Rollmaterialien`,	td : Anzahl },
		{ th : `Route`,						td : (RouteID != 0 ? RouteID + ' ' + Routen[RouteID] : '') },
		{ th : `Geschwindigkeit km/h`,		td : (Geschwindigkeit != 0 ? Geschwindigkeit.toFixed(0) : (LastDir == 1 ? '+0' : '-0')) },
		{ th : `Sollgeschwindigkeit km/h`,	td : sollgeschwindigkeit.toFixed(0) },
		{ th : `Automatik`,					td : autopilot },

		]) }) 
		
		return Zugverbaende.length;
		}
	})

<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

	// Anzeige der Gleisstile
	div = createTable({
		id		: 'Gleisstil',
		title 	: `Gleisstile (${Gleisstile.length})`,
		caption	: `Gleisstile`,
		content	: function(thead, tbody) {
		
		Gleisstile.sort(orderByID).forEach(Gleisstil => {
		
		fillTable(thead, tbody, [
			
		{ th : `Gleisstil`,			td : Gleisstil.ID 		},
		{ th : `Name`,				td : Gleisstil.Name 	},
		{ th : `Anzahl`,			td : Gleisstil.Anzahl 	},

		]) }) 
		
		return Gleisstile.length;
		}
	})

<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

	// Allow to sort all tables by clicking on the header
	prepareSort();
}

function orderByID(a,b) {
	// Sort by number ascending
	return (a.ID - b.ID);
}
function orderByName(a,b) {
	// Sort by text ascending
	const NameA = a.Name.toLowerCase(), NameB = b.Name.toLowerCase();
	if (NameA < NameB)	{ return -1; }
	if (NameA > NameB)	{ return 1;  }
	return 0;
}

// Create output table
function createTable( tab ) {
	const div 	= 	e(null,	 'div'					);
					e(div, 	 'h4', 		tab.title	);
	const table = 	e(div, 	 'table' 				);
	//				e(table, 'caption', tab.caption );  // TableFilter uses the caption already
	const thead	= 	e(table, 'thead' 				);
	const tbody	= 	e(table, 'tbody' 				);

	div.classList.add(tab.id);
	div.setAttribute('id', 'div'+tab.id);
	table.setAttribute('id', tab.id);

	// Now, let's do it
	const count = tab.content(thead, tbody);

	if (count > 0) {
	
	// Activate table filter (see http://www.tablefilter.com/examples.html )
	// Configuration via statements instead of object: http://www.tablefilter.com/features-no-configuration.html
	// Feature toggle: http://www.tablefilter.com/toggle-features.html
	const tf = new TableFilter(table, {
		base_path: 'https://www.tablefilter.com/tablefilter/',

		//themes: [{ name: 'skyblue' }],	// Themes 'default', 'skyblue', 'transparent', 'mytheme'
		
		auto_filter: { delay: 500 },	// Delay for automatic filtering (milliseconds)

		state: {						// Enable state persistence (see http://www.tablefilter.com/persistence.html for more options)
			types: ['local_storage'],	// Mögliche Werte: 'local_storage' 'hash' or 'cookie' (erfordert id für Tabellen) 
			filters: true,				// Persist filters values, enabled by default
			columns_visibility: true,	// Persist columns visibility
			filters_visibility: true,	// Persist filters row visibility
		},					
		
		sticky_headers: true,			// Sticky headers with overrides
		alternate_rows: true,			// Enable alternating rows
		mark_active_columns: {			// Mark active columns
			highlight_column: false,	// Highlight columns or only header
        },
		grid_layout: false,				// Grit layout (but no simple copy&paste to Excel anymore)
		filters_row_index: 0,  			// Row index to show the filter bar (default 0). Show filter bar above header allows easy copy&paste of the table content.

		toolbar: true,					// Enable toolbar component
		rows_counter: { text: tab.caption + ': ' },	// Enable rows counter UI component
		status_bar: {					// Enable status bar UI component
			msg_filter: 'Filter aktiv ...',	// Message during filtering
			toolbar_position: 'center',	// Default position in toolbar ('left'|'center'|'right')
		},
		btn_reset: {  					// Enable clear button
			tooltip: 'Filter löschen',
			toolbar_position: 'right',	// Default position in toolbar ('left'|'center'|'right')
		},
		
		locale: 'de',					// Define default locale, default to 'en'
		thousands_separator: '.',		// Define thousands separator ',' or '.', defaults to ','
		decimal_separator: ',',			// Define decimal separator ',' or '.', defaults to '.'
		
		empty_operator: '[empty]',
		nonempty_operator: '[nonempty]',
		help_instructions: {			// Instructions text (accepts HTML)
			text : 
            'Filter-Operatoren:<br /> ' +
            '<b>&lt;</b>, <b>&lt;=</b>, <b>=</b>, <b>&gt;=</b>, <b>&gt;</b>, <br />' +
            '<b>*</b>, <b>!</b> (nicht), <b>{</b> (beginnt mit), <b>}</b> (endet mit), <br />' +
            '<b>||</b> (oder),<b> &amp;&amp;</b> (und),<br />' +
            '<b>[empty]</b>, <b>[nonempty]</b>, <b>rgx:</b><br />' +
            '<a href="' + 
			'https://github.com/koalyptus/TableFilter/wiki/4.-Filter-operators' + 
			'" target="_blank">' +
            'Weitere Informationen</a><hr/>'
			,
			btn_text : '?',				// btn_text oder btn_html
		},

		no_results_message: {			// "No results" message
			content: 'Keine zum Filter passende Einträge vorhanden',
		},
		loader: false,					// Loading indicator, { html : '...' }
		watermark: [ 'Filter...', ],	// Repeated watermark text for input fields or watermark for each filter if an array is supplied
		
		extensions:[					// Extensions load addititional script files
			{ 
				name: 'colsVisibility',
				description: 'Sichbarkeit der Spalten verwalten',	// Module description
				enable_hover: true,		// Enable hover behaviour on columns manager button/link
				btn_text: 'Spalten verstecken&#9660;',	// Button's text, defaults to Columns&#9660;
				//at_start: [3, 4],		// List of columns indexes to be hidden at initialization
				tickToHide: true,		// Enable tick to hide a column, defaults to true
				text: 'Versteckte Spalten: ', // Text preceding the columns list, defaults to 'Hide' or 'Show'
				btn_close_text: 'Schließen',	// Columns manager UI close link text, defaults to 'Close'
				enable_tick_all: false,	// Enable select all option, disabled by default
				tick_all_text: 'Alle auswählen:',	// Text for select all option, defaults to 'Select all:'
				toolbar_position: 'right',	// Default position in toolbar ('left'|'center'|'right')
			},
			/*
			{
				name: 'filtersVisibility',
				description: 'Sichtbarkeit der Filter',		// Module description
				visible_at_start: true,	// Make filters visible at initialization, defaults to true
				enable_icon: true,		// Enable expand/collapse icon, defaults to true
				btn_text: 'Filter',		// Custom text for button
				toolbar_position: 'right',	// Default position in toolbar ('left'|'center'|'right')
			},
			*/
			//{ name: 'sort' }			// Sort requires to classify numeric columns using "col_types : [ 'numeric', String', ...]," see http://www.tablefilter.com/sort.html
		],
	});
	tf.init();
	
	}

	return div;
}

// Fill output table
function fillTable(thead, tbody, lines ) {
	let thead_tr;
	
	const first = (thead.rows.length == 0);
	if (first) {
		thead_tr = e(thead, 'tr' );
	}

	const tbody_tr = e(tbody,	'tr');
	for (const line of lines) {
		if (first) {
			e(thead_tr, 'th', line.th);
		}
		e(tbody_tr, 'td', line.td, line.html);
	}
}

// Element erzeugen und anhängen
function e(target, tagName, content, html) {
	const element = document.createElement(tagName);
	if (content) { 
		if (html) {	element.innerHTML 	= content; }
		else 	  { element.textContent = content; }
	}
	if (!target) { target = document.getElementById('container') }
	target.appendChild(element);
	return element;
}

// Sort table, https://stackoverflow.com/questions/14267781/sorting-html-table-with-javascript
function prepareSort() {

	function getCellValue(tr, idx){
		return tr.children[idx].innerText || tr.children[idx].textContent; 
	}

	function comparer(idx, asc) {
		return function(a, b) {
			return function(v1, v2) {
				return v1 !== '' && v2 !== '' && !isNaN(v1) && !isNaN(v2) ? v1 - v2 : v1.toString().localeCompare(v2);
			}(getCellValue((asc ? a : b), idx), getCellValue((asc ? b : a), idx));
		}
	}

	// prepare the work...
	document.querySelectorAll('th').forEach(
		th => th.addEventListener('click', (() => {
			const table = th.closest('table');
			const tbody = table.querySelector('tbody');
			Array.from(tbody.querySelectorAll('tr'))
				.sort(comparer(Array.from(th.parentNode.children).indexOf(th), this.asc = !this.asc))
				.forEach(tr => tbody.appendChild(tr) );
		}))
	);
}
</script>

<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
<script> // html page

// Toggle visibility of elements
function toggleElements(selector, visible) {
	for (const ele of document.getElementById('container').querySelectorAll(selector)) {
		if (visible) {
			ele.classList.remove('hidden');
		} else {
			ele.classList.add('hidden');
		}
	}
}

</script>

<style> /* html page */
.hidden {
	display: none;
}

table {
	border-collapse: collapse;
}

caption {
  /* display: none;	*/
}

thead {
	font-weight: bold;
	background-color:#C5D8E1;
}

th {
	border: 1px solid gray;
	padding: 5px;
	cursor: n-resize; /* Cursor indicating sorting */
}

tbody {
	vertical-align: top;
}

tr {
}
 
tr:nth-child(even) {
  /* background-color: #ECF2F5; */
}

td {
	border: 1px solid gray;
	padding: 5px;
}

.fieldset {
	border-width: 0;
	margin-inline-start: 0;
	margin-inline-end: 0;
	padding-block-start: 0;
	padding-inline-start: 0;
	padding-inline-end: 0;
	padding-block-end: 0;
}
.fieldset .item {
	white-space: nowrap;		/* keep checkbox and label together */
	display: inline;			/* but do no add extra line breaks per item */
}

</style>

</head>

<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
<body>

<h3 id='filename'>EEP Inventar</h3>

<div id='header'> <!-- The header contains the initial selection screen -->

<div id='fileselector'>
<form action='#' onsubmit='return false;'> <!-- better not to use inline listener, explizit register is better -->
	<label for='fileinput'>Wähle und lade eine EEP-Anlage-Datei (.anl3)</label>
	<input type='file' id='fileinput' accept='.anl3' onchange='loadFile(this.files && this.files[0])'>
	<!-- An extra button is not neccessary -->
	<!-- <input type='button' id='btnLoad' value='Load' onclick='loadFile();'> -->
</form>

<p><small>Dieses Programm nutzt die Javascript-Funktion <a href='https://www.w3schools.com/xml/xml_parser.asp' target='_blank'>DOMParser</a> um eine <i>.anl3</i>-Datei von EEP, die aus <a href='https://www.w3schools.com/xml/xml_tree.asp' target='_blank'>XML</a> aufgebaut ist, zu interpretieren und in das <a href='https://www.w3schools.com/xml/xml_dom.asp' target='_blank'>Document Object Model (DOM)</a> umzuwandeln.<br />
Anschließend wird der Inhalt in verschiedenen Tabellen ausgegeben.<br /><br />
Man kann die Tabellen problemlos mit Copy &amp; Paste in ein Tabellenverarbeitungsprogramm übertragen.<br />
Die Tabellen können mit Klicks in die Spaltenüberschriften sortiert werden.<br />
</small></p>
<p><small>Zusätzlich wird die Bibliothek <a href='http://www.tablefilter.com/' target='_blank'>TableFilters</a> verwendet, um interaktive Funktionen zum Filtern in den Tabellen anzubieten.<br />
Die Filter-Operatoren werden auf der Projektseite im Kapitel <a href='https://github.com/koalyptus/TableFilter/wiki/4.-Filter-operators' target='_blank'>4.-Filter-operators</a> beschrieben.
</small></p>

<p><small>(c) Frank Buchholz, 2019</small></p>
</div> <!-- fileselector -->

</div>  <!-- header -->

<div id='container' class='hidden'> <!-- The container shows the result -->

<div class='group'>
<!-- Auswahl der anzuzeigenden Objekte. class=hidden wird für diese Objekte enfernt wenn eine Checkbox aktiv ist -->
<fieldset class='fieldset'>
	<div class="item"><label><input type='checkbox' name='Intro' 		checked autocomplete='off' onchange="toggleElements('.Intro', this.checked)"><a href='#divIntro'>Intro</a></label></div>
	<div class="item"><label><input type='checkbox' name='Weiche' 		checked autocomplete='off' onchange="toggleElements('.Weiche', this.checked)"><a href='#divWeiche'>Weiche</a></label></div>
	<div class="item"><label><input type='checkbox' name='Signal' 		checked autocomplete='off' onchange="toggleElements('.Signal', this.checked)"><a href='#divSignal'>Signal</a></label></div>
	<div class="item"><label><input type='checkbox' name='Kontakt' 		checked autocomplete='off' onchange="toggleElements('.Kontakt', this.checked)"><a href='#divKontakt'>Kontakt</a></label></div>
	<div class="item"><label><input type='checkbox' name='Zugverband' 	checked autocomplete='off' onchange="toggleElements('.Zugverband', this.checked)"><a href='#divZugverband'>Zugverband</a></label></div>
	<div class="item"><label><input type='checkbox' name='Gleisstil'	checked autocomplete='off' onchange="toggleElements('.Gleisstil', this.checked)"><a href='#divGleisstil'>Gleisstil</a></label></div>
	|
	<!-- Hide filter row and filter related icons to make copy&paste to Excel easier -->
	<div class="item"><label><input type='checkbox' name='Filter'		checked autocomplete='off' onchange="toggleElements('.fltrow,.rdiv', this.checked)">Filter</label></div>
</fieldset>
</div>

</div> <!-- container -->

</body>
</html>