<!DOCTYPE html>
<html lang="de">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Interaktive Anzeige des Gleisplans zu einer EEP-Anlage-Datei (.anl)</title>
<meta name="description" content="Dieses Programm nutzt die Javascript-Funktion DOMParser um eine .anl-Datei von EEP, die aus XML aufgebaut ist, zu interpretieren und in das Document Object Model (DOM) umzuwandeln. Anschließend wird dynamisch mit Javascript die Graphik des Gleisplanes mit SVG-Befehlen aufgebaut. Die Formatierung der graphischen Elemente erfolgt getrennt von der Definition der Graphik mit der SVG-Variante von CSS. Der Browser kann solche SVG-Graphiken direkt anzeigen. Zusätzlich werden die Bibliotheken svg-pan-zoom zum Verschieben und Zoomen und toolwindow zur Anzeige von Popups verwendet.">
<meta name="author" content="Frank Buchholz">
<meta name="keywords" content="EEP,.anl3,Gleisplan" />
<meta name="language" content="de" />
<link rel="icon" href="https://www.eepforum.de/images/favicon.ico" type="image/x-icon">

<style> /* html page */
html, body { /* deactivate default settings */
	margin: 0;
	padding: 0;
}

body {
	--header-background-color: STEELBLUE; /* ThreeDHighlight; */
	--header-text-color: WHITE; /* CaptionText; */
	
	--body-background-color: WhiteSmoke; /* AZURE; Window; */
	--body-text-color: BLACK; /* WindowText; */
	
	--footer-background-color: CADETBLUE; /* ButtonFace; */
	--footer-text-color: WHITE; /* ButtonText; */
}

.hidden {
	display: none;
}

 /* no select/copy to clipboard. Firefox prevents selection even in case of Ctrl-A, but with Chrome it's not relilaby. */
.no-select,
fieldset,
select,
input,
button {
	user-select: none;
}

kbd { 
	white-space: nowrap;		/* keep checkbox and label together */
	border: 1px solid #aaa; 
	-moz-border-radius: 0.2em; 
	-webkit-border-radius: 0.2em; 
	border-radius: 0.2em; 
	-moz-box-shadow: 0.1em 0.1em 0.2em rgba(0,0,0,0.1); 
	-webkit-box-shadow: 0.1em 0.1em 0.2em rgba(0,0,0,0.1); 
	box-shadow: 0.1em 0.1em 0.2em rgba(0,0,0,0.1); 
	background-color: #f9f9f9; 
	background-image: -moz-linear-gradient(top, #eee, #f9f9f9, #eee); 
	background-image: -o-linear-gradient(top, #eee, #f9f9f9, #eee); 
	background-image: -webkit-linear-gradient(top, #eee, #f9f9f9, #eee); 
	background-image: linear-gradient(to bottom, #eee, #f9f9f9, #eee); 
	color: #000; 
	padding: 0.1em 0.3em; 
	font-family: inherit; 
	font-size: 0.85em;
}
</style>
</head>

<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
<body>

<section id="fileselector"> <!-- Selection screen --> 
<header>
<h3>EEP Gleisplan</h3>
</header>

<article>
<form action="#" onsubmit="return false;"> <!-- better not to use inline listener, explizit register is better -->
	<label for="fileinput">Wähle (auch mit Drag&amp;Drop möglich) und lade eine EEP-Anlage-Datei (.anl3)</label>
	<input type="file" id="fileinput" accept=".anl3" onchange="loadFile(this.files && this.files[0])">
	<!-- An extra button is not neccessary -->
	<!-- <input type="button" id="btnLoad" value="Load" onclick="loadFile();"> -->
</form>
</article>

<article>
<p><small><strong>Mausfunktionen</strong><br>
Verschieben: Klick+Halten+Bewegen<br>
An der Stelle des Cursors hineinzoomen: Doppelklick<br>
Herauszoomen: <kbd>&#x21E7; Shift</kbd>+Doppelklick<br>
Details anzeigen: Klick auf Gleis, Symbol oder Text<br>
<span class="li">wenn zusammen mit <kbd>&#x21E7; Shift</kbd>, dann wird jeweils ein neues Popup geöffnet</span>
<span class="li">wenn zusammen mit <kbd>alt</kbd>, dann wird zusätzlich der Code aus der Anlage-Datei für dieses Objekt angezeigt</span>
</small></p>

<p><small><strong>Tastaturfunktionen</strong><br>
<kbd>&larr;</kbd> <kbd>&uarr;</kbd> <kbd>&rarr;</kbd> <kbd>&darr;</kbd> : Verschieben der Graphik (wenn zusammen mit <kbd>&#x21E7; Shift</kbd>, dann jeweils um eine halbe Seite)<br>
<kbd>+</kbd> <kbd>-</kbd> : Zoomen</small></p>

<p><small><strong>Interaktive Funktionen</strong><br>
Wechsel zwischen vertikaler und horizontaler Ausrichtung (Fullscreen mit <kbd>F11</kbd>)<br>
Zoom-in, -out, -reset<br>
Auswahl der anzuzeigenden Gleissysteme<br>
Auswahl der anzuzeigenden Informationen (GleisID, Gleisart, Gleisstil, Höhe, Weichen, Signale, Kontakte, Marker, Gleisobjekte, Kamera, Rahmen)<br>
Auswahl der anzuzeigenden Gleise (aktive/inaktive Gleise mit/ohne Rollmaterialien, sichtbare/unsichtbare Gleise)<br>
Aktuelle Darstellung als Bild (png/jpg/svg) speichern<br>
Gleisplan auf bestimmtes Gleis, bzw. das Gleis eines Signals oder Weiche positionieren<br>
Die Positionierung ist auch über das <a href="EEP_Inventar.html" target="_blank">Inventar</a>-Programm möglich!<br>
Einstellung der Linien- und Textbreite<br>
Auswahl der Gleise mit minimalem und maximalen Höhenfilter<br>
Farben der Gleissysteme anpassen
</small></p>

<p><small><strong>Referenzen / verwandte Programme</strong><br>
Diskussionbeitrag im <a href="https://www.eepforum.de/forum/thread/26770-eep-gleisplan-im-browser-anzeigen-javascript-projekt" target="_blank">EEP-Forum</a><br>
Entwicklungsprojekt auf <a href="https://github.com/FrankBuchholz/EEP_convert_anl3_file" target="_blank">GitHub</a><br>
Anzeige einer <a href="https://frankbuchholz.github.io/EEP_convert_anl3_file/EEP_Inventar.html" target="_blank">Inventarliste</a> zu einer EEP-Anlage<br>
Übersicht zu den <a href="https://frankbuchholz.github.io/EEP_convert_anl3_file/EEP_Signale.html" target="_blank">Signalstellungen</a> anhand der extrahierten .ini-Dateien zu Signalen (siehe EEP &rarr; Extras &rarr; Ressourcen-Extraktor)</small></p>
</article>

<article>
<p><small><strong>Technische Beschreibung</strong><br>
Dieses Programm nutzt die Javascript-Funktion <a href="https://www.w3schools.com/xml/xml_parser.asp" target="_blank">DOMParser</a> um eine <i>.anl</i>-Datei von EEP, die aus <a href="https://www.w3schools.com/xml/xml_tree.asp" target="_blank">XML</a> aufgebaut ist, zu interpretieren und in das <a href="https://www.w3schools.com/xml/xml_dom.asp" target="_blank">Document Object Model (DOM)</a> umzuwandeln.<br>
Anschließend wird dynamisch mit Javascript die Graphik des Gleisplanes mit <a href="https://www.w3schools.com/html/html5_svg.asp" target="_blank">SVG</a>-Befehlen aufgebaut. Die Formatierung der graphischen Elemente erfolgt getrennt von der Definition der Graphik mit der SVG-Variante von <a href="https://www.w3schools.com/html/html_css.asp" target="_blank">CSS</a>.<br>
Der Browser kann solche SVG-Graphiken direkt anzeigen. Zusätzlich werden die Bibliotheken <a href="https://github.com/ariutta/svg-pan-zoom" target="_blank">svg-pan-zoom</a> zum Verschieben und Zoomen und <a href="https://github.com/fluffynuts/toolwindow" target="_blank">toolwindow</a> zur Anzeige von Popups verwendet.<br>
Das Programm läuft in aktuellen Versionen von Google Chome und Firefox, nicht jedoch im Internet Explorer.</small></p>
</article>

<footer>
<p><small>(c) Frank Buchholz, 2020, mit Unterstützung von <a href="https://github.com/campersau" target="_blank">campersau</a> und <a href="https://github.com/EEP-Benny" target="_blank">Benny</a></small></p>
</footer>

<style> /* Selection screen */
#fileselector {
	margin: 15px;
}
#fileselector span.li {
	display: list-item;
	padding-top: 0.2em;
	margin-left: 2em;
}
</style>
<script type="text/javascript" src="rematrix/rematrix.js"></script> <!-- https://github.com/jlmakes/rematrix -->
<!-- <script type="text/javascript" src="https://unpkg.com/rematrix"></script> --> <!-- latest version -->
<!-- <script type="text/javascript" src="https://unpkg.com/rematrix@0.4.1/dist/rematrix.min.js"></script> --> <!-- version 0.4.1 -->
<script type="text/javascript"> // Load and process file
"use strict";

const global = {}; // Collection of all global variables

function loadFile(file) {
	let fr;
	if (typeof window.FileReader !== "function") {
		bodyAppend("p", "The file API isn't supported on this browser yet.");
		return;
	}

	if (!file) {
		bodyAppend("p", "Please select a file before clicking 'Load'");
		return;
	}
	else {
		global.timestamp = {};
		global.timestamp.start = Date.now();
	
		fr = { FileReader: new FileReader() }; // strict mode does not allow to unset read-only property 'result' directly, therfore we have to put the FileReader into an object 
		fr.FileReader.onload = processFile;
		fr.FileReader.readAsText(file);
	}

	// process file (local function to get access to local variable fr)
	function processFile() {
		global.timestamp.fileLoaded = Date.now();
		console.log('load file:' + (global.timestamp.fileLoaded - global.timestamp.start) / 1000 + 'sec');

		updateUi(function() {
			// Hide file selector
			document.getElementById("fileselector").classList.add("hidden");

			// Show loading
			document.getElementById("loading").classList.remove("hidden");
		}).then(function() {
			// Create parser
			var parser = new DOMParser();
			// Parse xml into DOM
			var xmlDoc = parser.parseFromString(fr.FileReader.result, "text/xml");
			//fr.FileReader.result = null; 	// we do not need the file content anymore, but in strict mode we cannot unset the property directly
			delete fr.FileReader;			// however, we can remove the whole thing (see http://perfectionkills.com/understanding-delete/ )

			global.timestamp.fileParsed = Date.now();
			console.log('parse file:' + (global.timestamp.fileParsed - global.timestamp.fileLoaded) / 1000 + 'sec');

			return xmlDoc;
		}).then(function(xmlDoc) {
			let progress = document.getElementById("progress");

			// Process root node (documentElement always represents the root node)
			const sutrackp = xmlDoc.documentElement;
			global.sutrackp = sutrackp;
			return createSVG(sutrackp, initProgress, incrementProgress);

			function initProgress(progressMax) {
				return updateUi(function() {
					progress.max = progressMax;
					progress.value = 0;
					progress.classList.remove("hidden");
				});
			}
			function incrementProgress() {
				return updateUi(function() {
					progress.value++;
				});
			}
		}).then(function() {
			// Hide loading
			document.getElementById("loading").classList.add("hidden");

			// Show main area
			document.getElementById("main").classList.remove("hidden");

			// Show file name
			document.getElementById("filename").textContent = file.name.substring(0, file.name.length -1 -1 -3);

			// Read settings from localStorage
			const strokeWidth = localStorage.getItem('strokeWidth') || document.getElementById("strokeWidth").value;					
			document.getElementById("strokeWidth").value = strokeWidth;
			const fontSize = localStorage.getItem('fontSize') || document.getElementById("fontSize").value;
			document.getElementById("fontSize").value = fontSize;
					
			for (let i = 0; i < localStorage.length; i++) {
				const key = localStorage.key(i);
				if (key.indexOf("checkbox_") === 0) { // Read checkbox settings
					const checkbox = document.querySelector(`input[type="checkbox"][name="${key.substring(9)}"]`);
					if (checkbox) {
						const value = localStorage.getItem(key) === "true";
						if (checkbox.checked !== value) {
							checkbox.checked = value;
							checkbox.dispatchEvent(new Event("change"));
						}
					}
				} else {
				}
			}
			
			loadColors();

			// Activate Pan and Zoom
			global.SvgPanZoom = SvgPanZoom();
			changefontSize(fontSize);
			changeStrokeWidth(strokeWidth);			
			return; 
			
		}, function(err) {
			// `</pre>` confuses syntax detection within Notepad++, therefore I've to use "</pre>"
			document.getElementById("loading").innerHTML = `Fehler beim Lesen der Datei:<br>${err.name}: "${err.message}" in line ${err.lineNumber}<br><pre>${err.stack}` + "</pre>";
			console.log(err);
		});
	}

}

// helper method which waits some time to let the browser update the ui
function updateUi(fn) {
	return new Promise(function(resolve) {
		requestAnimationFrame(function() {
			const result = fn();
			requestAnimationFrame(function() {
				resolve(result);
			});
		});
	});
}
</script>
<script type="text/javascript"> // DOM2SVG
"use strict";
// Process root node (sutrackp)
// EEP: Static texts
const GleissystemText = { 			// GleissystemID : Text,
	1 : "Eisenbahn",
	2 : "Straßenbahn",
	3 : "Straße",
	4 : "Wasserwege",
	5 : "Steuerstrecken",			// nicht in EEP 9
	6 : "GBS",						// nicht in EEP 9
};
const GleissystemCode = { 			// GleissystemID : Code,
	1 : "Eisenbahn",
	2 : "Strassenbahn",
	3 : "Strasse",
	4 : "Wasserwege",
	5 : "Steuerstrecken",			// nicht in EEP 9
	6 : "GBS",						// nicht in EEP 9
};

const Gleisart = { 					// clsid
	"2E25C8E2-ADCD-469A-942E-7484556FF932" : "Normal",
	"C889EADB-63B5-44A2-AAB9-457424CFF15F" : "Weiche",
	"B0818DD8-5DFD-409F-8022-993FD3C90759" : "3-Weg-Weiche",
	"06D80C90-4E4B-469B-BFE0-509A573EBC99" : "Prellbock",
};
	
// GleisData
const GleisDataText = {
	1	: 'Oberleitung',
	2	: 'Weichenlaterne verstecken ',
	3	: 'Oberleitung, Weichenlaterne verstecken ',
	4	: 'Weichenlaterne rechts',
	5	: 'Oberleitung, Weichenlaterne rechts',
	8	: 'Weichenlaterne links',
	9	: 'Oberleitung, Weichenlaterne links',
	16	: 'Weichenlaterne als Immobilie/Straßen-T-Kreuzung',
	18	: 'Doppelkreuzungsweiche',
	19	: 'Oberleitung, Doppelkreuzungsweiche',
	20	: 'Straßen-T-Kreuzung',
};

// Weichenstellung
const WeichenstellungText = { 	
	1 : 'Durchfahrt',
	2 : 'Abzweig',
	3 : 'KoAbzweig',
	5 : 'Spezial',
};

const GebaeudesammlungText = {		// GebaeudesammlungID : Text,
	1 : 'Eisenbahn', 
	2 : 'Straßenbahn', 
	3 : 'Gleisobjekte Straßen', 
	4 : 'Immobilien',
	5 : 'Landschaftselemente', 
	6 : 'Sonstiges', 
}

/* Gleisstile:
http://up.picr.de/33875489iu.pdf
http://bahn.hersacher.de/splinekatalog/spkat_intro.htm
*/
const unsichtbar = [			// unsichtbare Gleisstile
17,		// \Gleisstile\Sonstiges\Wasserweg_unsichtbar.3dm
28,		// Gleis
35,		// Straßenbahn
34,		// \Gleisstile\Sonstiges\Wasserweg_unsichtbar.3dm
36,		// \Gleisstile\Strassen\unsichtbar.3dm
562,	// Gleis
1346,	// Gleis
2052,	// \Gleisstile\Gleise\Unsichtbares_Gleis_m_OL_UB3.3dm
3425, 	// \Gleisstile\Strassen\1Spur_unsichtbar_AS3.3dm
5100,	// \Gleisstile\Gleise\Unsichtbar_RB2.3dm
100000,	// Kamerafahrweg
/*
18,		// \Gleisstile\Sonstiges\telegraph.3dm
70,		// \Gleisstile\Sonstiges\Stuetzmauer_Lauscha.3dm
85,		// \Gleisstile\Strassen\Leitplanke.3dm
92,		// \Gleisstile\Gleise\Bahnsteig.3dm
102,	// \Gleisstile\Sonstiges\Gitterzaun.3dm
134,	// \Gleisstile\Gleise\Bahnsteig_KoelnHbf.3dm
184,	// \Gleisstile\Sonstiges\Gelaender.3dm
264,	// \Gleisstile\Gleise\Bahnsteig_Hohenfels.3dm
731,	// \Gleisstile\Gleise\Bhst900_Kreihnsdoerp.3dm
732,	// \Gleisstile\Gleise\Bhst1350_Kreihnsdoerp.def
851,	// \Gleisstile\Sonstiges\851_Gelaender_mit_Stuetze_AF1.3dm
927,	// \Gleisstile\Sonstiges\Schallschutzwand.3dm
1246,	// \Gleisstile\Sonstiges\Sicherheitszaun.3dm
1307,	// \Gleisstile\Sonstiges\Gleis_Abdeckung_C_LW1.3dm
1380,	// \Gleisstile\Sonstiges\Fuehrungsschiene_R_LW1.3dm
1381,	// \Gleisstile\Sonstiges\Nur Fahrdraht_MM_LW1.3dm
1393,	// \Gleisstile\Sonstiges\LW1_Gleis_Fahrdraht_mitte.3dm
1399,	// \Gleisstile\Sonstiges\LW1_Gleis_Fahrdraht_ende.3dm
1401,	// \Gleisstile\Sonstiges\LW1_Gleis_Quertraeger_unten.3dm
1402,	// \Gleisstile\Sonstiges\LW1_Gleis_Quertraeger_oben.3dm		
1412,	// \Gleisstile\Sonstiges\LW1_Gleis_Fahrdraht_anf.3dm
1414,	// \Gleisstile\Sonstiges\LW1_Gleis_Fahrdraht_spann.3dm
1445,	// \Gleisstile\Sonstiges\LW1_Gleis_Quertraeger_Stahl_LW1.3dm
1448,	// \Gleisstile\Sonstiges\LW1_Gleis_Quertraeger_leer.3dm
1449,	// \Gleisstile\Sonstiges\LW1_Gleis_Schallschutz_Stuetzmauer_LW1.3dm
1450,	// \Gleisstile\Sonstiges\LW1_Gleis_Spannungsver_A.3dm
1601,	// \Gleisstile\Sonstiges\1601_Gelaender_mit_Stuetze_AF1.3dm
1738,	// \Gleisstile\Sonstiges\Kabelkanal1_MA1.3dm
1958,	// \Gleisstile\Sonstiges\3DVersion\Lattenzaun-3D_SM1.3dm
1959,	// \Gleisstile\Sonstiges\3DVersion\Jaegerzaun-3D_SM1.3dm
1974,	// \Gleisstile\Sonstiges\Steinmauer3_SM1.3dm
1978,	// \Gleisstile\Sonstiges\Arkadenmauer-2gl_SM1.3dm
1979,	// \Gleisstile\Sonstiges\Arkadenmauer-4gl_SM1.3dm
1982,	// \Gleisstile\Sonstiges\3DVersion\Arkadenmauer-einseitig-3D_SM1.3dm
1995,	// \Gleisstile\Sonstiges\Schutzmauer_2_MA1.3dm
2304,	// \Gleisstile\Sonstiges\DB-Gelaender_SB3.3dm
2381,	// \Gleisstile\Sonstiges\DB-Gelaender_10_SB3.3dm
2386,	// \Gleisstile\Sonstiges\Schallschutzwand_grau_SB3.3dm
2387,	// \Gleisstile\Sonstiges\Schallschutzwand_gruen_SB3.3dm
2581,	// \Gleisstile\Sonstiges\BMauer_eben_0_HW1.3dm
5008,	// \Gleisstile\Sonstiges\3DVersion\Sicherheitszaun_mit_Stacheldragt_3D.3dm	
5085,	// \Gleisstile\Sonstiges\3DVersion\Hedge_1m_Cypress.3dm
5138,	// \Gleisstile\Sonstiges\3DVersion\ParkHotel_Harz_Zaun.3dm
5145, 5146, 5147, // Farm track
5213,	// \Gleisstile\Sonstiges\3DVersion\Ebrzgl.3dm
5261,	// \Gleisstile\Sonstiges\3DVersion\Schutzplanke_einfach_MA1.3dm
5262,	// \Gleisstile\Sonstiges\3DVersion\Schutzplanke_zweifach_MA1.3dm
5263,	// \Gleisstile\Sonstiges\3DVersion\Schutzplanke_doppel_MA1.3dm
5271,	// \Gleisstile\Sonstiges\IndZaun_Zaun_AE1.3dm
5272,	// \Gleisstile\Sonstiges\IndZaun_Zaun_TT1_AE1.3dm
5274,	// \Gleisstile\Sonstiges\IndZaun_Zaun_TT3_AE1.3dm
5602,	// Fence
7411,	// \Gleisstile\Strassen\Leitpl_3D_mit_Pf_UFS_DH1.3dm
7412,	// \Gleisstile\Sonstiges\Doppel_T_Trg_30x30_blau_DH1.3dm
*/
	];

function createSVG(sutrackp, initProgress, incrementProgress) {
	const Gleissysteme = prepareGleissysteme(sutrackp);

	// Append new svg elements to this root node which we append to the svg node later
	const SVGfragment = document.createDocumentFragment();

	return initProgress(Gleissysteme.length).then(function() {
		let promise = null;
		for (const Gleissystem of Gleissysteme) {
			if (promise === null) {
				createSVGforGleissystem(Gleissystem, SVGfragment);
				promise = incrementProgress();
			} else {
				promise = promise.then(function() { 
					createSVGforGleissystem(Gleissystem, SVGfragment); 
					return incrementProgress(); 
				});
			}
		}
		return promise;

	}).then(function() { 
		createSVGfinalize(SVGfragment);
		return;
	});

function prepareGleissysteme(sutrackp) {

	// Verwendeter Bereich der Anlage
	global.usedArea = {
		min : {x : 0, y : 0, z : 0},
		max : {x : 0, y : 0, z : 0},
	};

	const Version = sutrackp.getElementsByTagName("Version")[0];
	if (Version) {
		global.EEPversion = Version.getAttribute("EEP");	
		if (global.EEPversion >= 16) {
			document.getElementById("CheckboxCurveType").classList.remove("hidden");
		}
	}

	// Collections for direct access
	global.Gleissysteme 	= {};	// Verwendung: Gleis = global.Gleissysteme[GleissystemID][GleisID];
	global.Meldungen 		= {};
	global.Weichen 			= {};
	global.Kontakte			= {};
	global.KontaktZiele		= {};
	global.Kameras 			= {};	// Verwendung: Kamera = global.Kameras[Name];
	global.KameraSet 		= {};	// Verwendung: Kamera = global.KameraSet[index];
	global.Gleisobjekte		= {};
	global.Routen			= {};
	global.Sounds			= {};

	// <Options RouteItems="5" SndId_0="6" SndName_0="ZIEGEN.WAV" SoundItems="1" RouteId_0="1" RouteName_0="Nahverkehr" RouteId_1="2" RouteName_1="Schnellzug" RouteId_2="3" RouteName_2="Gueter" RouteId_3="4" RouteName_3="Nebenbahn" RouteId_4="5" RouteName_4="Sonderzug"/>
	const Options = sutrackp.getElementsByTagName("Options")[0];
	const RouteItems = +Options.getAttribute('RouteItems');
	for (let i = 0; i < RouteItems; i++) {
		const RouteID	= Options.getAttribute('RouteId_' + i);
		const RouteName = Options.getAttribute('RouteName_' + i);
		
		global.Routen[RouteID] = RouteName;
	}	
	const SoundItems 	= +Options.getAttribute("SoundItems");
	for (let i = 0; i < SoundItems; i++) {
		const SoundID 	= Options.getAttribute("SndId_" + i);
		const SoundName = Options.getAttribute("SndName_" + i);
		
		global.Sounds[SoundID] = SoundName;
	}

	// Preparation: Collect "active" tracks
	const activeTracks = [];		// Gleise, auf denen Züge stehen oder die Kontakte bzw. Signale enthalten
									// oder die mit solchen Gleisen verbunden sind
	// Preparation: Collect connected tracks
	const trackConnections = [];	// Gleisverbindungen

	// Preparation: Collect signals on tracks
	const trackSignals = [];		// Vor- und Hauptsignale

	const Gleissysteme 	= sutrackp.getElementsByTagName("Gleissystem");
	for (const Gleissystem of Gleissysteme) {

		// Use attribute TrackSystemNumber instead of GleissystemID if available
		let GleissystemID 	= Gleissystem.getAttribute("TrackSystemNumber");
		if (!GleissystemID) {
			GleissystemID 	= Gleissystem.getAttribute("GleissystemID");
		}
		global.Gleissysteme[GleissystemID] = {};
		activeTracks[GleissystemID] = [];
		trackSignals[GleissystemID] = [];

		const Gleise 			= Gleissystem.getElementsByTagName("Gleis");
		for (const Gleis of Gleise) {
			const GleisID 	= Gleis.getAttribute("GleisID");
			Gleis.GleissystemID = GleissystemID;
			global.Gleissysteme[GleissystemID][GleisID] = Gleis;
			
			// Weichen
			const WeicheID = Number(Gleis.getAttribute("Key_Id"));
			global.Weichen[WeicheID] = Gleis;

			// Weichen mit KontaktZiel 
			const KontaktZielEntry 	= Gleis.getElementsByTagName("KontaktZiel")[0];
			if (KontaktZielEntry) {
				const KontaktZiel 	= KontaktZielEntry.textContent;
				if (KontaktZiel != null && KontaktZiel != 0) {
					global.KontaktZiele[KontaktZiel] = { 
						Typ				: 'Weiche',
						ID				: WeicheID,
						GleissystemID 	: GleissystemID,
						GleisID			: GleisID,
					}
				}
			}

			// Collect Meldungen to be able to create individual symbols for Vor- and Hauptsignal
			for (const Meldung of Gleis.getElementsByTagName("Meldung")) {
				const SignalID = Number(Meldung.getAttribute("Key_Id"));
				Meldung.GleissystemID = GleissystemID;
				Meldung.GleisID = GleisID;
				global.Meldungen[SignalID] = Meldung;

				if (!trackSignals[GleissystemID][GleisID]) {
					 trackSignals[GleissystemID][GleisID] = [];
				}
				trackSignals[GleissystemID][GleisID].push({Meldung : Meldung});
				
				// Signale mit KontaktZiel 
				const KontaktZielEntry 	= Meldung.getElementsByTagName("KontaktZiel")[0];
				if (KontaktZielEntry) {
					const KontaktZiel 	= KontaktZielEntry.textContent;
					if (KontaktZiel != null && KontaktZiel != 0) {
						global.KontaktZiele[KontaktZiel] = { 
							Typ 			: 'Signal',
							ID				: SignalID,
							GleissystemID 	: GleissystemID,
							GleisID			: GleisID,
						}
					}
				}
			}
			
			// Signale, die nur zur Anzeige dienen und keine Züge beeinflussen sollen werden gerne auf "inaktive" Gleise gesetzt.
			// Alternativ könnte man nicht-verbundene Einzelgleise als "inaktive" interpretieren.
			// A track having a Signal is an "active" track
			/*
			for (const Meldung of Gleis.getElementsByTagName("Meldung")) {
				if (!activeTracks[GleissystemID].includes(GleisID)) {
					 activeTracks[GleissystemID].push(GleisID);
				}
			}
			*/
			
			// Kontakte
			// A track having a Kontakt is an "active" track
			for (const Kontakt of Gleis.getElementsByTagName("Kontakt")) {
				if (!activeTracks[GleissystemID].includes(GleisID)) {
					 activeTracks[GleissystemID].push(GleisID);
				}
			}
		} // Gleise

		// Gleisverbindungen
		trackConnections[GleissystemID] = [];
		const Gleisverbindungen = Gleissystem.getElementsByTagName("Gleisverbindung");
		for (const Gleisverbindung of Gleisverbindungen) {
			// <Gleisverbindung GleisID1="1" Anschluss1="Anfang" GleisID2="5" Anschluss2="Anfang" Flags="1"/>
			// Verwendung:
			// prevGleisID   		= trackConnections[GleissystemID][GleisID].Anfang.GleisID
			// prevGleisAnschluss 	= trackConnections[GleissystemID][GleisID].Anfang.Anschluss
			// nextGleisID   		= trackConnections[GleissystemID][GleisID].Ende.GleisID
			// nextGleisAnschluss	= trackConnections[GleissystemID][GleisID].Ende.Anschluss
			// ..
			const GleisID1 		= Gleisverbindung.getAttribute("GleisID1");
			const Anschluss1 	= Gleisverbindung.getAttribute("Anschluss1");
			const GleisID2 		= Gleisverbindung.getAttribute("GleisID2");
			const Anschluss2 	= Gleisverbindung.getAttribute("Anschluss2");
			const Flags 		= Gleisverbindung.getAttribute("Flags");		// undefined: normal connection, 1: virtual connection

			// Store relation GleisID1 -> GleisID2
			if (!trackConnections[GleissystemID][GleisID1]) {
				 trackConnections[GleissystemID][GleisID1] = {};
			}
			trackConnections[GleissystemID][GleisID1][Anschluss1] = { GleisID : GleisID2, Anschluss : Anschluss2, Flags : Flags };

			// Store relation GleisID2 -> GleisID1
			if (!trackConnections[GleissystemID][GleisID2]) {
				 trackConnections[GleissystemID][GleisID2] = {};
			}
			trackConnections[GleissystemID][GleisID2][Anschluss2] = { GleisID : GleisID1, Anschluss : Anschluss1, Flags : Flags };
		}
	}
	// Now we are able to show connections on detail popups
	global.trackConnections = trackConnections;
	
	// Meldungen analysieren um Fahrstraßen sowie Vor- zu Hauptsignele zu separieren
	for (const GleissystemID in trackSignals) {
		for (const GleisID in trackSignals[GleissystemID]) {
			for (const entry of trackSignals[GleissystemID][GleisID]) {
				if (entry.signalType) { continue; } // we have added the entry during the loop, however, for..of does not process new entries anyway

				let currentGleisID 	= GleisID;	// Let"s start with the current track
				
				const SignalID		= entry.Meldung.getAttribute("Key_Id");
				let   Position		= entry.Meldung.getAttribute("Position") / 100; 	// Wert zwischen 0 und Gleis.Laenge
				let   ParaOderAnti 	= entry.Meldung.getAttribute("ParaOderAnti"); 	//Gleisrichtung: 0 = Ende -> Anfang, 1 = Anfang -> Ende
				const Distanz		= entry.Meldung.getElementsByTagName("Signal")[0].getAttribute("wirkungsdistanz") / 100; // immmer positiv
				
				const Name 			= entry.Meldung.getAttribute("name"); // Fahrstraßen: name = "system\Route_SignalS.3ds" bzw. "system\Route_SignalZ.3ds"
				const Routes		= entry.Meldung.getAttribute("Routes"); // Fahrstraßen Start: Routes > 0

				// Store signal data
				entry.SignalID		= SignalID;
				entry.Position 		= Position;
				entry.ParaOderAnti 	= ParaOderAnti;

				// Für Fahrstraßen gilt: name="system\Route_SignalS.3ds" für den Start bzw. name="system\Route_SignalZ.3ds" für das Ziel
				// (Außerdem besitzt die Meldung zu Beginn einer Fahrstraße weitere Elemente <Route> usw.
				if (Name === "system\\Route_SignalS.3ds") {
					entry.signalType 	= "FStart";					// Fahrstraße Start
					continue;
				} else if (Name === "system\\Route_SignalZ.3ds") {
					entry.signalType 	= "FZiel";					// Fahrstraße Ziel
					continue;
				} else if (Distanz == 0) {
					entry.signalType 	= "single";					// Einzel-Signal
					continue;
				}
			
				// Store Vorsignal
				entry.signalType 	= "pre";						// Vorsignal
				
				// Now we can follow the tracks to find the position of the main signal on the track
				let Gleis 	= global.Gleissysteme[GleissystemID][currentGleisID];	// current track
				let Laenge
				if (global.EEPversion && global.EEPversion >= 16) { /* EEP 16 */
					const Interval 	= Gleis.getElementsByTagName("Interval")[0];
					const near		= +Interval.getAttribute("near");
					const far 		= +Interval.getAttribute("far");
					Laenge	= Math.abs( far - near );
				} else {  /* EEP 15 */
					const Charakteristik = Gleis.getElementsByTagName("Charakteristik")[0];
					Laenge	= +Charakteristik.getAttribute("Laenge") / 100;
				}
				
				// Do we find the main signal on the same track?
				Position = Position + Distanz * (ParaOderAnti == 1 ? 1 : -1);
				if (Position >= 0 && Position <= Laenge) {
					// The main signal is on the same track
					trackSignals[GleissystemID][currentGleisID].push({
						Meldung 		: entry.Meldung,
						SignalID		: SignalID,
						signalType 		:"main",
						Position 		: Position,
						ParaOderAnti	: ParaOderAnti,
					});
					continue;
				}

				if (Position > Laenge) { 					// look forward
					Position	= Position - Laenge;		// remaining position on next track
				} else {									// look backward
					Position	= -Position;				// remaining position on previous track
				}
				
				// The main signal is on a different track
				while (Position > 0) {
					let nextGleisID, Anschluss;

					if (!trackConnections[GleissystemID][currentGleisID]) { // should not happen
						console.log(`Error: Signal ${SignalID} no connected track for ${GleissystemText[GleissystemID]} ${currentGleisID}`);
						break;
					}
					
					if (ParaOderAnti == 1) { // look forward
				
						if (!trackConnections[GleissystemID][currentGleisID].Ende) { // should not happen
							console.log(`Error: no connected track for ${GleissystemText[GleissystemID]} ${currentGleisID}.Ende`);
							break;
						}
						
						nextGleisID		= trackConnections[GleissystemID][currentGleisID].Ende.GleisID;
						Anschluss		= trackConnections[GleissystemID][currentGleisID].Ende.Anschluss;
						ParaOderAnti	= (Anschluss === "Anfang" ? ParaOderAnti : 1-ParaOderAnti);
						
					} else {				// look backward

						if (!trackConnections[GleissystemID][currentGleisID].Anfang) { // should not happen
							console.log(`Error: Signal ${SignalID} no connected track for ${GleissystemText[GleissystemID]} ${currentGleisID}.Anfang`);
							break;
						}					

						nextGleisID		= trackConnections[GleissystemID][currentGleisID].Anfang.GleisID;
						Anschluss		= trackConnections[GleissystemID][currentGleisID].Anfang.Anschluss;
						ParaOderAnti	= (Anschluss !== "Anfang" ? ParaOderAnti : 1-ParaOderAnti);
					}
					
					Gleis 	= global.Gleissysteme[GleissystemID][nextGleisID];
					if (!Gleis) { // should not happen
						console.log(`Error: Signal ${SignalID} no track for ${GleissystemID}-${nextGleisID}`);
						break;
					}
					
					let Laenge
					if (global.EEPversion && global.EEPversion >= 16) { /* EEP 16 */
						const Interval 	= Gleis.getElementsByTagName("Interval")[0];
						const near		= +Interval.getAttribute("near");
						const far 		= +Interval.getAttribute("far");
						Laenge	= Math.abs( far - near );
					} else {  /* EEP 15 */
						const Charakteristik = Gleis.getElementsByTagName("Charakteristik")[0];
						Laenge	= +Charakteristik.getAttribute("Laenge") / 100;
					}
				
					if (Position <= Laenge) {
						// The main signal is on the this track
						if (!trackSignals[GleissystemID][nextGleisID]) {
							 trackSignals[GleissystemID][nextGleisID] = [];
						}
						trackSignals[GleissystemID][nextGleisID].push({
							Meldung 		: entry.Meldung,
							SignalID		: SignalID,
							signalType 		:"main",
							Position 		: (Anschluss === "Anfang" ? Position : Laenge - Position),
							ParaOderAnti	: ParaOderAnti,
						});
						break;

					} else {
						// keep going
						currentGleisID 	= nextGleisID;
						Position 		= Position - Laenge;
					}
				} // while searching for tracks
				
			} // Signale
		} // Gleise
	} // Gleissysteme

	// Now we are able to show all signals in the svg-output
	global.trackSignals = trackSignals;
	
	// Analyse Fuhrpark to identify "active" tracks
	const Fuhrpark = sutrackp.getElementsByTagName("Fuhrpark")[0];
	if (Fuhrpark) {
	for (const Zugverband of Fuhrpark.getElementsByTagName("Zugverband")) {
		// <Gleisort gleissystemID="3" gleisID="41" parameter="1177.944" ausrichtung="0"/>
		const Gleisort		= Zugverband.getElementsByTagName("Gleisort")[0];
		const GleissystemID	= Gleisort.getAttribute("gleissystemID");
		const GleisID		= Gleisort.getAttribute("gleisID");

		// A track with a Zugverband is an "active" track
		if (!activeTracks[GleissystemID].includes(GleisID)) {
			 activeTracks[GleissystemID].push(GleisID);
		}
	}
	}

	// Lade Kollektor-Einträge, die Gleise miteinander verbinden, z.B. bei bestimmten Drehscheiben 
	/* Beispiel:
	<Kollektor id="8">
		<Gleis gleisID="171" gleissystemID="1"/>
		<Gleis gleisID="172" gleissystemID="1"/>
		<Gleis gleisID="173" gleissystemID="1"/>
		...
	</Kollektor>
	*/
	const Gleisobjekte = {};
	let countGleisobjekte = 0;
	const KollektorTracks = {};
	for (const Kollektor of sutrackp.getElementsByTagName("Kollektor")) {
		const KollektorID = Kollektor.getAttribute("id");

		const Dreibein 	= Kollektor.getElementsByTagName("Dreibein")[0];
		const Vektor 	= Dreibein.getElementsByTagName("Vektor")[0];
		const PosZ 		= +Vektor.getAttribute("z") / 100;

		const Kollektors = Kollektor.getElementsByTagName("Gleis");
		
		for (const Gleis of Kollektors) {
			const GleissystemID = Gleis.getAttribute("gleissystemID");
			const GleisID 		= Gleis.getAttribute("gleisID");

			// First entry of Kollektor
			if (!Gleisobjekte[KollektorID]) {
				countGleisobjekte += 1;
				Gleisobjekte[KollektorID] = { 
					GleissystemID 	: GleissystemID, 
					PosZ 			: PosZ, 
					Gleise 			: [],
				};
			}
			// Store Gleis of Kollektor
			Gleisobjekte[KollektorID].Gleise.push({GleissystemID : GleissystemID, GleisID : GleisID, });
			
			// connected tracks
			// First entry of Gleissystem
			if (!KollektorTracks[GleissystemID]) {
				KollektorTracks[GleissystemID] = {};
			}
			// New Gleis (we assume that a Gleis is part of exactly 1 Gleisobjekt only)
			KollektorTracks[GleissystemID][GleisID] = [];
			KollektorTracks[GleissystemID][GleisID].KollektorID = KollektorID;
			// connected tracks
			for (const Gleis of Kollektor.getElementsByTagName("Gleis")) {
				const GleissystemID2 = Gleis.getAttribute("gleissystemID");
				const GleisID2 		 = Gleis.getAttribute("gleisID");
				if (GleisID !== GleisID2) {
					KollektorTracks[GleissystemID][GleisID].push({
						GleissystemID : GleissystemID2, 
						GleisID : GleisID2, 
					});
				}
			}
		}
	}

	// Load Immobilien if there exist Gleisobjekte
	if (countGleisobjekte > 0) { //# How to identity empty objects?
		for (const Gebaeudesammlung of sutrackp.getElementsByTagName("Gebaeudesammlung")) {
			const GebaudesammlungID = Gebaeudesammlung.getAttribute("GebaudesammlungID");
			for (const Immobile of sutrackp.getElementsByTagName("Immobile")) {
				const KollektorID 	= Immobile.getAttribute("kollektorID");
				if (KollektorID) {
					const ImmoIdx 	= Immobile.getAttribute("ImmoIdx");
					const gsbname 	= Immobile.getAttribute("gsbname");
					
					// Take care of inconsistend data: Immobilie without Kollektor 
					if (!Gleisobjekte[KollektorID]) {
						Gleisobjekte[KollektorID] = { Error : 'missing Kollector', };
					}
					
					Gleisobjekte[KollektorID].GebaudesammlungID	= GebaudesammlungID;
					Gleisobjekte[KollektorID].ImmoIdx 			= ImmoIdx;
					Gleisobjekte[KollektorID].gsbname 			= gsbname;
				}
			}
		}
	}
	global.Gleisobjekte = Gleisobjekte;
	global.KollektorTracks = KollektorTracks;
	
	// Add connected tracks as "active" tracks because they can be reached by trains as well
	for (const GleissystemID in activeTracks) {
		const usedGleiseArray = activeTracks[GleissystemID];
		
		// Extend "active" tracks
		for (let i = 0; i < usedGleiseArray.length; i++){ // old-fashioned for statement because we need to extend the array within the loop
			const GleisID1 = usedGleiseArray[i];

			// Get connected tracks of "active" tracks
			const connectedTracks = trackConnections[GleissystemID][GleisID1];
			if (connectedTracks) {			
				for (const Anschluss in connectedTracks) {
					// Add new connected tracks
					// These tracks will be processed, too
					if (!activeTracks[GleissystemID].includes(connectedTracks[Anschluss].GleisID)) {
						 activeTracks[GleissystemID].push(connectedTracks[Anschluss].GleisID);
					}
				}
			}

			// Get related tracks from Kollektors
			if (KollektorTracks[GleissystemID]) {
				const collectedTracks = KollektorTracks[GleissystemID][GleisID1];
				if (collectedTracks) {			
					for (const Gleis of collectedTracks) {
						// Add new connected tracks
						// These tracks will be processed, too
						if (!activeTracks[Gleis.GleissystemID].includes(Gleis.GleisID)) {
							 activeTracks[Gleis.GleissystemID].push(Gleis.GleisID);
						}
					}
				}
			}
		
			
		}
	}
	// Now we are able to mark all "active" tracks in the svg-output
	global.activeTracks = activeTracks;
	
	return Gleissysteme;
}

function createSVGforGleissystem(Gleissystem, SVGfragment) {
	// Use attribute TrackSystemNumber instead of GleissystemID if available
	let GleissystemID 	= Gleissystem.getAttribute("TrackSystemNumber");
	if (!GleissystemID) {
		GleissystemID 	= Gleissystem.getAttribute("GleissystemID");
	}

	// Append groups to the root node; append other elements to these group nodes
	const svgGleissystemGroup = svgAppend(SVGfragment, {
		svg_tag	: `g`,
		'class'	: `${GleissystemCode[GleissystemID]}`,
	});

	const Gleise = Gleissystem.getElementsByTagName("Gleis");

	// Zeige die Checkbox zum ein-/ausblenden (und andere Elemente) nur dann an, wenn ein Gleissystem auch Gleise enthält
	if (Gleise.length > 0) {
		for (const ele of document.getElementsByClassName(GleissystemCode[GleissystemID])) {
			ele.classList.remove("hidden");
		}
	}

	// Process Gleise
	for (const Gleis of Gleise) {

	/* Example:
	<Gleis GleisID="1" clsid="2E25C8E2-ADCD-469A-942E-7484556FF932" data="0" scale="1" ElectSideS="0" ElectSideE="0" stil="1353" gsbname="\Gleisstile\Gleise\Beton2_Sch_C_LW1.3dm" LockEd="0">
		<Dreibein>
			<Vektor x="-12359.88" y="-1854.389" z="30">Pos</Vektor>
			<Vektor x="0.699066" y="-0.715057" z="0">Dir</Vektor>
			<Vektor x="0.715057" y="0.699066" z="0">Nor</Vektor>
			<Vektor x="-0" y="0" z="1">Bin</Vektor>
		</Dreibein>
		<Anfangsfuehrungsverdrehung Wert="0"/>
		<Charakteristik Kruemmung="0" Torsion="0" Fuehrungsverdrehung="-0" Kurve="0" Laenge="2580"/>
	</Gleis>
	*/

	/*
	Das Kordinatensystem von SVG ist gegenüber dem üblichen Koordinatensystem (also auch dem von EEP) an der x-Achse gespiegelt.
	Die Spiegelung ließe sich über CSS einfach zurücknehmen:
	svg { transform: scale(1,-1); }
	Damit würde allerdings auch der Text gespiegelt und müsste daher erneut gespiegelt und verschoben werden.
	Daher werden hier stattdessten alle y-Koordinaten und y-Winkel negativ angegeben (also z.Z. -PosY -DirY -NorY)
	Statt cm soll als Einheit m verwendet werden, daher wird Laenge, Kruemmung, PosX und PosY geeignet skaliert.
	*/

		const GleisID 	= Gleis.getAttribute("GleisID");
		const clsid 	= Gleis.getAttribute("clsid");		// Gleisart
		const stil 		= Gleis.getAttribute("stil");		// Gleisstil
		const gsbname 	= Gleis.getAttribute("gsbname");	// Dateiname
		const Key_Id	= Gleis.getAttribute("Key_Id"); 	// Id einer Weiche
		const GleisData	= Gleis.getAttribute("data"); 		// Bitfeld einer Weiche
															// 1: Oberleitung
															// 18: DKW (Weichen und zentrale Gleise)
															// 16: Zentrale Strecken einer Straßen-T-Kreuzung
															// 20: Weichen einer Straßen-T-Kreuzung

		let CurveType, Laenge, Kruemmung, mMatrix;
		let PosX, PosY, PosZ, DirX, DirY, DirZ, NorX, NorY, NorZ, BinX, BinY, BinZ;

		if (global.EEPversion && global.EEPversion >= 16) { /* EEP 16 */
		
			// Common attributes
			const Curve 	= Gleis.getElementsByTagName("Curve")[0];

			const Interval 	= Gleis.getElementsByTagName("Interval")[0];
			const near 		= +Interval.getAttribute("near");
			const far 		= +Interval.getAttribute("far");
			
if (near > far) { console.log('near ' + near + ' > far ' + far + ' for '
	+ GleissystemText[GleissystemID] + ' ' + GleisID
)}			
			const Frame		= Gleis.getElementsByTagName("Frame")[0];
			const FramePos	= Frame.getElementsByTagName("Position")[0];
			const FrameDir	= Frame.getElementsByTagName("Vector")[0];
			/* Strange: Sometimes we need to swap Nor and Bin  
			which would be a matrix multiplication with
			1 0 0 0
			0 1 0 0 
			0 0 0 1
			0 0 1 0
			*/
			const swap = (   Math.abs(+Frame.getElementsByTagName("Vector")[1].getAttribute("dz")) > 0.99
						  && Math.abs(+Frame.getElementsByTagName("Vector")[2].getAttribute("dz")) < 0.01 
						  ? true : false);
			const FrameNor	= Frame.getElementsByTagName("Vector")[(swap ? 2 : 1)];
			const FrameBin	= Frame.getElementsByTagName("Vector")[(swap ? 1 : 2)];
if (swap) { console.log('Swap frame vektor Nor<->Bin for '
	+ GleissystemText[GleissystemID] + ' ' + GleisID
)}
			
			Laenge	= Math.abs( far - near );
			
			// Depending on CurveType some adjustments will be done later
			PosX	= +FramePos.getAttribute("x");
			PosY	= -FramePos.getAttribute("y");
			PosZ	= +FramePos.getAttribute("z");
			
			DirX	= +FrameDir.getAttribute("dx");
			DirY	= -FrameDir.getAttribute("dy");
			DirZ	= +FrameDir.getAttribute("dz");
			
			NorX	= +FrameNor.getAttribute("dx");
			NorY	= -FrameNor.getAttribute("dy");
			NorZ	= +FrameNor.getAttribute("dz");
			
			BinX	= +FrameBin.getAttribute("dx");
			BinY	= -FrameBin.getAttribute("dy");
			BinZ	= +FrameBin.getAttribute("dz");
			
			if (DirX == 0 && DirY == 0 && DirZ == 1 && NorX != 0 && NorY != 0 && NorZ == 0) { // wrong order Bin - Dir - Nor
				const FrameBin	= Frame.getElementsByTagName("Vector")[0];
				const FrameDir	= Frame.getElementsByTagName("Vector")[1];
				const FrameNor	= Frame.getElementsByTagName("Vector")[2];
				
				DirX		= +FrameDir.getAttribute("dx");
				DirY		= -FrameDir.getAttribute("dy");
				DirZ		= +FrameDir.getAttribute("dz");
				
				NorX		= +FrameNor.getAttribute("dx");
				NorY		= -FrameNor.getAttribute("dy");
				NorZ		= +FrameNor.getAttribute("dz");
				
				BinX		= +FrameBin.getAttribute("dx");
				BinY		= -FrameBin.getAttribute("dy");
				BinZ		= +FrameBin.getAttribute("dz");
			}			
/*
if (DirX == -NorY ) { 
	console.log(GleissystemText[GleissystemID] + ' ' + GleisID
		+ ' DirX == -NorY'
	);
}			
if (BinZ == -1 ) {
	console.log(GleissystemText[GleissystemID] + ' ' + GleisID
		+ ' BinZ == -1'
	);
	//BinZ = 1;
}	
*/

			//mMatrix = Rematrix.format([DirX, DirY, NorX, NorY, PosX, PosY]);
			// Rematrix.format maps short form [DirX, DirY, NorX, NorY, PosX, PosY] to long form:
			//  	   0     1     2     3     4     5     6     7     8     9     10    11    12    13    14    15  
			// 		  [DirX, DirY, 0,    0,    NorX, NorY, 0,    0,    0,    0,    0,    0,    PosX, PosY, 0,    1 ]
			mMatrix = [DirX, DirY, DirZ, 0,    NorX, NorY, NorZ, 0,    BinX, BinY, BinZ, 0,    PosX, PosY, PosZ, 1 ];
				
			// Identify CurveType
			const EEPCurve  = Curve.getElementsByTagName("EEPCurve")[0];
			const Line		= Curve.getElementsByTagName("Line")[0];
			const Arc		= Curve.getElementsByTagName("Arc")[0];
			const Helix		= Curve.getElementsByTagName("Helix")[0];
			const Clothoid	= Curve.getElementsByTagName("Clothoid")[0];
			const Cubic		= Curve.getElementsByTagName("Cubic")[0];
			const Rotator	= Curve.getElementsByTagName("Rotator")[0];
			const RotatorChain	= Curve.getElementsByTagName("RotatorChain")[0];
			
			// Get track geometry per CurveType
			if (EEPCurve) {	// EEPCurve = Line or Arc
				CurveType 	= 'EEPCurve';
				Kruemmung	= +EEPCurve.getAttribute("Kruemmung") * 100;
				
				 // assumption: Gleis.Frame does not contain relevant data
				if (Math.abs(+FramePos.getAttribute("x")) > 1 ) {
					console.log(`EEPCurve ${GleissystemText[GleissystemID]} ${GleisID} has Frame value`);
				}

				const Frame2	= EEPCurve.getElementsByTagName("Frame")[0];
				const Frame2Pos	= Frame2.getElementsByTagName("Position")[0];
				const Frame2Dir	= Frame2.getElementsByTagName("Vector")[0];
				const Frame2Nor	= Frame2.getElementsByTagName("Vector")[1];
				const Frame2Bin	= Frame2.getElementsByTagName("Vector")[2];
				
				PosX		= +Frame2Pos.getAttribute("x") / 100;
				PosY		= -Frame2Pos.getAttribute("y") / 100;
				PosZ		= +Frame2Pos.getAttribute("z") / 100;
				
				DirX		= +Frame2Dir.getAttribute("dx");
				DirY		= -Frame2Dir.getAttribute("dy");
				DirZ		= +Frame2Dir.getAttribute("dz");
				
				NorX		= +Frame2Nor.getAttribute("dx");
				NorY		= -Frame2Nor.getAttribute("dy");
				NorZ		= +Frame2Nor.getAttribute("dz");
				
				BinX		= +Frame2Bin.getAttribute("dx");
				BinY		= -Frame2Bin.getAttribute("dy");
				BinZ		= +Frame2Bin.getAttribute("dz");

/*
Problematische Gleise:

Makinista_GRAFENBURG 16

<Gleis GleisID="4944" clsid="2E25C8E2-ADCD-469A-942E-7484556FF932" data="0" scale="1" ElectSideS="0" ElectSideE="0" stil="17" gsbname="\Gleisstile\Sonstiges\Wasserweg_unsichtbar.3dm" LockEd="0">
<Frame>
<Position x="4.882813E-04" y="6.103516E-03" z="0"/>
<Vector dx="1" dy="0" dz="0"/>
<Vector dx="0" dy="1" dz="0"/>
<Vector dx="0" dy="0" dz="1"/>
</Frame>
<Interval near="0" far="2.3"/>
<Curve>
<EEPCurve Kruemmung="0" Torsion="0" Fuehrungsverdrehung="-0" Laenge="230" Kurve="0" Anfangsfuehrungsverdrehung="0">
<Frame>
<Position x="-572287.6" y="-28208.7" z="4840"/>
<Vector dx="0" dy="0" dz="1"/>
<Vector dx="-0.7071068" dy="0.7071068" dz="0"/>
<Vector dx="-0.7071068" dy="-0.7071068" dz="0"/>
</Frame>
</EEPCurve>
</Curve>

-> Falsche Reihenfolge von EEPCurve Vector: Bin - Dir - Nor

*/
//if (GleissystemID == "4" && GleisID == "4944") debugger;
//if (GleissystemID == "4" && GleisID == "5817") debugger;
				if (DirX == 0 && DirY == 0 && DirZ == 1 && NorX != 0 && NorY != 0 && NorZ == 0) { // wrong order Bin - Dir - Nor
					const Frame2Bin	= Frame2.getElementsByTagName("Vector")[0];
					const Frame2Dir	= Frame2.getElementsByTagName("Vector")[1];
					const Frame2Nor	= Frame2.getElementsByTagName("Vector")[2];
					
					DirX		= +Frame2Dir.getAttribute("dx");
					DirY		= -Frame2Dir.getAttribute("dy");
					DirZ		= +Frame2Dir.getAttribute("dz");
					
					NorX		= +Frame2Nor.getAttribute("dx");
					NorY		= -Frame2Nor.getAttribute("dy");
					NorZ		= +Frame2Nor.getAttribute("dz");
					
					BinX		= +Frame2Bin.getAttribute("dx");
					BinY		= -Frame2Bin.getAttribute("dy");
					BinZ		= +Frame2Bin.getAttribute("dz");
				}

				//mMatrix = Rematrix.format([DirX, DirY, NorX, NorY, PosX, PosY]);
				mMatrix = [DirX, DirY, DirZ, 0,    NorX, NorY, NorZ, 0,    BinX, BinY, BinZ, 0,    PosX, PosY, PosZ, 1 ];
				
			} else if (Line) {
				CurveType 	= 'Line';
				Kruemmung	= 0;
				
				/* The line geometry is partly stored in <Gleis><Frame> as well as in 
				<Line><VectorBundle><Position> 		Position of parameter s=0 
				<Line><VectorBundle><Vector>   		.. and tangent of the line.
				<Line><Vector>						Up direction (always 0 0 1?)
				*/

				const Position	= Line.getElementsByTagName("VectorBundle")[0].getElementsByTagName("Position")[0];
				const Tangent	= Line.getElementsByTagName("VectorBundle")[0].getElementsByTagName("Vector")[0];
				const UpDirection = Line.getElementsByTagName("Vector")[1];	// Caution: getElementsByTagName searches in all decendant elements!
																			// Vector[0] is the vector within VectorBundle 
/* Try this from https://stackoverflow.com/questions/1241525/java-element-getelementsbytagname-restrict-to-top-level/18090152
function getChildrenByTagName(parent, name) {
var nodeList = [];
for (var child = parent.firstChild; child != null; child = child.nextSibling) {
if (child.nodeType == 1 && name == child.nodeName) {
	nodeList.push(child);
}
}
return nodeList;
}
*/						
				const PosX2		= +Position.getAttribute("x");		// dX
				const PosY2		= +Position.getAttribute("y");		// dY
				const PosZ2		= +Position.getAttribute("z");		// dZ

				const DirX2		= +Tangent.getAttribute("dx");		// cos(a)
				const DirY2		= +Tangent.getAttribute("dy");		// -sin(a)
				const DirZ2		= +Tangent.getAttribute("dz");		// ?
					
				const NorX2		= -DirY2;							// sin(a)
				const NorY2		= DirX2;  							// cos(a)
				const NorZ2		= +Tangent.getAttribute("dz");		// ?
					
				const BinX2		= +UpDirection.getAttribute("dx");
				const BinY2		= +UpDirection.getAttribute("dy");
				const BinZ2		= +UpDirection.getAttribute("dz");
				
// Special tracks				
//if (GleissystemID == "3" && GleisID == "349") debugger;	// <Interval near="99.99991" far="0"/>
//if (GleissystemID == "3" && GleisID == "354") debugger;	// <Interval near="40.00005" far="0"/>; ist: 1728 -1805 soll: 1730 -1812 diff: +2 -7
//if (GleissystemID == "3" && GleisID == "362") debugger;	// <Interval near="59.9999" far="0"/>

				mMatrix = [
							mMatrix,
							[DirX2, DirY2, DirZ2, 0, NorX2, NorY2, NorZ2, 0, BinX2, BinY2, BinZ2, 0, PosX2, PosY2, PosZ2, 1 ],  // 321 354 ok
						  ].reduce(Rematrix.multiply);
			

			} else if (Arc) {
				CurveType 	= 'Arc';

				// relative position of center point of the Arc
				const Pos 	= Arc.getElementsByTagName("VectorBundle2")[0].getElementsByTagName("Position")[0];
				const PosX2 = +Pos.getAttribute("x");
				const PosY2 = +Pos.getAttribute("y");
				const PosZ2 = +Pos.getAttribute("z");

				// Tangent (= normalized direction vector with dx^2 + dy^2 + dz^2 = 1) 
				const Dir 	= Arc.getElementsByTagName("VectorBundle2")[0].getElementsByTagName("Vector")[0];
				const DirX2 = +Dir.getAttribute("dx");
				const DirY2 = +Dir.getAttribute("dy");
				const DirZ2 = +Dir.getAttribute("dz");

				// The distance of the center point = curve radius is the length of the second vector
				const Nor 	= Arc.getElementsByTagName("VectorBundle2")[0].getElementsByTagName("Vector")[1];
				const MidX2 = +Nor.getAttribute("dx");
				const MidY2 = +Nor.getAttribute("dy");
				const MidZ2 = +Nor.getAttribute("dz");

				const angle = ( DirX2 === 1 && DirY2 === 0 ? 0 : Math.atan2(DirY2, DirX2)*180/Math.PI );	// skip 0° Rotation
				mMatrix = [
						mMatrix,
						Rematrix.translate3d(PosX2 - MidX2, PosY2 - MidY2, PosZ2 - MidZ2),	// Translate by distance of mid point of circle
						Rematrix.rotateZ( angle ), 											// Rotate by tangent of circle
					].reduce(Rematrix.multiply);

				const Radius = Math.sqrt(MidX2*MidX2 + MidY2*MidY2 + MidZ2*MidZ2)			// The curve radius is the length of the second vector
								 * (DirX2 >= 0 ? 1 : -1) * (MidY2 >= 0 ? 1 : -1);			// Adjustment according to quadrant (1, 3 counter clockwise; 2, 4 clock wise)
				Kruemmung = 1 / Radius;

// Special tracks				
//if (GleissystemID == "4" && GleisID == "52") debugger;				
//if (GleissystemID == "3" && GleisID == "351") debugger;	// <Interval near="26.99997" far="0"/>
//if (GleissystemID == "3" && GleisID == "358") debugger;	//
//if (GleissystemID == "3" && GleisID == "360") debugger;	// <Interval near="99.66833" far="0"/>
//if (GleissystemID == "4" && GleisID == "156") debugger;	// <Interval near="99.66833" far="0"/>

			} else if (Helix) {
				CurveType 	= 'Helix';

				// relative position of center point of the Helix
				const Pos 	= Helix.getElementsByTagName("VectorBundle2")[0].getElementsByTagName("Position")[0];
				const PosX2 = +Pos.getAttribute("x");
				const PosY2 = +Pos.getAttribute("y");
				const PosZ2 = +Pos.getAttribute("z");

				// Tangent (= normalized direction vector with dx^2 + dy^2 + dz^2 = 1) 
				const Dir 	= Helix.getElementsByTagName("VectorBundle2")[0].getElementsByTagName("Vector")[0];
				const DirX2 = +Dir.getAttribute("dx");
				const DirY2 = +Dir.getAttribute("dy");
				const DirZ2 = +Dir.getAttribute("dz");

				// Normal (= normalized direction vector with dx^2 + dy^2 + dz^2 = 1)
				const Nor 	= Helix.getElementsByTagName("VectorBundle2")[0].getElementsByTagName("Vector")[1];
				const NorX2 = +Nor.getAttribute("dx");
				const NorY2 = +Nor.getAttribute("dy");
				const NorZ2 = +Nor.getAttribute("dz");

				// Adjust position and direction
				const a = +Helix.getAttribute("a");			// Radius (= offset) in x direction
				const b = +Helix.getAttribute("b");			// Offset in z direction

/* Original
			
				mMatrix = [
							[DirX, DirY, DirZ, 0,    NorX, NorY, NorZ, 0,    BinX, BinY, BinZ, 0,    PosX + DirX * a, PosY + DirY * a, PosZ, 1 ],
							Rematrix.translate3d(PosX2, PosY2, PosZ2),
							Rematrix.rotateZ((NorY2 >= 0 ? 1 : -1) * 90),
						  ].reduce(Rematrix.multiply);

identisch zu Original
				mMatrix = [
							Rematrix.translate3d(DirX * a, DirY * a, DirZ * a),
							mMatrix,  
							Rematrix.translate3d(PosX2, PosY2, PosZ2),
							Rematrix.rotateZ((NorY2 >= 0 ? 1 : -1) * 90),
						  ].reduce(Rematrix.multiply);

*/

					  
// Special tracks			
//if (GleissystemID == "3" && GleisID == "350") 	debugger;	// <VectorBundle2><Position x="-3.80571" y="0" z="0"/>

// Error: wrong position of special Helix
if ( ((PosX2 != 0 || PosY2 != 0) && (DirX2 != 1 || DirY2 != 0))		// generic
||	(GleissystemID == "1" && GleisID == "5675"	)					// Makinista_GRAFENBURG 16
||	(GleissystemID == "1" && GleisID == "5902"	)
||	(GleissystemID == "1" && GleisID == "5935"	)
||	(GleissystemID == "1" && GleisID == "6096"	)
||	(GleissystemID == "2" && GleisID == "888"	)
||	(GleissystemID == "2" && GleisID == "970"	)
||	(GleissystemID == "3" && GleisID == "4065"	)
||	(GleissystemID == "3" && GleisID == "5011"	)
||	(GleissystemID == "3" && GleisID == "5027"	)
||	(GleissystemID == "3" && GleisID == "5649"	)
||	(GleissystemID == "3" && GleisID == "5650"	)
||	(GleissystemID == "4" && GleisID == "3170"	)
||	(GleissystemID == "4" && GleisID == "5627"	)
||	(GleissystemID == "4" && GleisID == "6049"	)
||	(GleissystemID == "4" && GleisID == "6051"	)
||	(GleissystemID == "4" && GleisID == "6056"	)
||	(GleissystemID == "4" && GleisID == "6057"	)
||	(GleissystemID == "4" && GleisID == "6059"	)
||	(GleissystemID == "4" && GleisID == "6060"	)
||	(GleissystemID == "4" && GleisID == "6072"	)
||	(GleissystemID == "1" && GleisID == "687"	)					// Gleismauerbau
){
	console.log('\t' + GleissystemText[GleissystemID] + '\t' + GleisID
		+ '\tHelix non-zero Pos2'
		+ '\tPos\t'  + PosX  + '\t' + PosY  + '\t' + PosZ
		+ '\ta\t' + a
		+ '\tb\t' + b
		+ '\tPos2\t' + PosX2 + '\t' + PosY2 + '\t' + PosZ2
		+ '\tDir2\t' + DirX2 + '\t' + DirY2 + '\t' + DirZ2
		+ '\tNor2\t' + NorX2 + '\t' + NorY2 + '\t' + NorZ2
	);
}

				// I do not know why this works in most cases ... but not in all cases ...
				//if (PosX2 == 0 && PosY2 == 0 && PosZ2 == 0) {
				if (PosY2 == 0) {
					// Start point need adjustment
					const DirAngle = ( DirX2 === 1 && DirY2 === 0 ? 0 : Math.atan2(DirY2, DirX2)*180/Math.PI );
					const NorAngle = ( NorX2 === 1 && NorY2 === 0 ? 0 : Math.atan2(NorY2, NorX2)*180/Math.PI );
					mMatrix = [
								Rematrix.translate3d(a * DirX, a * DirY, a * DirZ),
								mMatrix,  
								Rematrix.translate3d(PosX2, -PosY2, PosZ2),
								Rematrix.rotateZ(NorAngle),
							  ].reduce(Rematrix.multiply);
				} else {
					// Start point is already ok
				}

				const Radius = a 													// Radius
								* (DirX2 >= 0 ? 1 : -1) * (NorY2 >= 0 ? 1 : -1);	// Adjustment according to quadrant (1, 3 counter clockwise; 2, 4 clock wise)
				Kruemmung 	= 1 / Radius; 


			} else if (Clothoid) {
				CurveType 	= 'Clothoid';
				
/*
Curve parameter: 		
k = 1/r

k(s) = s/a^2
s = a^2*k(s)

r(s) = a^2/s 				für s != 0
s = a^2/r(s)
a^2 = s*r(s)

L = s2 - s1 
L = a^2/r2 - a^2/r1 
L = a^2(k2-k1) 
				
Curve characteristic:
a^2 = L/(k2-k1) 
a^2 = L*r1*r2/(r1-r2)

Clothoid.anl3
																a2 = a^2 	near	far		nor.y	bin.z
Id 1: From radius k1=0m 	to radius r2=100m	length 	l=60m 	a2=6000 	near=0 	far=60	1		1
Id 2: From radius k1=0m 	to radius r2=50m 	length 	l=60m 	a2=3000 	near=0 	far=60	1		1
Id 3: From radius r1=100m 	to radius r2=50m 	length 	l=60m 	a2=6000 	near=60 far=120	1		1
Id 4: From radius r1=50m 	to radius k2=0m		length 	l=60m 	a2=3000 	near=60 far=0	-1		-1		
Id 5: From radius r1=50m 	to radius k2=0m		length 	l=60m 	a2=3000 	near=0 	far=60	1		1

How to calculate [x(s), y(s)] ?
https://link.springer.com/article/10.1007/s12544-013-0119-8
*/	

				const a2 		= +Clothoid.getAttribute("a2");		// not used anymore, replaced by "a" 
				const a 		= (a2 ? Math.sqrt(a2) : +Clothoid.getAttribute("a") );
				
				//const l		= far - near;	// Laenge
				//const k1		= near / a**2;	// Krümmung am Startpunkt
				//const k2		= far / a**2;	// Krümmung am Endpunkt

				//const r1		= (k1 != 0 ? 1 / k1 : 0);	// Radius am Anfangspunkt
				//const r2		= (k2 != 0 ? 1 / k2 : 0);	// Radius am Endpunkt

				Gleis.Clothoid = {
					A: 				a,
					L1: 			near,
					L2: 			far,
					RotationCCW: 	-1,
				};

			} else if (Cubic) {
				CurveType 	= 'Cubic';
				// How to map the Bezier vector [a b c d] to the Bezier points B1 B2 B3 B4?
				// https://developer.mozilla.org/de/docs/Web/SVG/Tutorial/Pfade#Bezier-Kurven
				// http://blogs.sitepointstatic.com/examples/tech/svg-curves/cubic-curve.html
				// https://pomax.github.io/bezierinfo/
				// https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-837-computer-graphics-fall-2012/lecture-notes/MIT6_837F12_Lec01.pdf
				
/*				
Pattern A:
	<Frame>
		<Position 		x="0" 				y="0" 				z="0"/>
		<Vector 		dx="1" 				dy="0" 				dz="0"/>
		<Vector 		dx="0" 				dy="1" 				dz="0"/>
		<Vector 		dx="0" 				dy="0" 				dz="1"/>
	</Frame>
	<Interval near="0" far="7.290804"/>
	<Curve>
		<Cubic>
			<Position 	x="-308.2468" 		y="1647.528" 		z="234.1985"/>
			<Vector 	dx="-4.936119" 		dy="4.789839" 		dz="-0.4930255"/>
			<Vector 	dx="-0.2395048" 	dy="3.452314" 		dz="1.185636"/>
			<Vector 	dx="2.73141" 		dy="-1.794522" 		dz="-0.6260821"/>
		</Cubic>
	</Curve>
Strasse
Rotator	393	Anfang	-301	-1643	Ende	-308	-1645	
Cubic	20	
Arc		392	Anfang	-310	-1656	Ende	-311	-1654	

Cubic 390			

Pattern B:
	<Frame>
		<Position 		x="1546.876" 		y="-1850.316" 		z="12.383"/>
		<Vector 		dx="-0.9830491" 	dy="0.1833427" 		dz="1.704315E-05"/>
		<Vector 		dx="-0.1833427" 	dy="-0.9830491" 	dz="1.721977E-07"/>
		<Vector 		dx="1.678582E-05" 	dy="-2.955457E-06" 	dz="1"/>
	</Frame>
	<Interval near="0" far="84.4156"/>
	<Curve>
		<Cubic>
			<Position 	x="0" 				y="0" 				z="0"/>
			<Vector 	dx="84.86435" 		dy="0" 				dz="0"/>
			<Vector 	dx="1.134216" 		dy="-14.52291" 		dz="-3.315334E-05"/>
			<Vector 	dx="-2.8041" 		dy="1.988125" 		dz="-4.251127E-04"/>
		</Cubic>
	</Curve>

Strasse 
Arc 	346	x	1691.981	y	-1825.882	z	12.382	Length	65.57804 	
Cubic	347	x	1630.569	y	-1848.626	z	12.382	Length	84.41406
Cubic	348	x	1546.876	y	-1850.316	z	12.383	Length	84.41560	
Arc 	215	x	1467.390	y	-1822.741	z	12.384

*/
				
				// If Frame.Position = 0 and Cubic.Position <> 0 then treat Cubic.Position as the starting point of the curve
				const PositionA	= Cubic.getElementsByTagName("Position")[0];
				const pX		= +PositionA.getAttribute("x");
				const pY		= +PositionA.getAttribute("y");
				const pZ		= +PositionA.getAttribute("z");
				if (pX != 0 || pY != 0 || pZ != 0) {
					mMatrix = [
							mMatrix,
							Rematrix.translate3d(pX, pY, pZ),
						].reduce(Rematrix.multiply);
				}

				// The Cubic element stores the canonical monomial basis values of the bezier curve
				// The values of Cubic.Vector are relative to the starting point.
				// Therefore we define a=0 and use the Cubic.Vector for b, c, d.  
				const VectorB	= Cubic.getElementsByTagName("Vector")[0];
				const VectorC	= Cubic.getElementsByTagName("Vector")[1];
				const VectorD	= Cubic.getElementsByTagName("Vector")[2];
				
				const aX		= 0; 
				const aY		= 0; 
				const aZ		= 0; 
				const bX		= +VectorB.getAttribute("dx");
				const bY		= +VectorB.getAttribute("dy");
				const bZ		= +VectorB.getAttribute("dz");
				const cX		= +VectorC.getAttribute("dx");
				const cY		= +VectorC.getAttribute("dy");
				const cZ		= +VectorC.getAttribute("dz");
				const dX		= +VectorD.getAttribute("dx");
				const dY		= +VectorD.getAttribute("dy");
				const dZ		= +VectorD.getAttribute("dz");

				/* Bezier points
				Multipy the Bezier vector [a b c d] with the matrix
				1  1   1  1
				0 1/3 2/3 1
				0  0  1/3 1
				0  0   0  1
				to get the coordinates of the Bezier points B1 B2 B3 B4.
				*/
				const B1X 		= aX;
				const B1Y 		= aY;
				const B1Z 		= aZ;
				const B2X 		= aX + bX/3;
				const B2Y 		= aX + bY/3;
				const B2Z 		= aX + bZ/3;
				const B3X 		= aX + bX*2/3 + cX/3;
				const B3Y 		= aX + bY*2/3 + cY/3;
				const B3Z 		= aX + bZ*2/3 + cZ/3;
				const B4X 		= aX + bX     + cX   + dX;
				const B4Y 		= aX + bY     + cY   + dY;
				const B4Z 		= aX + bZ     + cZ   + dZ;
				
				Gleis.BezierPoints = [ [B1X, B1Y, B1Z], [B2X, B2Y, B2Z], [B3X, B3Y, B3Z], [B4X, B4Y, B4Z]];

/*						
console.log(`Cubic ${GleissystemText[GleissystemID]} ${GleisID}`
+ ' Pos ' + FramePos.getAttribute("x")  + ' ' + FramePos.getAttribute("y")  + ' ' + FramePos.getAttribute("z")  
+ ' Dir ' + FrameDir.getAttribute("dx") + ' ' + FrameDir.getAttribute("dy") + ' ' + FrameDir.getAttribute("dz")  
+ ' Nor ' + FrameNor.getAttribute("dx") + ' ' + FrameNor.getAttribute("dy") + ' ' + FrameNor.getAttribute("dz")  
+ ' Bin ' + FrameBin.getAttribute("dx") + ' ' + FrameBin.getAttribute("dy") + ' ' + FrameBin.getAttribute("dz")  
+ ' pA  ' + PositionA.getAttribute("x")	+ ' ' + PositionA.getAttribute("y")	+ ' ' + PositionA.getAttribute("z")
+ ' vB  ' + VectorB.getAttribute("dx") 	+ ' ' + VectorB.getAttribute("dy") 	+ ' ' + VectorB.getAttribute("dz")
+ ' vC  ' + VectorC.getAttribute("dx") 	+ ' ' + VectorC.getAttribute("dy") 	+ ' ' + VectorC.getAttribute("dz")
+ ' vD  ' + VectorD.getAttribute("dx") 	+ ' ' + VectorD.getAttribute("dy") 	+ ' ' + VectorD.getAttribute("dz")  
)
*/

			} else if (Rotator) {
				CurveType 	= 'Rotator';
				// A Rotator looks like an Arc if we can ignore the z-axis 
				Kruemmung = +Rotator.getAttribute("a");
				const KruemmungZ = +Rotator.getAttribute("b");
				if (KruemmungZ * Laenge > 1) {
					console.log(`Rotator ${GleissystemText[GleissystemID]} ${GleisID} has large KruemmungZ`);
				}
				
			} else if (RotatorChain) {
				CurveType 	= 'RotatorChain';
				console.log(`RotatorChain not supported yet: ${GleissystemText[GleissystemID]} ${GleisID}`);
				continue;

			} else { // curve not supported yet
				CurveType 	= 'others';
				console.log(`other curve type not supported yet:  ${GleissystemText[GleissystemID]} ${GleisID}`);
				continue;
			}

		} else {  /* EEP 15 */
			CurveType 		= 'classic';
			const Charakteristik = Gleis.getElementsByTagName("Charakteristik")[0];
			const Dreibein	= Gleis.getElementsByTagName("Dreibein")[0];
			const FramePos	= Dreibein.getElementsByTagName("Vektor")[0];
			const FrameDir	= Dreibein.getElementsByTagName("Vektor")[1];
			const FrameNor	= Dreibein.getElementsByTagName("Vektor")[2];
			const FrameBin	= Dreibein.getElementsByTagName("Vektor")[3];
			
			Laenge 		= +Charakteristik.getAttribute("Laenge") / 100;
			Kruemmung	= +Charakteristik.getAttribute("Kruemmung") * 100;
			
			PosX		= +FramePos.getAttribute("x") / 100;
			PosY		= -FramePos.getAttribute("y") / 100;
			PosZ		= +FramePos.getAttribute("z") / 100;
			
			DirX		= +FrameDir.getAttribute("x");
			DirY		= -FrameDir.getAttribute("y");
			DirZ		= +FrameDir.getAttribute("z");
			
			NorX		= +FrameNor.getAttribute("x");
			NorY		= -FrameNor.getAttribute("y");
			NorZ		= +FrameNor.getAttribute("z");
			
			BinX		= +FrameBin.getAttribute("x");
			BinY		= -FrameBin.getAttribute("y");
			BinZ		= +FrameBin.getAttribute("z");

			//mMatrix = Rematrix.format([DirX, DirY, NorX, NorY, PosX, PosY]);
			mMatrix = [DirX, DirY, DirZ, 0,    NorX, NorY, NorZ, 0,    BinX, BinY, BinZ, 0,    PosX, PosY, PosZ, 1 ];
		} /* EEP 15 */

/*
const Interval = Gleis.getElementsByTagName("Interval")[0];			
if (0 != +Interval.getAttribute("near")) {
console.log(`near != 0 ${GleissystemText[GleissystemID]} ${GleisID} ${CurveType}`
+ ' ' + Interval.getAttribute("near") 
+ ' ' + Interval.getAttribute("far") 
);
}					
*/
		/* 
		2D transformation matrix		3D transformation matrix	
		matrix(	a, b, c, d,  x, y) = 	matrix3d( a, b, 0, 0,  c, d, 0, 0,  0, 0, 1, 0,  x, y, 0, 1 ).
		
		Rematrix.format
		[ a, b, 0, 0,
		  c, d, 0, 0,
		  0, 0, 1, 0,
		  x, y, 0, 1  ]
		  
		Rematrix.identity
		[ 1, 0, 0, 0,
		  0, 1, 0, 0,
		  0, 0, 1, 0,
		  0, 0, 0, 1 ]
		 
		Rematrix.rotateZ
		[ cos a, 	sin a,	0, 0,
		  -sin a, 	cos a, 	0, 0,
		  0, 		0, 		1, 0,
		  0, 		0, 		0, 1]
		
		Rematrix.translate3d
		[ 1,  0,  0,  0,
		  0,  1,  0,  0,
		  0,  0,  1,  0,
		  dx, dy, dz, 1 ]

		*/

		Gleis.CurveType = CurveType;
		Gleis.Laenge 	= Laenge;
		Gleis.mPos 		= mMatrix;

		let Winkel, DeltaX, DeltaY, DeltaZ, svgRotate;
		const posX = 12, posY = 13, posZ = 14; // Index in mMatrix

		// Log defect data
		if (isNaN( mMatrix[posX] )) {
			console.log("NaN Error: "
				+ ' Gleis ' + GleissystemID + '-' + GleisID
			);
		}

		// Group node for Gleis
		const svgGleisGroup = svgAppend(svgGleissystemGroup, {
			svg_tag	: `g`,
			id		: `G${GleissystemID}-${GleisID}`,
			'class'	: Gleisart[clsid]
						+ " " + CurveType
						+ " " + (global.activeTracks[GleissystemID].includes(GleisID) ? "active" : "inactive")
						+ " " + `height=${Gleis.mPos[posZ].toFixed(2)}`	// Height
						// Ein Kamerafahrweg ist immer unsichtbar
						+ (stil == 100000 || (unsichtbar.includes(parseInt(stil)) && GleisData != 16) ? " " + "unsichtbar" : ""),
		});

		// Calculate end point and create svg curve
		if (CurveType == 'Cubic') {
			const t = 1;
			[DeltaX, DeltaY, DeltaZ, Winkel] = calcBezierCurve(Gleis.BezierPoints, t);

			// Gleis.BezierPoints = [ [B1X, B1Y, B1Z], [B2X, B2Y, B2Z], [B3X, B3Y, B3Z], [B4X, B4Y, B4Z]];
			const B1X = Gleis.BezierPoints[0][0];
			const B1Y = Gleis.BezierPoints[0][1];
			const B1Z = Gleis.BezierPoints[0][2];
			const B2X = Gleis.BezierPoints[1][0];
			const B2Y = Gleis.BezierPoints[1][1]; 
			const B2Z = Gleis.BezierPoints[1][2];
			const B3X = Gleis.BezierPoints[2][0];
			const B3Y = Gleis.BezierPoints[2][1];
			const B3Z = Gleis.BezierPoints[2][2];
			const B4X = Gleis.BezierPoints[3][0];
			const B4Y = Gleis.BezierPoints[3][1];
			const B4Z = Gleis.BezierPoints[3][2];

			// The svg command "M x0 y0 C x1 y1 x2 y2 x3 y3" uses the coordinates of the bezier points of the cubic curve.  
			svgAppend(svgGleisGroup, {
				svg_tag				: `path`,
				class				: `stil-${stil}`,
				d 					: `M ${B1X} ${B1Y} C ${B2X} ${B2Y} ${B3X} ${B3Y} ${B4X} ${B4Y}`,
				transform 			: matrixToTransform(mMatrix)
			});

		} else if (CurveType == 'Clothoid') {
			let svgPath;
			[points, svgPath] = calcClothoidCurve(
				Gleis.Clothoid.A, 
				Gleis.Clothoid.L1, 
				Gleis.Clothoid.L2, 
				Gleis.Clothoid.RotationCCW
			);
			DeltaX		= points.End.x;
			DeltaY 		= points.End.y;
			DeltaZ		= points.End.z;
			Winkel		= points.End.Winkel;
			
			svgAppend(svgGleisGroup, {
				svg_tag				: `path`,
				class				: `stil-${stil}`,
				d 					: svgPath,
				transform 			: matrixToTransform(mMatrix)
			});
			
			// Adjust Gleis.mPos
			Gleis.mPos = [
					mMatrix,
					Rematrix.translate3d(points.Pos.x, points.Pos.y, points.Pos.z),
				].reduce(Rematrix.multiply);				
				
		} else if (Kruemmung > -0.0001 && Kruemmung < 0.0001) { // Show line. The svg-arc is not shown if the radius is too big
			/* SVG: Gerades Gleis
			Alternativen (line erlaubt allerdings kein text-path, daher wird path verwendet)
			a) <line x1="0" y1="0" x2="Laenge" y2="0" transform="translate(PosX PosY) matrix(DirX DirY NorX NorY 0 0)"/>
			b) <line x1="0" y1="0" x2="Laenge" y2="0" transform="matrix(DirX DirY NorX NorY PosX PosY)"/>
			b) <path d="M 0 0 H Laenge" transform="matrix(DirX DirY NorX NorY PosX PosY)"/>
			*/
			DeltaX		= Laenge;
			DeltaY 		= 0;
			DeltaZ		= 0;				
			Winkel		= 0;	

			svgAppend(svgGleisGroup, {
				svg_tag				: `path`,
				class				: `stil-${stil}`,
				d 					: `M 0 0 H ${Laenge}`,
				transform 			: matrixToTransform(mMatrix)
			});

		} else { // Show arc. Kruemmung != 0

			/* SVG: Gebogenes Gleis

			Winkel (rad) = Kruemmung * Laenge
			ArcFlag = 0 für Winkel im Bereich -180° bis +180°, ansonsten 1
			SweepFlag = 1 für Winkel >= 0, 0 für Winkel < 0
			Radius = 1 / Kruemmung
			DeltaX = sin(Winkel) * Radius
			DeltaY = (1-cos(Winkel)) * Radius

			Kreisbogen als Spezialfall eines Ausschnittes einer allgenmeinen Ellipse:
			<path d="M PosX PosY A RadiusX RadiusY RotateX ArcFlag SweepFlag PosEndX PosEndY" />
			PosX = 0			x-Koordinate des Anfangpunktes
			PosY = 0			Y-Koordinate des Anfangpunktes
			RadiusX = Radius	Radius der x-Achse der Ellipse
			RadiusY	= Radius	Radius der y-Achse der Ellipse
			RotateX = 0 		Rotation der x-Achse der Ellipse in Grad (0: keine Rotation)
			ArcFlag = 0			large-arc-flag: kurzer Weg um die Ellipse: 0, langer Weg um die Ellipse: 1
			SweepFlag = ...		Zeichnung entgegen den Uhrzeigersinn: 0, Zeichnung mit dem Uhrzeigersinn: 1
			PosEndX = DeltaX	x-Koordinate des Endpunktes
			PosEndY = DeltaY	Y-Koordinate des Endpunktes

			Dies ergibt folgende vereinfachte Form:
			<path d="M 0 0 A Radius Radius 0 ArcFlag SweepFlag DeltaX DeltaY />
			*/
			Winkel 	= Kruemmung * Laenge;
			const Radius	= 1 / Kruemmung;
			
			DeltaX		= Math.sin(Winkel) * Radius;
			DeltaY 		= (1 - Math.cos(Winkel)) * Radius;
			DeltaZ		= 0;

			const ArcFlag 	= ( Winkel <= Math.PI && Winkel >= -Math.PI ? 0 : 1);
			const SweepFlag = ( Winkel >= 0 ? 1 : 0);

			svgAppend(svgGleisGroup, {
				svg_tag				: `path`,
				class				: `stil-${stil}`,
				d 					: `M 0 0 A ${Radius} ${Radius} 0 ${ArcFlag} ${SweepFlag} ${DeltaX} ${DeltaY}`,
				transform 			: matrixToTransform(mMatrix)
			});

		}

		Gleis.mEnd = [
				mMatrix,
				Rematrix.translate3d(DeltaX, DeltaY, DeltaZ),
			].reduce(Rematrix.multiply);
		svgRotate	= (Winkel != 0 ? ` rotate(${Winkel*180/Math.PI} ${DeltaX} ${DeltaY})` : '');

		if (Key_Id) {
			// Show text of Weiche at the end of the track
			let Code = "W";
			if (GleisData == 18 || GleisData == 19) { Code = "DWK" };
			if (GleisData == 20 || GleisData == 21) { Code = "T-W" };
			svgAppend(svgGleisGroup, {
				svg_tag			: `text`,
				id				: `W${Key_Id}`,
				text			: `${Code}${Key_Id}`,
				dy				: `1em`, 		// Shift text below the track
				"class"			: `WeicheText`,
				x				: DeltaX,
				y				: -DeltaY,
				transform 		: matrixToTransform(mMatrix)
								  + svgRotate
								  + ` scale(1 -1)`,
			});
		}
			
		// Calculate mid point
		if (CurveType == "Cubic") {
			const t = 0.5;
			[DeltaX, DeltaY, DeltaZ, Winkel] = calcBezierCurve(Gleis.BezierPoints, t);
			svgRotate	= ` rotate(${Winkel*180/Math.PI} ${DeltaX} ${DeltaY})`;

		} else if (CurveType == 'Clothoid') {
			let svgPath;
			[points, svgPath] = calcClothoidCurve(
				Gleis.Clothoid.A, 
				0, 
				Gleis.Clothoid.L1 + (Gleis.Clothoid.L2 - Gleis.Clothoid.L1)/2, 
				Gleis.Clothoid.RotationCCW
			);
			DeltaX			= points.End.x;
			DeltaY 			= points.End.y;
			DeltaZ			= points.End.z;
			Winkel			= points.End.Winkel;

		} else if (Kruemmung > -0.0001 && Kruemmung < 0.0001) { // The svg-arc is not shown if the radius is too big
			DeltaX			= Laenge / 2;
			DeltaY			= 0;
			DeltaZ			= 0;
			Winkel			= 0;
			
		} else {  // Kruemmung != 0
			Winkel 	= Kruemmung * Laenge / 2;
			// const ArcFlag 	= ( Winkel <= Math.PI && Winkel >= -Math.PI ? 0 : 1);
			// const SweepFlag = ( Winkel >= 0 ? 1 : 0);
			const Radius	= 1 / Kruemmung;

			DeltaX 			= Math.sin(Winkel) * Radius;
			DeltaY 			= (1 - Math.cos(Winkel)) * Radius;
			DeltaZ			= 0;
		}

		Gleis.mMid = [
				mMatrix,
				Rematrix.translate3d(DeltaX, DeltaY, DeltaZ),
			].reduce(Rematrix.multiply);
		svgRotate	= (Winkel != 0 ? ` rotate(${Winkel*180/Math.PI} ${DeltaX} ${DeltaY})` : '');
		
		// show GleisID in the middle above the track (left-adjusted)
		svgAppend(svgGleisGroup, {
			svg_tag				: `text`,
			text				: `${GleisID}`,
			dx					: `-0.5em`, 	// Shift text left to move it a little bit towards the center
			dy					: `-0.1em`, 	// Shift text up
			"class"				: `GleisID`,
			x					: DeltaX,
			y					: -DeltaY,
			transform 			: matrixToTransform(mMatrix)
			//transform 			: matrixToTransform(Gleis.mMid) // Bug: does not work for Rotator yet
								  + svgRotate
								  + ` scale(1 -1)`,
		});
		// show CurveType in the middle above the track (right-adjusted)
		if (CurveType != 'classic' && CurveType != 'EEPCurve') {
		svgAppend(svgGleisGroup, {
			svg_tag				: `text`,
			text				: `${CurveType}`,
			dx					: `-0.7em`, 	// Shift text left to geta away from GleisID
			dy					: `-0.1em`, 	// Shift text up
			"class"				: `CurveType`,
			x					: DeltaX,
			y					: -DeltaY,
			transform 			: matrixToTransform(mMatrix)
			//transform 			: matrixToTransform(Gleis.mMid) // Bug: does not work for Rotator yet
								  + svgRotate
								  + ` scale(1 -1)`,
		});
		}
		// show Gleisstil in the middle below the track (right-adjusted)
		svgAppend(svgGleisGroup, {
			svg_tag				: `text`,
			text				: `${stil}`,
			dx					: `-0.1em`, 	// Shift text left a little bit  
			dy					: `1em`, 		// Shift text below the track
			"class"				: `Stil`,
			x					: DeltaX,
			y					: -DeltaY,
			transform 			: matrixToTransform(mMatrix)
								  + svgRotate
								  + ` scale(1 -1)`,
		});					
		// show Hoehe in the middle below the track (left-adjusted)
		svgAppend(svgGleisGroup, {
			svg_tag				: `text`,
			text				: `[${mMatrix[posZ].toFixed(2)}m]`,
			dx					: `+0.1em`, 	// Shift text right a little bit
			dy					: `1em`, 		// Shift text below the track
			"class"				: `Hoehe`,
			x					: DeltaX,
			y					: -DeltaY,
			transform 			: matrixToTransform(mMatrix)
								  + svgRotate
								  + ` scale(1 -1)`,
		});					

		if (global.__showCircles__) {	// degugging feature
			// Show circle at Point
			svgAppend(svgGleisGroup, {
				svg_tag				: `circle`,
				r					: 1.5,
				transform 			: matrixToTransform(Gleis.mPos),
			});
			svgAppend(svgGleisGroup, {
				svg_tag				: `circle`,
				r					: 0.5,
				transform 			: matrixToTransform(Gleis.mMid),
			});
			svgAppend(svgGleisGroup, {
				svg_tag				: `circle`,
				r					: 1,
				transform 			: matrixToTransform(Gleis.mEnd),
			});
		}

		// Verwendeten Bereich der Anlage anpassen
		const border = 20;
		global.usedArea.min.x = Math.min( global.usedArea.min.x, Gleis.mPos[posX]-border, Gleis.mMid[posX]-border, Gleis.mEnd[posX]-border );
		global.usedArea.min.y = Math.min( global.usedArea.min.y, Gleis.mPos[posY]-border, Gleis.mMid[posY]-border, Gleis.mEnd[posY]-border );
		global.usedArea.min.z = Math.min( global.usedArea.min.z, Gleis.mPos[posZ],        Gleis.mMid[posZ],        Gleis.mEnd[posZ] );

		global.usedArea.max.x = Math.max( global.usedArea.max.x, Gleis.mPos[posX]+border, Gleis.mMid[posX]+border, Gleis.mEnd[posX]+border );
		global.usedArea.max.y = Math.max( global.usedArea.max.y, Gleis.mPos[posY]+border, Gleis.mMid[posY]+border, Gleis.mEnd[posY]+border );
		global.usedArea.max.z = Math.max( global.usedArea.max.z, Gleis.mPos[posZ],        Gleis.mMid[posZ],        Gleis.mEnd[posZ] );

		// Signale
		// <Meldung Position="3449.492" ParaOderAnti="1" fireOnPara="1" fireOnAnti="0" name="PI5_HP02_Form_oVSig" Key_Id="5" >
		//     <KontaktZiel>6</KontaktZiel>
		//     <Signal stellung="1" wirkungsdistanz="10856.51"/>
		// </Meldung>
		
		// Fahrstraßen: name = "system\Route_SignalS.3ds" bzw. "system\Route_SignalZ.3ds"
		// <Meldung Position="5190" ParaOderAnti="1" fireOnPara="1" fireOnAnti="0" name="system\Route_SignalS.3ds" Key_Id="141" Routes="7">
		// 		<KontaktZiel>0</KontaktZiel>
		// 		<Signal stellung="1" wirkungsdistanz="0" StopAt="0" Delay="0" ActDelay="0"/>
		// 		<Route Target="142" Start="5190" Stop="1890" Color="13">
		//		...
		// </Meldung>

		const trackSignalEntries = global.trackSignals[GleissystemID][GleisID];
		if (trackSignalEntries) { 
		for (const trackSignalEntry of trackSignalEntries) {
			const Meldung		= trackSignalEntry.Meldung;
			const SignalID		= Meldung.getAttribute("Key_Id");
			const signalType	= trackSignalEntry.signalType;
			const Position		= trackSignalEntry.Position;
			const Distanz		= Meldung.getElementsByTagName("Signal")[0].getAttribute("wirkungsdistanz") / 100;
			const ParaOderAnti 	= trackSignalEntry.ParaOderAnti; //Gleisrichtung: 0 = Ende -> Anfang, 1 = Anfang -> Ende
			
			// Calculate point
			if (CurveType == "Cubic") {
				const t = (Laenge ? Position / Laenge : 0);
				[DeltaX, DeltaY, DeltaZ, Winkel] = calcBezierCurve(Gleis.BezierPoints, t);

			} else if (CurveType == 'Clothoid') {
				let svgPath;
				[points, svgPath] = calcClothoidCurve(
					Gleis.Clothoid.A, 
					0, 
					Gleis.Clothoid.L1 + Position * (Gleis.Clothoid.L1 < Gleis.Clothoid.L2 ? +1 : -1), 
					Gleis.Clothoid.RotationCCW
				);
				DeltaX			= points.End.x;
				DeltaY 			= points.End.y;
				DeltaZ			= points.End.z;
				Winkel			= points.End.Winkel;

			} else if (Kruemmung > -0.0001 && Kruemmung < 0.0001) { // The svg-arc is not shown if the radius is too big
				DeltaX			= Position;
				DeltaY			= 0;
				DeltaZ			= 0;
				Winkel 			= 0;
				
			} else { // Kruemmung != 0
				Winkel 			= Kruemmung * Position;
				const Radius 	= 1 / Kruemmung;

				DeltaX 			= Math.sin(Winkel) * Radius;
				DeltaY 			= (1 - Math.cos(Winkel)) * Radius;
				DeltaZ			= 0;
			}

			Meldung.mPos = [
					mMatrix,
					Rematrix.translate3d(DeltaX, DeltaY, DeltaZ),
					Rematrix.rotateZ( 
						  Winkel*180/Math.PI	// Rotate to tangent of track
						+ ParaOderAnti*180 		// Rotate text to the side of the symbol 
					),												
				].reduce(Rematrix.multiply);

			// Group node for Signal
			const svgSignalGroup = svgAppend(svgGleisGroup, {
				svg_tag	: `g`,
				id		: `S${SignalID}`,
				class	: `Signal`,
			});

			if (global.__showCircles__) {	// degugging feature
				// Show circle at Point
				svgAppend(svgSignalGroup, {
					svg_tag				: `circle`,
					r					: 2,
					transform 			: matrixToTransform(Meldung.mPos),
				});
			}
	
			// Show symbol for Signal / Fahrstraße
			svgAppend(svgSignalGroup, {
				svg_tag				: `use`,
				href				: (	  signalType === "FStart" 	? "#SymbolFStart" 
										: signalType === "FZiel" 	? "#SymbolFZiel"
										: signalType === "pre" 		? "#SymbolPreSignal" 
										: 							  "#SymbolSignal"
									  ),
				transform 			: matrixToTransform(Meldung.mPos)
										+ ` translate(-10 0)` // required to move the origin of the symbol to the Signal position
										,
			});

			// Show text of Signal / Fahrstraße
			svgAppend(svgSignalGroup, {
				svg_tag				: `text`,
				text				: (	  signalType === "FStart"	? "Fs" 
										: signalType === "FZiel"	? "Fz"
										: signalType === "pre" 		? "S" 
										: 						  	  "S"  
									  )
										+ SignalID 
										+ (signalType === "pre" ? ` ${Distanz.toFixed(0)}m` : ``),
				"dy"				: `-2.3`, 									// Shift text above the symbol
				transform 			: matrixToTransform(Meldung.mPos)
										+ ` scale(1 -1)`,
			});


		}} // Signale

		// Kontakte
		for (const Kontakt of Gleis.getElementsByTagName("Kontakt")) {
			const Position		= Kontakt.getAttribute("Position") / 100;
			const ParaOderAnti 	= Kontakt.getAttribute("ParaOderAnti"); // Gleisrichtung 1: 0 = Ende -> Anfang, 1 = Anfang -> Ende
			const fireOnPara  	= Kontakt.getAttribute("fireOnPara"); 	// Kontakt aktiv für Gleisrichtung 1
			const fireOnAnti  	= Kontakt.getAttribute("fireOnAnti"); 	// Kontakt aktiv für Gleisrichtung 2
			const SetType 		= Number(Kontakt.getAttribute('SetType'));
			const SetValue 		= Number(Kontakt.getAttribute('SetValue'));
			const KontaktZiel 	= Number(Kontakt.getAttribute('KontaktZiel'));
			
			if (!global.Kontakte.Anzahl) {
				global.Kontakte.Anzahl = 0;				// initialization
			}
			const KontaktID = global.Kontakte.Anzahl; 	// arbitrary identfication
			global.Kontakte[KontaktID] = Kontakt;
			global.Kontakte.Anzahl += 1;
			
			// Calculate point
			if (CurveType == "Cubic") {
				const t = (Laenge ? Position / Laenge : 0);
				[DeltaX, DeltaY, DeltaZ, Winkel] = calcBezierCurve(Gleis.BezierPoints, t);

			} else if (CurveType == 'Clothoid') {
				let svgPath;
				[points, svgPath] = calcClothoidCurve(
					Gleis.Clothoid.A, 
					0, 
					Gleis.Clothoid.L1 + Position * (Gleis.Clothoid.L1 < Gleis.Clothoid.L2 ? +1 : -1), 
					Gleis.Clothoid.RotationCCW
				);
				DeltaX			= points.End.x;
				DeltaY 			= points.End.y;
				DeltaZ			= points.End.z;
				Winkel			= points.End.Winkel;

			} else if (Kruemmung > -0.0001 && Kruemmung < 0.0001) { // The svg-arc is not shown if the radius is too big
				Winkel 			= 0;
				DeltaX			= Position;
				DeltaY			= 0;
				DeltaZ			= 0;

			} else { // Kruemmung != 0
				Winkel 			= Kruemmung * Position;
				const Radius 	= 1 / Kruemmung;

				DeltaX 			= Math.sin(Winkel) * Radius;
				DeltaY 			= (1 - Math.cos(Winkel)) * Radius;
				DeltaZ			= 0;
			}

			Kontakt.mPos = [
					mMatrix,
					Rematrix.translate3d(DeltaX, DeltaY, DeltaZ),
					Rematrix.rotateZ( 
						  Winkel*180/Math.PI	// Rotate to tangent of track
						//+ ParaOderAnti*180 		// Rotate text to the side of the symbol 
					),												
				].reduce(Rematrix.multiply);

			// Group node for Kontakt
			const svgKontaktGroup = svgAppend(svgGleisGroup, {
				svg_tag	: `g`,
				id		: `K${KontaktID}`,
				class	: `Kontakt`,
			});

			if (global.__showCircles__) {
				// Show circle at Point
				svgAppend(svgKontaktGroup, {
					svg_tag				: `circle`,
					r					: 2,
					transform 			: matrixToTransform(Kontakt.mPos),
				});
			}
			
			// Show symbol for Kontakt
			if (fireOnPara == 1) {
				svgAppend(svgKontaktGroup, {
					svg_tag				: `use`,
					"href"				: `#SymbolKontakt`,
					transform 			: matrixToTransform(Kontakt.mPos)
											+ (ParaOderAnti ? ` rotate(${ParaOderAnti*180})` : '')
											+ ` translate(-10 0)` // required to move the origin of the symbol to the Kontakt position
											,
				});
			}
			if (fireOnAnti == 1) {
				svgAppend(svgKontaktGroup, {
					svg_tag				: `use`,
					"href"				: `#SymbolKontakt`,
					transform 			: matrixToTransform(Kontakt.mPos)
											+ (1-ParaOderAnti ? ` rotate(${(1-ParaOderAnti)*180})` : '')
											+ ` translate(-10 0)` // required to move the origin of the symbol to the Kontakt position
											,
				});
			}

			// Show text of Kontakt
			let KontaktTypText = getKontaktIcon(GleissystemID, SetType, SetValue);
			if (KontaktZiel > 0 ) {
				const Ziel = global.KontaktZiele[KontaktZiel];
				KontaktTypText += (Ziel ? `${Ziel.Typ.substr(0, 1)}${Ziel.ID}` : `?${KontaktZiel}`);
			}
			if (KontaktTypText != '') {
				svgAppend(svgKontaktGroup, {
					svg_tag				: `text`,
					text				:  KontaktTypText,
					"dy"				: `-2.3`, 													// Shift text above the symbol
					transform 			: matrixToTransform(Kontakt.mPos)
											+ ` rotate(${ParaOderAnti*180 + (1-fireOnPara)*180})`	// Rotate text to the side of the symbol
											+ ` scale(1 -1)`,
				});
			}

		} // Kontakte

	} // Gleise
}

function createSVGfinalize(SVGfragment) {

	const SVGfragmentBackground 	= document.createDocumentFragment();

	createSVGforGleisobjekte(SVGfragmentBackground);
	createSVGforRahmen(SVGfragmentBackground);

	createSVGforKameras(SVGfragment);

	// Now we can append the fragments to the svg node
	// Order: 1. Gleisobjekte (Flächen), 2. Rahmen, 3. Gleise (Linien), 4. Kameras
	document.getElementById("sutrackp").appendChild(SVGfragmentBackground);
	document.getElementById("sutrackp").appendChild(SVGfragment);

	// Test: process all nodes recursivly
	//process_node(sutrackp);

	global.timestamp.svgCreated = Date.now();
	console.log('create svg:' + (global.timestamp.svgCreated - global.timestamp.fileParsed) / 1000 + 'sec');
}

function createSVGforGleisobjekte(SVGfragment) {
/*
	in:
		global.Gleisobjekte
		global.Gleissysteme
		GleissystemCode
	
	mod:
		document.getElementById("CheckboxGleisobjekt")
		SVGfragment
	
*/
	
	// Process Gleisobjekte
	// to be discussed: should Gleisobjekt get aktiv/inaktiv status? (current: no - this could be a feature)

	let svgGleisobjekteGroup;
	for (const GleisobjektID in global.Gleisobjekte) {
		const Gleisobjekt = global.Gleisobjekte[GleisobjektID];
		const GleissystemID = Gleisobjekt.GleissystemID;				// GleissystemID of Gleisobjekt
		
		let minX, minY, maxX, maxY;
		const points = [];
		for (const i in Gleisobjekt.Gleise) {
			const GleissystemID = Gleisobjekt.Gleise[i].GleissystemID;	// GleissystemID of Gleis
			const GleisID 		= Gleisobjekt.Gleise[i].GleisID;

			const Gleis = global.Gleissysteme[GleissystemID][GleisID];
			if (Gleis) {
		
				// simplified: calculate outer rectangle
				const posX = 12, posY = 13;

				if (minX === undefined || 
					minX > Gleis.mPos[posX]) { minX = Gleis.mPos[posX] };
				if (maxX === undefined || 
					maxX < Gleis.mPos[posX]) { maxX = Gleis.mPos[posX] };
				if (minY === undefined || 
					minY > Gleis.mPos[posY]) { minY = Gleis.mPos[posY] };
				if (maxY === undefined ||
					maxY < Gleis.mPos[posY]) { maxY = Gleis.mPos[posY] };

				if (minX > Gleis.mMid[posX]) { minX = Gleis.mMid[posX] };
				if (maxX < Gleis.mMid[posX]) { maxX = Gleis.mMid[posX] };
				if (minY > Gleis.mMid[posY]) { minY = Gleis.mMid[posY] };
				if (maxY < Gleis.mMid[posY]) { maxY = Gleis.mMid[posY] };

				if (minX > Gleis.mEnd[posX]) { minX = Gleis.mEnd[posX] };
				if (maxX < Gleis.mEnd[posX]) { maxX = Gleis.mEnd[posX] };
				if (minY > Gleis.mEnd[posY]) { minY = Gleis.mEnd[posY] };
				if (maxY < Gleis.mEnd[posY]) { maxY = Gleis.mEnd[posY] };
				
				// Collect start- mid- and end-points of Gleise to calculate the convex hull
				//points.push({ x: Gleis.mPos[posX], y: Gleis.mPos[posY], });
				//points.push({ x: Gleis.mMid[posX], y: Gleis.mMid[posY], });
				//points.push({ x: Gleis.mEnd[posX], y: Gleis.mEnd[posY], });

				// Extend the area of the hull a litte bit
				const d = 1;
				points.push({ x: Gleis.mPos[posX]+d, y: Gleis.mPos[posY]+d, });
				points.push({ x: Gleis.mMid[posX]+d, y: Gleis.mMid[posY]+d, });
				points.push({ x: Gleis.mEnd[posX]+d, y: Gleis.mEnd[posY]+d, });
				
				points.push({ x: Gleis.mPos[posX]+d, y: Gleis.mPos[posY]-d, });
				points.push({ x: Gleis.mMid[posX]+d, y: Gleis.mMid[posY]-d, });
				points.push({ x: Gleis.mEnd[posX]+d, y: Gleis.mEnd[posY]-d, });

				points.push({ x: Gleis.mPos[posX]-d, y: Gleis.mPos[posY]+d, });
				points.push({ x: Gleis.mMid[posX]-d, y: Gleis.mMid[posY]+d, });
				points.push({ x: Gleis.mEnd[posX]-d, y: Gleis.mEnd[posY]+d, });
				
				points.push({ x: Gleis.mPos[posX]-d, y: Gleis.mPos[posY]-d, });
				points.push({ x: Gleis.mMid[posX]-d, y: Gleis.mMid[posY]-d, });
				points.push({ x: Gleis.mEnd[posX]-d, y: Gleis.mEnd[posY]-d, });
			}
		}
/*console.log('Gleisobjekt ' + GleisobjektID
	+ ' min(' + minX.toFixed(1) + ' ' + minY.toFixed(1) + ') max(' + maxX.toFixed(1) + ' ' + maxY.toFixed(1) + ')'
)*/

		// Create svg group node
		if (!svgGleisobjekteGroup) {		// First Gleisobjekt
			// Show checkbox
			document.getElementById("CheckboxGleisobjekt").classList.remove("hidden");
		
			// Create svg group node
			svgGleisobjekteGroup = svgAppend(SVGfragment, {
				svg_tag	: `g`,
				'class'	: `Gleisobjekt`,
			});
		}
		const svgGleisobjektGroup = svgAppend(svgGleisobjekteGroup, {
			svg_tag	: `g`,
			id		: `GO` + GleisobjektID,
			'class'	: `${GleissystemCode[GleissystemID]}`
						+ ` height=${Gleisobjekt.PosZ.toFixed(2)}`	// Height
		});
		// simplified: show outer rectangle
		// <rect x="50" y="20" width="150" height="150"
		/*
		svgAppend(svgGleisobjektGroup, {
			svg_tag				: `rect`,
			x					: minX,
			y					: minY,
			width				: maxX - minX,
			height				: maxY - minY,
			//transform 			: matrixToTransform(...),
		});
		*/
		// Create svg for convex hull of Gleisobjekt
		// see https://www.nayuki.io/page/convex-hull-algorithm		
		const hull = convexhull.makeHull(points);
		const svgPath = hull.map(function(point, i) {
								return (i == 0 ? "M" : " L") + point.x + " " + point.y;
							}).join("") + "Z";		
		svgAppend(svgGleisobjektGroup, {
			svg_tag				: `path`,
			d					: svgPath,
		});
		
	}
}

function createSVGforKameras(SVGfragment) {
/*
	in:
		sutrackp.getElementsByTagName("Kammerasammlung")
	
	mod:
		SVGfragment
	
*/
	// Process Kameras
/*
		Wendelsteins_Kurvenbrueck_v12
		
		<Kammera name="Stellwerk West" DOF="0" Dynamic="0" FocalIdx="193" FStopIdx="13" SubDist="100" DOFSubDist="100" DOFShiftNear="9.65" DOFShiftFar="11.96" FOV="0" TakeSwitch="0">
			<Dreibein>
				<Vektor x="-25064" y="-25576" z="2098">Pos</Vektor>
				<Vektor x="0.9711025" y="-0.2179571" z="-9.723549E-02">Dir</Vektor>
				<Vektor x="0.2189948" y="0.975726" z="0">Nor</Vektor>
				<Vektor x="0.0948752" y="-2.129407E-02" z="0.9952614">Bin</Vektor>
			</Dreibein>
		</Kammera>
		Position X:					-250.64	PosX
		Position Y:					-255.76	PosY
		Position Z:					20.98	PosZ
		Neigung X:					0.00
		Neigung Y:					5.58
		Neigung Z:					-12.65
		Sichtfeld:					0.00
		Schärfentiefe:				aus 	DOF (die nachfolgenden Parameter sind dann fix)
		Brennweite:					100.00	Brennweite[FocalIdx]
		Blendenwert:				f/3.6	Blende[FStopIdx]
		Objektentfernung:			100.0	SubDist
		Hyperfokale Entfernung: 	935.48
		Vor dem Zielobjekt:			9.65	DOFShiftNear
		Hinter dem Zielobjekt:		11.96	DOFShiftFar
		Objektentfernung:			100.0	DOFSubDist

		<Kammera name="Einfahrsignal West" DOF="0" Dynamic="0" FocalIdx="193" FStopIdx="13" SubDist="100" DOFSubDist="100" DOFShiftNear="9.65" DOFShiftFar="12.965" FOV="0" TakeSwitch="0">
			<Dreibein>
				<Vektor x="-45815.86" y="-23729.89" z="1437.605">Pos</Vektor>
				<Vektor x="7403.506" y="-2208.023" z="35.84314">Dir</Vektor>
				<Vektor x="0.2858036" y="0.9582962" z="3.385832E-08">Nor</Vektor>
				<Vektor x="-4.623935E-02" y="1.379063E-02" z="0.9988322">Bin</Vektor>
			</Dreibein>
		</Kammera>
		Position X:					-458.16	PosX
		Position Y:					-237.30	PosY
		Position Z:					14.38	PosZ
		Neigung X:					0.00
		Neigung Y:					-0.27
		Neigung Z:					-16,61
		Sichtfeld:					0.00
		Schärfentiefe:				aus 	DOF (die nachfolgenden Parameter sind dann fix)
		Brennweite:					100.00	Brennweite[FocalIdx]
		Blendenwert:				f/3.6	Blende[FStopIdx]
		Objektentfernung:			100.0	SubDist
		Hyperfokale Entfernung: 	935.48
		Vor dem Zielobjekt:			9.65	DOFShiftNear
		Hinter dem Zielobjekt:		11.96	DOFShiftFar
		Objektentfernung:			100.0	DOFSubDist
*/		
	let svgKamerasGroup;
	const Kamerasammlung = sutrackp.getElementsByTagName("Kammerasammlung")[0];
	const Kameras = Kamerasammlung.getElementsByTagName("Kammera");
	let KameraID = 0;
	for (const Kamera of Kameras) {
		KameraID += 1;

		const Name 	= Kamera.getAttribute("name");
		if (Name === 'Leer') {
			continue;
		}

		// Store Kamera
		Kamera.Name 				= Name;
		Kamera.KameraID 			= KameraID;
		global.Kameras[Name] 		= Kamera;
		global.KameraSet[KameraID] 	= Kamera;

		// Process Kamera
		if (!svgKamerasGroup) {		// First Kamera
			// Show checkbox
			document.getElementById("CheckboxKamera").classList.remove("hidden");
		
			// Create svg group node
			svgKamerasGroup = svgAppend(SVGfragment, {
				svg_tag	: `g`,
				id		: `Kamera`,
				'class'	: `Kamera`,
			});
		}

		/*
		<Kammera name="Anlage" DOF="0" Dynamic="0" FocalIdx="193" FStopIdx="13" SubDist="100" DOFSubDist="100" DOFShiftNear="9.65" DOFShiftFar="11.96" FOV="0.6981317" TakeSwitch="0">
		*/
		const Dynamic 	= Kamera.getAttribute("Dynamic");

		let Laenge, mMatrix;
		let PosX, PosY, PosZ, DirX, DirY, DirZ, NorX, NorY, NorZ, BinX, BinY, BinZ;
		
		const Dreibein	= Kamera.getElementsByTagName("Dreibein")[0];
		const FramePos	= Dreibein.getElementsByTagName("Vektor")[0];
		const FrameDir	= Dreibein.getElementsByTagName("Vektor")[1];
		const FrameNor	= Dreibein.getElementsByTagName("Vektor")[2];
		const FrameBin	= Dreibein.getElementsByTagName("Vektor")[3];
		
		PosX = +FramePos.getAttribute("x") / 100;
		PosY = -FramePos.getAttribute("y") / 100;
		PosZ = +FramePos.getAttribute("z") / 100;
		
		// Bei den Kameras gibt der Dir-Vektor zum Teil sowohl die Blickrichtung wie auch die Sichtweite an und muss daher normalisiert werden
		DirX = +FrameDir.getAttribute("x");
		DirY = -FrameDir.getAttribute("y");
		DirZ = +FrameDir.getAttribute("z");
		const norm = Math.sqrt(DirX*DirX + DirY*DirY + DirZ*DirZ);
		DirX /= norm;
		DirY /= norm;
		DirZ /= norm;
		
		NorX = +FrameNor.getAttribute("x");
		NorY = -FrameNor.getAttribute("y");
		NorZ = +FrameNor.getAttribute("z");
		
		BinX = +FrameBin.getAttribute("x");
		BinY = -FrameBin.getAttribute("y");
		BinZ = +FrameBin.getAttribute("z");

		mMatrix = [DirX, DirY, DirZ, 0,    NorX, NorY, NorZ, 0,    BinX, BinY, BinZ, 0,    PosX, PosY, PosZ, 1 ];
		Kamera.mPos = mMatrix;
		
		Laenge = 40;	// arbitrary length

		let svgKameraGroup = svgAppend(svgKamerasGroup, {
			svg_tag	: `g`,
			id		: Name, 
		});
		
		// Show circle at Point
		svgAppend(svgKameraGroup, {
			svg_tag				: `circle`,
			r					: 2,
			transform 			: matrixToTransform(Kamera.mPos),
		});

		// Draw Line
		svgAppend(svgKameraGroup, {
			svg_tag				: `path`,
			d 					: `M 2 0 H ${Laenge}`,
			transform 			: matrixToTransform(Kamera.mPos)
		});
		
		//Show Name
		svgAppend(svgKameraGroup, {
			svg_tag			: `text`,
			text			: Name,			// 📷 \u1F4F7
			dx				: `2`, 			// Shift text right
			dy				: `-0.3em`, 	// Shift text up
			//dy			: `1em`, 		// Shift text below the track
			transform 		: matrixToTransform(Kamera.mPos)
							  + ` scale(1 -1)`,
		});

		// show Hoehe in the middle below the track (left-adjusted)
		svgAppend(svgKameraGroup, {
			svg_tag			: `text`,
			text			: `[${PosZ.toFixed(0)}m]`,
			dx				: `2`, 		// Shift text right a little bit
			dy				: `1em`, 		// Shift text below the track
			"class"			: `Hoehe`,
			transform 		: matrixToTransform(Kamera.mPos)
							  + ` scale(1 -1)`,
		});					

	}
}

function createSVGforRahmen(SVGfragment) {
/*
	in:
		sutrackp.getElementsByTagName("Schandlaft")
		global.usedArea
	
	mod:
		document.getElementById("heightArea")
		global.usedArea
		SVGfragment
	
*/
	// Show min/max height
	const text = (global.usedArea.min.z).toFixed(0) + " .. " + (global.usedArea.max.z).toFixed(0);
	document.getElementById("heightArea").textContent = text;

	// Groesse der Anlage (alle Positionsangaben in m statt cm)
	const Schandlaft 	= sutrackp.getElementsByTagName("Schandlaft")[0];
	const Area = {
		min : {
			x : Schandlaft.getAttribute("posX") / 100,
			y : Schandlaft.getAttribute("posY") / 100,
		},
		width  	: Math.abs(Schandlaft.getAttribute("posX") * 2 / 100),
		height 	: Math.abs(Schandlaft.getAttribute("posY") * 2 / 100),
	};

	// Verwendeter Bereich der Anlage anpassen (nicht größer als die Anlage selber)
	global.usedArea.min.x = Math.max( global.usedArea.min.x, Area.min.x );
	global.usedArea.min.y = Math.max( global.usedArea.min.y, Area.min.y );
	global.usedArea.max.x = Math.min( global.usedArea.max.x, Area.min.x + Area.width  );
	global.usedArea.max.y = Math.min( global.usedArea.max.y, Area.min.y + Area.height );
	
	// Group for additional general elements
	let svg_general_group = svgAppend(SVGfragment, {
		svg_tag	: `g`,
		id		: `general`,
	});

	// Box zur Anzeige der Groesse der Anlage
	// <rect class="box" x="-503" y="-303" width="1006" height="606" />
	svgAppend(svg_general_group, {
		svg_tag	: `rect`,
		"class"	: `box`,
		x		:  Area.min.x,
		y		:  Area.min.y,
		width	:  Area.width,
		height	:  Area.height,
	});
	// Box zur Anzeige des verwendeten Teils der Anlage
	// <rect class="box" x="-175" y="-140" width="382" height="305" />
	svgAppend(svg_general_group, {
		svg_tag	: `rect`,
		"class"	: `box`,
		x		:  global.usedArea.min.x,
		y		:  global.usedArea.min.y,
		width	:  global.usedArea.max.x - global.usedArea.min.x,
		height	:  global.usedArea.max.y - global.usedArea.min.y,
	});
	// Zusätzliche Markierung des Zentrums
	// <circle id="center" cx="0" cy="0" r="1" />
	svgAppend(svg_general_group, {
		svg_tag	: `circle`,
		id		: `center`,
		cx		:  `0`,
		cy		:  `0`,
		r		:  `1`,
	});
}

// Generate matrix command for svg
function matrixToTransform(m) {
	//       `matrix(${DirX} ${DirY} ${NorX} ${NorY} ${PosX} ${PosY})`
	//return `matrix(${m[0]} ${m[1]} ${m[4]} ${m[5]} ${m[12]} ${(m[13])})`;
	
/* https://wiki.selfhtml.org/wiki/SVG/Transformationen#matrix	
transform="matrix(1,0,0,1,0,0)" ist die Identität. Diese Angabe hat also überhaupt keinen Effekt.
transform="matrix(1,0,0,1,x,y)" entspricht transform="translate(x,y)".
transform="matrix(x,0,0,y,0,0)" entspricht transform="scale(x,y)".
transform="matrix(1,0,tan(α),1,0,0)" entspricht transform="skewX(α)".
transform="matrix(1,tan(α),0,1,0,0)" entspricht transform="skewY(α)".
transform="matrix(cos(α),sin(α),-sin(α),cos(α),0,0)" entspricht transform="rotate(α)". 
Eigentlich entspricht diese Drehmatrix der Drehung gegen den Uhrzeigersinn während rotate im Uhrzeigersinn dreht, sodass der Parameter der trigonometrischen Funktionen -α statt α sein müsste. Jedoch ist in SVG die y-Achse falschherum, wodurch sich dies gegenseitig aufhebt.
transform="matrix(cos(α),sin(α),-sin(α),cos(α),x,y) matrix(1,0,0,1,-x,-y)" entspricht transform="rotate(α,x,y)"	
*/
	
	const [	DirX, DirY, DirZ, d0, 
			NorX, NorY, NorZ, n0, 
			BinX, BinY, BinZ, b0, 
			PosX, PosY, PosZ, scale ] = m;
	return `matrix(${DirX} ${DirY} ${NorX} ${NorY} ${PosX} ${PosY})`;
}
		
function calcBezierCurve(BezierPoints, t) {
	// BezierPoints = [ [B1X, B1Y, B1Z], [B2X, B2Y, B2Z], [B3X, B3Y, B3Z], [B4X, B4Y, B4Z]];
	const B1X = BezierPoints[0][0]; // = aX;
	const B1Y = BezierPoints[0][1]; // = aY;
	const B1Z = BezierPoints[0][2]; // = aZ;
	const B2X = BezierPoints[1][0]; // = aX +bX/3;
	const B2Y = BezierPoints[1][1]; // = aX +bY/3;
	const B2Z = BezierPoints[1][2]; // = aX +bZ/3;
	const B3X = BezierPoints[2][0]; // = aX +bX*2/3 +cX/3;
	const B3Y = BezierPoints[2][1]; // = aX +bY*2/3 +cY/3;
	const B3Z = BezierPoints[2][2]; // = aX +bZ*2/3 +cZ/3;
	const B4X = BezierPoints[3][0]; // = aX +bX     +cX   +dX;
	const B4Y = BezierPoints[3][1]; // = aX +bY     +cY   +dY;
	const B4Z = BezierPoints[3][2]; // = aX +bZ     +cZ   +dZ;

	// Split the Bezier curve into two parts to calculate the position of the point 
	// https://pomax.github.io/bezierinfo/#matrixsplit
	// P(t) = (1-t)^3*B1 + 3t(1-t)^2*B2 + 3t^2(1-t)*B3 + t^3*B4
	const DeltaX = (1-t)**3*B1X + 3*t*(1-t)**2*B2X + 3*t**2*(1-t)*B3X + t**3*B4X;
	const DeltaY = (1-t)**3*B1Y + 3*t*(1-t)**2*B2Y + 3*t**2*(1-t)*B3Y + t**3*B4Y;
	const DeltaZ = (1-t)**3*B1Z + 3*t*(1-t)**2*B2Z + 3*t**2*(1-t)*B3Z + t**3*B4Z;

	// Rotation = Winkel of Tangent
	// P(t)     = (1-t)^3*B1    + 3t(1-t)^2*B2             + 3t^2(1-t)*B3         + t^3*B4
	// dP(t)/dt = -3(1-t)^2*B1  + 3(1-t)^2*B2 - 6(1-t)t*B2 + 6t(1-t)*B3 - 3t^2*B3 + 3t^2*B4
	const dPX = -3*B1X*(1-t)**2  + B2X*3*(1-t)**2 - B2X*6*(1-t)*t  + B3X*6*(1-t)*t - B3X*3*t**2  + 3*B4X*t**2;
	const dPY = -3*B1Y*(1-t)**2  + B2Y*3*(1-t)**2 - B2Y*6*(1-t)*t  + B3Y*6*(1-t)*t - B3Y*3*t**2  + 3*B4Y*t**2;
	const dPZ = -3*B1Z*(1-t)**2  + B2Z*3*(1-t)**2 - B2Z*6*(1-t)*t  + B3Z*6*(1-t)*t - B3Z*3*t**2  + 3*B4Z*t**2;
	const Winkel = Math.atan2(dPY, dPX); 
						
	return [DeltaX, DeltaY, DeltaZ, Winkel];
}

function calcClothoidCurve(A, L1, L2, RotationCCW) {
	// Approximate clothoid line
	/*	R = radius
		L = length
		A^2 = R*L
		
		x  = integral[L1,L2](cos(φ) dl)
		dx = cos(φ) dl
		y  = integral[L1,L2](sin(φ) dl)
		dy = cos(φ) dl
		
		φ is a function of l
		dφ/dL = 1/R = L/A^2
		φ = L^2/(2*A^2) = ( L/(A*sqrt(2)) )^2 
		
		let
		s = L/(A*sqrt(2))
		
		then
		φ = s^2
		l = s*A*sqrt(2)
		dl = ds*A*sqrt(2)
		
		x = A*sqrt(2) * integral[s1,s2](cos(s^2) ds)
		y = A*sqrt(2) * integral[s1,s2](sin(s^2) ds)
	*/

	const STEPCOUNT = 1000;

	const sign 	= RotationCCW;

	const a 	= A*Math.sqrt(2);

	const s1 	= (L1<L2 ? L1 : L2)/a;				// curvature = 1/radius at start point
	const s2 	= (L1<L2 ? L2 : L1)/a;				// curvature = 1/radius at end point
	
	let   s 	= 0;				// curvature at current point (we have to start at 0 0)
	const s0 	= s*s;				// angle at start point
	let   w;
	let   ds 	= s2/STEPCOUNT;		// delta curvature per step
	const ads	= a * ds;			// factor used in loop

	let   p2 	= {x:0,y:0};		// next point
	let   p		= p2;				// current point

	let   dx, dy;					// delta between points

	let   b1, b2, b3, b4;			// Bezier points
	
	const pathPoints = [];			
	
	for (let i = 1; i <= STEPCOUNT; i++) {

		p.x = p2.x;													// Set current point
		p.y = p2.y;

		w = s*s-s0;
		p2.x += dx =        ads * Math.cos(w);						// Calculate next point
		p2.y += dy = sign * ads * Math.sin(w);

		if (!b1 && Math.abs(s)>=Math.abs(s1) ) {
			b1 = {x: p.x,   y: p.y,	  dx: dx,  dy: dy,  w: w, };			// first 1. Bezier point
			
			pathPoints.push( {x: b1.x,   y: -b1.y,  z: 0,  w: b1.w, } );	// first 1. Bezier point
		};

		const f = 4;	// limit 4: max 45°, 3: max 60°
		if ( (b1 && Math.abs(w - b1.w) > (Math.PI / f)) 			// Draw new curve if difference of the angles exceeds limit  
			|| i == STEPCOUNT )  {									// or to cover the last point
			// if yes, draw the next part
			
			b4 = { x: p2.x,  y: p2.y,  dx: dx,  dy: dy,  w: w, };			// 4. Bezier point 
			b3 = {																// 3. Bezier point on intersection of tangents
					x: b1.x + ( (b4.x - b1.x) - (b4.y - b1.y) / (b4.dy / b4.dx) ) / ( 1 - ( (b1.dy / b1.dx) / (b4.dy / b4.dx)) ),
					y: b1.y + ( (b4.y - b1.y) - (b4.x - b1.x) * (b4.dy / b4.dx) ) / ( 1 - ( (b4.dy / b4.dx) / (b1.dy / b1.dx)) ),
				};
			b2 = {															// 2. Bezier point on tangent near B1 
					x: b1.x + (b3.x - b1.x) / f,							// works fine with f=4, but not with f=3
					y: b1.y + (b3.y - b1.y) / f,							// (I guess we should calculate the factor dependant on s or a)
				}	

			if (L1 < L2) {	// forward
				pathPoints.push( 	{x: b2.x,   y: -b2.y, } );					// 2. Bezier point 
				pathPoints.push( 	{x: b3.x,   y: -b3.y, } );					// 3. Bezier point 
				pathPoints.push( 	{x: b4.x,   y: -b4.y,  z: 0,  w: b4.w, } );	// 4. Bezier point 
			} else {		// backward
				pathPoints.unshift( {x: b2.x,   y: -b2.y, } );					// 2. Bezier point 
				pathPoints.unshift( {x: b3.x,   y: -b3.y, } );					// 3. Bezier point 
				pathPoints.unshift( {x: b4.x,   y: -b4.y,  z: 0,  w: b4.w, } );	// 4. Bezier point 
			}

			// Prepare next part
			b1 = { x: b4.x,  y: b4.y,  dx: dx,  dy: dy,  w: w, };	// next 1. Bezier point
		};
		
		// next
		s += ds;
	}

	// Create svg path command
	let i;
	let svgBezierPath = 'M ' + pathPoints[0].x + ' ' + pathPoints[0].y; // Complete path e.g. 'M 60 -100 C 100 100 421 154 406 249 C ...'
	for (i=1; i<pathPoints.length; i=i+3) {
		svgBezierPath += ' C ' + pathPoints[i].x + ' ' + pathPoints[i].y 
					  +  ' '   + pathPoints[i+1].x + ' ' + pathPoints[i+1].y
					  +  ' '   + pathPoints[i+2].x + ' ' + pathPoints[i+2].y;
	}
	
	// Get start and end point
	const points = {};									// Result points
	i = 0;
	points.Pos		= {								 	// Start point
		x: 		pathPoints[i].x,  
		y: 		pathPoints[i].y,  
		z: 		pathPoints[i].z, 
		Winkel: pathPoints[i].w + (L1<L2 ? 0 : Math.PI), };
	i = pathPoints.length-1; 
	points.End		= {								 	// End point
		x: 		pathPoints[i].x,  
		y: 		pathPoints[i].y,  
		z: 		pathPoints[i].z, 
		Winkel: pathPoints[i].w + (L1<L2 ? 0 : Math.PI), };
	
	return [points, svgBezierPath];
}

function process_node(node) {
	bodyAppend("p", node.nodeName + "|" + node.nodeValue + "|" + node.nodeType);

	// Process child elements
	for(let i=0; i<node.childNodes.length; i++) {
		process_node(node.childNodes[i]);
	}
}

function bodyAppend(tagName, innerHTML) {
	var elm = document.createElement(tagName);
	elm.textContent = innerHTML;
	document.body.appendChild(elm);
}

function svgAppend(svg_node, obj) {
	const svgNS 	= "http://www.w3.org/2000/svg";
	//const xlinkNS	= "http://www.w3.org/1999/xlink";
	
	// The lightweight library for manipulating and animating SVG: https://github.com/svgdotjs/svg.js
	// http://svgjs.com/
	
	// planned: optimize sequence of transform operations based on https://github.com/svg/svgo
	/*
	https://github.com/svg/svgo/blob/master/plugins/convertTransform.js
	Convert matrices to the short aliases,
	Convert long translate, scale or rotate transform notations to the shorts ones,
	Convert transforms to the matrices and multiply them all into one,
	Remove useless transforms.
	Limit transform precision with matrix one. Calculating with larger precision doesn't add any value.
	No sense in angle precision more then number of significant digits in matrix.
	Convert fixed-point numbers: 12.754997 → 12.755
	Convert long translate transform notation to the shorts one: translate(10 0) → translate(10)
	Convert long scale transform notation to the shorts one: scale(2 2) → scale(2)
	Convert long rotate transform notation to the short one: translate(cx cy) rotate(a) translate(-cx -cy) → rotate(a cx cy)
	Decrease accuracy of floating-point numbers in transforms keeping a specified number of decimals: Smart rounds values like 2.349 to 2.35.
	*/

	let element = document.createElementNS(svgNS, obj.svg_tag);

	// copy all attributes except the tag and the text
	for (const [key, value] of Object.entries(obj)) {
		if (key !== "svg_tag" && key !== "text") {
			// reduce precission of numbers ( simulated floor() operation )
			const valueString = (''+value).replace(/(\.\d{0,5})\d*/g, '$1');

			element.setAttribute(key, valueString); 
		}
	}

	if (obj.svg_tag === "text") {
		const textNode 	= document.createTextNode(obj.text);
		element.appendChild(textNode);
	}

	svg_node.appendChild(element);
	return element;
}

} // end function createSVG

/* Not used anymore
function svgAppendTextPath(svg_node, obj) {
	const svgNS 	= "http://www.w3.org/2000/svg";
	const xlinkNS	= "http://www.w3.org/1999/xlink";

	// Create special element using attributes href, text, text-anchor (optional)
	// Example:
	// <text><textPath startOffset="50%" href="#G1-1">1</textPath></text>

	const textNode 	= document.createTextNode(obj.text);

	const textPath 	= document.createElementNS(svgNS, "textPath");
	textPath.setAttribute("class", obj.class);
	if (obj["text-anchor"] === "middle") {
		textPath.setAttribute("startOffset", "50%");
	}
	else if (obj["text-anchor"] === "end") {
		textPath.setAttribute("startOffset", "90%"); // How to put the text exactly to the end?
	}
	textPath.setAttributeNS(xlinkNS, "xlink:href", obj.href);
	textPath.appendChild(textNode);

	const text 		= document.createElementNS(svgNS, "text");
	if (obj["text-anchor"]) { text.setAttribute("text-anchor", obj["text-anchor"]); }
	text.appendChild(textPath);
	text.setAttribute("dy", "-0.1em"); // Shift text up the track

	svg_node.appendChild(text);

	return text;
}
*/

</script>

<script type="text/javascript"> // https://www.nayuki.io/page/convex-hull-algorithm
/* Explanations and animation of the algorithm
https://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain
*/   
/* 
 * Convex hull algorithm - Library (JavaScript)
 * 
 * Copyright (c) 2018 Project Nayuki
 * https://www.nayuki.io/page/convex-hull-algorithm
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program (see COPYING.txt and COPYING.LESSER.txt).
 * If not, see <http://www.gnu.org/licenses/>.
 */

"use strict";

const convexhull = new function() {
	
	// Returns a new array of points representing the convex hull of
	// the given set of points. The convex hull excludes collinear points.
	// This algorithm runs in O(n log n) time.
	this.makeHull = function(points) {
		const newPoints = points.slice();					// copy array
		newPoints.sort(POINT_COMPARATOR);					// sort first by x-coordinate, and in case of a tie, by y-coordinate
		return this.makeHullPresorted(newPoints);
	};
	
	
	// Returns the convex hull, assuming that each points[i] <= points[i + 1]. Runs in O(n) time.
	this.makeHullPresorted = function(points) {
		if (points.length <= 1) {							// just 0 or 1 point
			return points.slice();
		}
		
		// Andrew's monotone chain algorithm. Positive y coordinates correspond to "up"
		// as per the mathematical convention, instead of "down" as per the computer
		// graphics convention. This doesn't affect the correctness of the result.
		
		// The upper hull is the part of the convex hull, which is visible from above. 
		const upperHull = [];
		for (let i = 0; i < points.length; i++) {			// inspect all points from left to right
			const p = points[i];							// current point
			while (upperHull.length >= 2) {					// do we at least have 2 more points in this part of the hull
				const q = upperHull[upperHull.length - 1];	// last point in this part of the hull
				const r = upperHull[upperHull.length - 2];	// pre-last point in this part of the hull
				if ( cross(q, p, r) ) {						// check turn direction of these 3 points
					upperHull.pop();						// wrong turn direction -> remove inner point q
				} else {
					break;
				}
			}
			upperHull.push(p);								// add current point temporarily to this part of the hull
		}
		upperHull.pop();									// Remove the last point of each list (it's the same as the first point of the other list).
		
		// The lower hull is the part of the convex hull, which is visible from below. 
		const lowerHull = [];
		for (let i = points.length - 1; i >= 0; i--) {		// inspect all points from right to left
			const p = points[i];							// current point
			while (lowerHull.length >= 2) {					// do we at least have 2 more points in this part of the hull
				const q = lowerHull[lowerHull.length - 1];	// last point in this part of the hull
				const r = lowerHull[lowerHull.length - 2];	// pre-last point in this part of the hull
				if ( cross(q, p, r) ) {						// check turn direction of these 3 points
					lowerHull.pop();						// wrong turn direction -> remove inner point q
				} else {
					break;
				}
			}
			lowerHull.push(p);								// add current point temporarily to this part of the hull
		}
		lowerHull.pop();									// Remove the last point of each list (it's the same as the first point of the other list).
		
		if (upperHull.length == 1 && lowerHull.length == 1 && upperHull[0].x == lowerHull[0].x && upperHull[0].y == lowerHull[0].y) {
			return upperHull;					// just 1 point
		} else {
			return upperHull.concat(lowerHull);	// multiple points in the result will be listed in counter-clockwise order.
		}
	};
	
	function POINT_COMPARATOR(a, b) {
		// return a.x == b.x ? a.y - b.y : a.x - b.x;
		if 		(a.x < b.x)	return -1;			// sort first by x-coordinate, 
		else if (a.x > b.x)	return +1;
		else if (a.y < b.y)	return -1;			// and in case of a tie, by y-coordinate
		else if (a.y > b.y)	return +1;
		else				return 0;			// identical points
	};
	
	function cross(q, p, r) {
		return 	(q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x);
	}
	
};
</script>
</section>  <!-- Selection screen --> 

<section id="loading" class="hidden"> <!-- Progress bar screen --> 
Lade... <progress id="progress" class="hidden" max="100"></progress>
<style> /* Progress bar screen */
#loading {						/* progress bar */
	text-align: center;
	width: 100%;
}
</style>
</section> <!-- Progress bar screen --> 

<main id="main" class="column hidden"> <!-- Main screen --> 
<style> /* Flex main screen */
#main {
	margin: 0;
	padding: 0;
}

/* flex */

#main {
	height: 100vh;
}

#main.column {
	display: flex;				/* top level flex */
	flex-direction: column; 	/* vertically stacked */
}
#main.column #heading {
	flex: 0;					/* shrink as much as possible */
	margin-bottom: 0px;
	border-bottom: 1px dotted #3983ab;
}
#main.column #container {
	flex: 1;					/* grow as much as possible */

	display: flex;				/* second level flex for svg */
}
#main.column #controls {
	display: flex;				/* second level flex for article within heading */
	flex-direction: row; 		/* horizontally */
	flex-wrap: wrap;
	justify-content: space-between;
	margin-left: 0px;
	margin-right: 0px;
}
#main.column #controls .group {
	flex: 1;
	margin: 0px;
	border-right: 1px dotted;
	padding-top: 5px;
	padding-left: 5px;
	padding-right: 5px;
}

#main.row {
	display: flex;
	flex-direction: row; 		/* side by side */
}
#main.row #heading {
	flex: 1;					/* 1/5 = width: 20% */
	border-right: 1px dotted #3983ab;
}
#main.row #container {
	flex: 4;					/* 4/5 = width: 80% */

	display: flex;				/* second level flex for svg */
}
#main.row #controls {
	display: flex;				/* second level flex for div within heading */
	flex-direction: column; 	/* vertically */
	flex-wrap: wrap;
	justify-content: space-between;
}
#main.row #controls .group {
	flex: 1;
	margin: 5px;
}

#svg {
	flex: 1;
	height: 100%;
}
</style>

<section id="heading"> <!-- The heading shows the header and the controls -->
<style> /* heading */
#heading {
	background-color: var(--body-background-color);
	color: var(--body-text-color);
}

#controls input[type="number"]#number, 
input[type="number"]#sizePNG,
input[type="number"]#exportSize,
input[type="number"]#jpgQuality {
	width:60px;
}

#controls .fieldset {
	border-width: 0;
	margin-inline-start: 0;
	margin-inline-end: 0;
	padding-block-start: 0;
	padding-inline-start: 0;
	padding-inline-end: 0;
	padding-block-end: 0;
}
#controls .fieldset .item {
	white-space: nowrap;		/* keep checkbox and label together */
	display:inline;				/* but do no add extra line breaks per item */
}
</style>
<nav id="controls">

<header class="group">
<h3 id="filename">EEP Gleisplan</h3>
</header>

<article class="group no-select"> <!-- Buttons, line and font size -->
<button id="swap">swap</button>
<!--<input type="number" name="sizePNG" id="sizePNG" value="3000" min="1"> -->
<button id="savePNG">Export PNG/JPG/SVG</button>
<button id="setColors">Farben</button>
<br>
<button id="zoom-in">+</button>
<button id="zoom-out">-</button>
<button id="resetzoom">reset zoom</button>
<button id="reset">reset all</button>
<!-- enable/disable of controls of SvgPanZoom within the graphic
	<button id="enable">enable controls</button>
	<button id="disable">disable controls</button>
-->
<br>
Linie <input type="range" min="1" max="150" value="75" name="strokeWidth" id="strokeWidth" autocomplete="off" />
<br>
Font <input type="range" min="1" max="100" value="75" name="fontSize" id="fontSize" autocomplete="off" />
</article>

<article class="group no-select"> <!-- Auswahl des im Zentrum anzuzeigendes Objektes -->
<select id="select" >
	<option value="1">Eisenbahn</option>
	<option value="2">Straßenbahn</option>
	<option value="3">Straße</option>
	<option value="4">Wasserwege</option>
	<option value="5">Steuerstrecken</option>
	<option value="6">GBS</option>
	<option value="I">Signal/Weiche</option>
<!--
	<option value="K">Kontakt</option>
-->
</select>
<input type="number" id="number" value="1" min="1">
<button id="centerItem">Zeige Objekt </button>
<div id="message"></div>
</article>

<article class="group"> <!-- Status line -->
Min/Max Höhe der Anlage: <span id="heightArea"></span><br>

<!-- Begin: Two handled slider for min/max height -->
<!-- https://leaverou.github.io/multirange/ 
Features:
	Only 0.6KB minified & gzipped!
	No dependencies.
	Uses feature detection, will not run if two-handle sliders are natively supported.
	Keyboard accessible
	Clicking on the track still works
	Handles can be moved past each other
	Customizable styling
	JS properties polyfilled too (input.value, input.valueLow, input.valueHigh)
API:
	JS: Use the multirange(element) function to process sliders added to the page later.
	CSS: Use the --range-color property to change the color of the range. Use the --track-background property for more extensive customization.
	HTML: Use the multiple attribute to enable the second handle. Use data-drag-middle attribute to enable moving both handles by dragging the middle of the track between them.
-->
<style>
@supports (--css: variables) {
	input[type="range"].multirange {
		padding: 0;
		margin: 0;
		display: inline-block;
		vertical-align: top;
	}
		input[type="range"].multirange::-moz-range-thumb {
			transform: scale(1); /* FF doesn't apply position it seems */
		}

	input[type="range"].multirange.original {
		position: absolute;
	}

		input[type="range"].multirange.original::-webkit-slider-thumb {
			position: relative;
			z-index: 2;
		}

		input[type="range"].multirange.original::-moz-range-thumb {
			z-index: 2;
		}

		input[type="range"].multirange::-moz-range-track {
			border-color: transparent; /* needed to switch FF to "styleable" control */
		}

	input[type="range"].multirange.middle {
		position: absolute;
		-webkit-appearance: none;
	}
		input[type="range"].multirange.middle:focus {
			outline: none;
		}
		input[type="range"].multirange.middle::-moz-range-thumb {
			position: relative;
			z-index: 1;
			height: 9px;
			width: var(--size);
			margin-top: 6px;
			margin-bottom: 6px;
			background: transparent;
			cursor: pointer;
			border: 0;
		}
		input[type="range"].multirange.middle::-webkit-slider-thumb {
			position: relative;
			z-index: 1;
			height: 9px;
			width: var(--size);
			margin-top: 6px;
			margin-bottom: 6px;
			background: transparent;
			-webkit-appearance: none;
			cursor: pointer;
		}

	input[type="range"].multirange.ghost {
		position: relative;
		background: var(--track-background);
		--track-background: linear-gradient(		/* color of different parts of the bar */
				to right,							/* direction from left to right */
				transparent 		var(--low), 	/* no color up to left slider */
				var(--range-color) 	0,				/* constant color starting with left slider */
				var(--range-color) 	var(--high), 	/* constant color ending at right slider */
				transparent 		0				/* no color right of sliders */
			) no-repeat 0 45% / 100% 20%;			/* "0" "relative vertical position" / "relative width" "relative height=thickness" */
		--range-color: hsl(190, 80%, 40%);			/* base color of bar hsl(hue, satuation, lightness)*/ 
	}

		input[type="range"].multirange.ghost::-webkit-slider-runnable-track {
			background: var(--track-background);
		}

		input[type="range"].multirange.ghost::-moz-range-track {
			background: var(--track-background);
		}
		input[type="range"].multirange.ghost::-webkit-slider-thumb {
			position: relative;
			z-index: 2;
		}
		input[type="range"].multirange.ghost::-moz-range-thumb {
			z-index: 2;
		}

}
</style>

<style>
#heightRange {
	width: 200px;
}
</style>
<input id="heightRange" type="range" multiple value="0,100" data-drag-middle /><br>

<script type="text/javascript">
"use strict";
(function() {

var supportsMultiple = self.HTMLInputElement && "valueLow" in HTMLInputElement.prototype;

var descriptor = Object.getOwnPropertyDescriptor(HTMLInputElement.prototype, "value");

var multirange = function(input) {
	if (supportsMultiple || input.classList.contains("multirange")) {
		return;
	}

	var value = input.getAttribute("value");
	var values = value === null ? [] : value.split(",");
	var min = +(input.min || 0);
	var max = +(input.max || 100);
	var ghost = input.cloneNode();
	var dragMiddle = input.getAttribute("data-drag-middle") !== null;
	var middle = input.cloneNode();

	input.classList.add("multirange", "original");
	ghost.classList.add("multirange", "ghost");

	input.value = values[0] || min + (max - min) / 2;
	ghost.value = values[1] || min + (max - min) / 2;

	input.parentNode.insertBefore(ghost, input.nextSibling);

	Object.defineProperty(input, "originalValue", descriptor.get ? descriptor : {
		// Fuck you Safari >:(
		get: function() { return this.value; },
		set: function(v) { this.value = v; }
	});

	Object.defineProperties(input, {
		valueLow: {
			get: function() { return Math.min(this.originalValue, ghost.value); },
			set: function(v) { this.originalValue = v; update(); },
			enumerable: true
		},
		valueHigh: {
			get: function() { return Math.max(this.originalValue, ghost.value); },
			set: function(v) { ghost.value = v; update(); },
			enumerable: true
		}
	});

	if (descriptor.get) {
		// Again, fuck you Safari
		Object.defineProperty(input, "value", {
			get: function() { return this.valueLow + "," + this.valueHigh; },
			set: function(v) {
				var values = v.split(",");
				this.valueLow = values[0];
				this.valueHigh = values[1];
				update();
			},
			enumerable: true
		});
	}

	if (typeof input.oninput === "function") {
		ghost.oninput = input.oninput.bind(input);
	}

	function update(mode) {
		ghost.style.setProperty("--low", 100 * ((input.valueLow - min) / (max - min)) + 1 + "%");
		ghost.style.setProperty("--high", 100 * ((input.valueHigh - min) / (max - min)) - 1 + "%");

		if (dragMiddle && mode !== 1) {
			let w = input.valueHigh - input.valueLow;
			if (w>1) w-=0.5;
			middle.style.setProperty("--size", (100 * w / (max - min)) + "%");
			middle.value = min + (input.valueHigh + input.valueLow - 2*min - w)*(max - min)/(2*(max - min - w));
		}
		
		// Process changed values (this should be a callback function instead)
		changeHeightRange(input.valueLow, input.valueHigh);
	}

	ghost.addEventListener("mousedown", function passClick(evt) {
		// Find the horizontal position that was clicked
		let clickValue = min + (max - min)*evt.offsetX / this.offsetWidth;
		let middleValue = (input.valueHigh + input.valueLow)/2;
		if ( (input.valueLow == ghost.value) == (clickValue > middleValue) ) {
			// Click is closer to input element and we swap thumbs
			input.value = ghost.value;
		}
	});
	input.addEventListener("input", update);
	ghost.addEventListener("input", update);

	if (dragMiddle) {
		middle.classList.add("multirange", "middle");
		input.parentNode.insertBefore(middle, input.nextSibling);
		middle.addEventListener("input", function () {
			let w = input.valueHigh - input.valueLow;
			let m = min + w/2 + (middle.value - min)*(max - min - w)/(max-min);
			input.valueLow = m - w/2;
			input.valueHigh = input.valueLow+w;
			update(1);
		});
	}

	update();
}

multirange.init = function() {
	[].slice.call(document.querySelectorAll("input[type=range][multiple]:not(.multirange)")).forEach(multirange);
}

if (typeof module === "undefined") {
	self.multirange = multirange;
	if (document.readyState == "loading") {
		document.addEventListener("DOMContentLoaded", multirange.init);
	}
	else {
		multirange.init();
	}
} else {
	module.exports = multirange;
}

})(this);
</script>
<!-- End: Two handled slider for min/max height -->

Sichtbarer Bereich: <span id="visibleArea"> </span><br>
Zentrum des Bereichs: <span id="centerPosition"> </span><br>
Cursor: <span id="cursorPosition"> </span>
</article>

<article class="group no-select"> <!-- Auswahl der anzuzeigenden Objekte. class=hidden wird für diese Objekte enfernt wenn eine Checkbox aktiv ist -->
<fieldset class="fieldset">
	<!-- Firefox keeps the status of the checkbox between page loads by default. -->
	<div class="item Eisenbahn hidden"><label>					<!-- only visible if there are elements of that type -->
	<input type="checkbox" name="Eisenbahn" 	checked autocomplete="off" onchange="toggleElements('.Eisenbahn', this.checked)">Eisenbahn</label></div>
	<div class="item Strassenbahn hidden"><label>				<!-- only visible if there are elements of that type -->
	<input type="checkbox" name="Strassenbahn" 	checked autocomplete="off" onchange="toggleElements('.Strassenbahn', this.checked)">Straßenbahn</label></div>
	<div class="item Strasse hidden"><label>					<!-- only visible if there are elements of that type -->
	<input type="checkbox" name="Strasse" 		checked autocomplete="off" onchange="toggleElements('.Strasse', this.checked)">Straße</label></div>
	<div class="item Wasserwege hidden"><label>					<!-- only visible if there are elements of that type -->
	<input type="checkbox" name="Wasserwege" 	checked autocomplete="off" onchange="toggleElements('.Wasserwege', this.checked)">Wasserwege</label></div>
	<div class="item Steuerstrecken hidden"><label>				<!-- only visible if there are elements of that type -->
	<input type="checkbox" name="Steuerstrecken" checked autocomplete="off" onchange="toggleElements('.Steuerstrecken', this.checked)">Steuerstrecken</label></div>
	<div class="item GBS hidden"><label>						<!-- only visible if there are elements of that type -->
	<input type="checkbox" name="GBS" 			checked autocomplete="off" onchange="toggleElements('.GBS', this.checked)">GBS</label></div>
	<div class="item"><label>	<!-- GleisID -->
	<input type="checkbox" name="GleisID" 		checked autocomplete="off" onchange="toggleElements('.GleisID', this.checked)">GleisID</label></div>
	<div class="item hidden" id="CheckboxCurveType"><label>		<!-- only visible if there are elements of that type = EEP 16 -->
	<input type="checkbox" name="CurveType" 	checked autocomplete="off" onchange="toggleElements('.CurveType', this.checked)">Gleisart</label></div>
	<div class="item"><label>	<!-- Stil -->
	<input type="checkbox" name="Stil" 			checked autocomplete="off" onchange="toggleElements('.Stil', this.checked)">Stil</label></div>
	<div class="item"><label>	<!-- Hoehe -->
	<input type="checkbox" name="Hoehe" 		checked autocomplete="off" onchange="toggleElements('.Hoehe', this.checked)">Höhe</label></div>
	<div class="item"><label>	<!-- WeicheText -->
	<input type="checkbox" name="WeicheText" 	checked autocomplete="off" onchange="toggleElements('.WeicheText', this.checked)">Weichen</label></div>
	<div class="item"><label>	<!-- Signal -->
	<input type="checkbox" name="Signal" 		checked autocomplete="off" onchange="toggleElements('.Signal', this.checked)">Signale</label></div>
	<div class="item"><label>	<!-- Kontakt -->
	<input type="checkbox" name="Kontakt" 		checked autocomplete="off" onchange="toggleElements('.Kontakt', this.checked)">Kontakte</label></div>
	<div class="item"><label>	<!-- active -->
	<input type="checkbox" name="active" 		checked autocomplete="off" onchange="toggleElements('.active', this.checked)">aktiv</label></div>
	<div class="item"><label>	<!-- inactive -->
	<input type="checkbox" name="inactive" 		checked autocomplete="off" onchange="toggleElements('.inactive', this.checked)">inaktiv</label></div>
	<div class="item"><label>	<!-- unsichtbar -->
	<input type="checkbox" name="unsichtbar" 	checked autocomplete="off" onchange="toggleElements('.unsichtbar', this.checked)">unsichtbar</label></div>
	<div class="item"><label>	<!-- Marker -->
	<input type="checkbox" name="Marker" 		checked autocomplete="off" onchange="toggleMarker(this.checked)">Marker</label></div>
	<div class="item hidden" id="CheckboxGleisobjekt"><label>	<!-- only visible if there are elements of that type -->
	<input type="checkbox" name="Gleisobjekt" 	checked autocomplete="off" onchange="toggleElements('.Gleisobjekt', this.checked)">Gleisobjekte</label></div>
	<div class="item hidden" id="CheckboxKamera"><label>		<!-- only visible if there are elements of that type -->
	<input type="checkbox" name="Kamera" 	    checked autocomplete="off" onchange="toggleElements('#Kamera', this.checked)">Kameras</label></div>
	<div class="item"><label>
	<input type="checkbox" name="general" 	    checked autocomplete="off" onchange="toggleElements('#general', this.checked)">Rahmen</label></div>
</fieldset>
</article>

</nav> <!-- controls -->
</section>  <!-- heading -->

<section id="container"> <!-- The container takes the remainig part of the screen to show the graphic -->
<!-- 
svg editor: https://github.com/SVG-Edit/svgedit
https://svg-edit.github.io/svgedit/releases/latest/editor/svg-editor.html
-->

<svg id="svg" xmlns="http://www.w3.org/2000/svg" version="1.1">

<title>EEP Gleisplan</title>
<desc>EEP Gleisplan</desc>
<defs> <!-- style -->
	<style type="text/css" id="css-track-colors"> /* dynamic update via Javascript to adjust color per track type */
	/* <![CDATA[ */
svg {
	--Eisenbahn-color: red;
	--Strassenbahn-color: darkgray;
	--Strasse-color: grey;
	--Wasserwege-color: blue;
	--Steuerstrecken-color: purple;
	--GBS-color: brown;
	--Kamera-color: green;
	--Hintergrund-color: white;							
}
	/* ]]> */
	</style>

	<style type="text/css" id="css-marker-colors"> /* dynamic update via Javascript to hide/show markers */
	/* <![CDATA[ */
svg {
	--Eisenbahn-marker-color: var(--Eisenbahn-color);
	--Strassenbahn-marker-color: var(--Strassenbahn-color);
	--Strasse-marker-color: var(--Strasse-color);
	--Wasserwege-marker-color: var(--Wasserwege-color);
	--Steuerstrecken-marker-color: var(--Steuerstrecken-color);
	--GBS-marker-color: var(--GBS-color);
	--Kamera-marker-color: var(--Kamera-color);
}
	/* ]]> */
	</style>

	<style type="text/css" id="css-strokeWidth-variables"> /* dynamic update via Javascript to adjust line size */
	/* <![CDATA[ */
svg {
	--normal-stroke-width: 0.5px;
	--narrow-stroke-width: 0.25px;
}
	/* ]]> */
	</style>

	<style type="text/css" id="css-fontSize-variables"> /* dynamic update via Javascript to adjust font size */
	/* <![CDATA[ */
svg {
	--normal-font-size: 3px;
}
	/* ]]> */
	</style>

	<style type="text/css">
	/* <![CDATA[ */
svg {
	background: var(--Hintergrund-color);
	border: 0; /* 1px dotted #3983ab; */
	padding: 0;
	box-sizing: border-box;
	/* transform: scale(1,-1);     		not useful as it would mirror the text, too */
}

/* Texte für Signale, Weichen etc. */
text {
	font-size: var(--normal-font-size);
	font-family: Arial;
	stroke-width: 0;
}

/* not used */
textPath {
}

text.GleisID {
	text-anchor	: start;
}

text.CurveType {
	text-anchor	: end;
}

text.Stil {
	text-anchor	: end;
	font-style: italic;
}

text.Hoehe {
	text-anchor	: start;
	font-style: italic;
}

text.WeicheText {
	text-anchor	: end;
}

.Signal text, .Kontakt text {
	text-anchor	: middle;
}

#Kamera text {
	text-anchor	: start;
}

/* Box zur Anzeige der verwendeten Groesse der Anlage */
.box {
	stroke-width: 0.1;
	stroke: black;
	fill:   none;
	stroke-dasharray: 1;
}

/* Zusätzliche Markierung des Zentrums */
#center {
	stroke-width: 0;
	stroke: grey;
	fill:   grey;
}

/* Individuelle Formatierung je Gleissystem */

.Eisenbahn {
	stroke-width: var(--normal-stroke-width);
	stroke: var(--Eisenbahn-color);
	fill:   none;
	marker-start: url(#EisenbahnMarkerCircle);
	marker-end:   url(#EisenbahnMarkerArrow);
	/* stroke-dasharray: 0.2 0.4; */ /* Schwellenabstand von 60cm */
}
#EisenbahnMarkerCircle, #EisenbahnMarkerArrow {
	fill: var(--Eisenbahn-marker-color);
}
.Eisenbahn text {
	fill: var(--Eisenbahn-color);
}

.Strassenbahn {
	stroke-width: var(--normal-stroke-width);
	stroke: var(--Strassenbahn-color);
	fill:   none;
	marker-start: url(#StrassenbahnMarkerCircle);
	marker-end:   url(#StrassenbahnMarkerArrow);
}
#StrassenbahnMarkerCircle, #StrassenbahnMarkerArrow {
	fill: var(--Strassenbahn-marker-color) ;
}
.Strassenbahn text {
	fill: var(--Strassenbahn-color) ;
}

.Strasse {
	stroke-width: var(--normal-stroke-width);
	stroke: var(--Strasse-color);
	fill:   none;
	marker-start: url(#StrasseMarkerCircle);
	marker-end:   url(#StrasseMarkerArrow);
}
#StrasseMarkerCircle, #StrasseMarkerArrow {
	fill: var(--Strasse-marker-color);
}
.Strasse text {
	fill: var(--Strasse-color);
}

.Wasserwege {
	stroke-width: var(--narrow-stroke-width);
	stroke: var(--Wasserwege-color);
	fill:   none;
	marker-start: url(#WasserwegeMarkerCircle);
	marker-end:   url(#WasserwegeMarkerArrow);
}
#WasserwegeMarkerCircle, #WasserwegeMarkerArrow {
	fill: var(--Wasserwege-marker-color);
}
.Wasserwege text {
	fill: var(--Wasserwege-color);
}

.Steuerstrecken {
	stroke-width: var(--narrow-stroke-width);
	stroke: var(--Steuerstrecken-color);
	fill:   none;
	marker-start: url(#SteuerstreckenMarkerCircle);
	marker-end:   url(#SteuerstreckenMarkerArrow);
}
#SteuerstreckenMarkerCircle, #SteuerstreckenMarkerArrow {
	fill: var(--Steuerstrecken-marker-color);
}
.Steuerstrecken text {
	fill: var(--Steuerstrecken-color);
}

.GBS {
	stroke-width: var(--narrow-stroke-width);
	stroke: var(--GBS-color);
	fill:   none;
	marker-start: url(#GBSMarkerCircle);
	marker-end:   url(#GBSMarkerArrow);
}
#GBSMarkerCircle, #GBSMarkerArrow {
	fill: var(--GBS-marker-color);
}
.GBS text {
	fill: var(--GBS-color);
}

#Kamera {
	stroke-width: calc(var(--normal-stroke-width) * 1.5);
	stroke: var(--Kamera-color);
	fill:   none;
	/* marker-start: url(#KameraMarkerCircle); */
	marker-end:   url(#KameraMarkerArrow);
}
#KameraMarkerCircle, #KameraMarkerArrow {
	fill: var(--Kamera-marker-color);
}
#Kamera text {
	fill: var(--Kamera-color);
}

/* Gleisobjekte werden als transparente Flächen in der Farbe der jeweiligen Gleissysteme dargestellt */ 

.Gleisobjekt * {
	stroke: none;
	marker-start: none;
	marker-end: none;
}

.Gleisobjekt rect {
	fill-opacity: 0;		/* hide it */
	filter: url(#blur);   	/* #blur #dilate #dilate+blur */
}
.Gleisobjekt path {
	fill-opacity: 0.2;
	filter: url(#blur);  	/* #blur #dilate #dilate+blur */
}

.Gleisobjekt .Eisenbahn {
	fill: var(--Eisenbahn-color);
}

.Gleisobjekt .Strassenbahn {
	fill: var(--Strassenbahn-color);
}

.Gleisobjekt .Strasse {
	fill: var(--Strasse-color);
}

.Gleisobjekt .Wasserwege {
	fill: var(--Wasserwege-color);
}

.Gleisobjekt .Steuerstrecken {
	fill: var(--Steuerstrecken-color);
}

.Gleisobjekt .GBS {
	fill: var(--GBS-color);
}

/* Besondere Objekte */

.Prellbock {
	marker-end:   url(#Prellbock);
}

/* Symbole */

#SymbolSignal, #SymbolPreSignal, #SymbolFStart, #SymbolFZiel, #SymbolKontakt {
	marker-start: none;
	marker-end:   none;
	stroke-width: var(--narrow-stroke-width);
	fill:   none;
}

/* Individuelle Formatierung je Gleisstil */

.stil-1353 { 	/* Gleis mit Betonschwellen */
}

.stil-5146 { 	/* Farm track */
	stroke: brown;
}

.unsichtbar {	/* unsichtbare Gleisstile */
	stroke-dasharray: 0.4 0.2;
}

.inactive {		/* inaktive Gleisstile */
	stroke-opacity: 0.5;
}

/* versteckte Elemente */

.hidden, .hiddenZ {
	display: none !important;
}
	/* ]]> */
	</style>
</defs>

<defs> <!-- Filters, Symbols and Markers -->
	<!-- Dilate and blur Gleisobjekte -->
	<filter id="dilate">
		<feMorphology operator="dilate" radius="3" />
	</filter>
	<filter id="blur">
		<feGaussianBlur stdDeviation="0.2" />
	</filter>
	<filter id="dilate+blur">
		<feMorphology operator="dilate" radius="2" />
		<feGaussianBlur stdDeviation="1" />
	</filter>

	<!-- Use of symbols requires translate(-10 0) to move the origin M 0 0 to the correct position -->
	<!-- <path d="M 0 0 L 4 3 A 12 12  0 0 1  -4 3 z" /> --> <!-- Kreissegment -->
	<!-- <path d="M 0 0 L 0 1.2 L 4.8 1.2 L 4.8 5.8 L -4.8 5.8 L -4.8 1.2 L 0 1.2" /> --> <!-- Box -->
	<!-- <path d="M 0 0 L 0 0.9" /><circle cx="0" cy="1.5" r="0.6" /> --> <!-- Linie mit Kreis -->
	<symbol id="SymbolSignal" width="20" height="10" viewBox="-10 0 20 10">
		<path d="M 0 0 L 0 0.9  M 0.25 0.9 L 0.6 1.25 L 0.6 1.75 L 0.25 2.1  L -0.25 2.1 L -0.6 1.75 L -0.6 1.25 L -0.25 0.9 Z" /> <!-- Linie mit Achteck --> 
	</symbol>
	<symbol id="SymbolPreSignal" width="20" height="10" viewBox="-10 0 20 10">
		<path d="M 0 0 L 0 0.9" /><circle cx="0" cy="1.3" r="0.4" /> <!-- Linie mit kleinem Kreis -->
	</symbol>
	<symbol id="SymbolKontakt" width="20" height="10" viewBox="-10 0 20 10">
		<path d="M 0 0 L 0 0.9  M 0 0.9 L 0.7 2.1 L -0.7 2.1 Z" /> <!-- Linie mit Dreieck -->
	</symbol>
	<symbol id="SymbolFStart" width="20" height="10" viewBox="-10 0 20 10">
		<path d="M 0 0 L 0 1.1  M 0 1.1 L 0.41 0.83 L 0.29 1.3 L 0.67 1.6 L 0.17 1.65 L 0 2.1  L -0.17 1.65 L -0.67 1.6 L -0.29 1.3 L -0.41 0.83 Z" /> <!-- Linie mit 5er Stern -->
	</symbol>
	<symbol id="SymbolFZiel" width="20" height="10" viewBox="-10 0 20 10">
		<path d="M 0 0 L 0 0.9  M 0 0.9 L -1.2 0.9 L -1.2 2.1 L 0 2.1 Z  M -0.6 0.9 L -0.6 2.1  M 0 1.5 L -1.2 1.5" /> <!-- Linie mit Flagge -->
	</symbol>

	<!-- Prellbock: Querbalken -->
	<marker id="Prellbock" 	markerWidth="2" markerHeight="4" refX="2" refY="2" orient="auto">
		<rect x="0" y="0" width="2" height="4"/>
	</marker>

	<!-- We need individual markers to be able to apply CSS -->
	<marker id="EisenbahnMarkerCircle" 		markerWidth="5" markerHeight="5" refX="2" refY="3">
		<circle cx="3" cy="3" r="1" />
	</marker>
	<marker id="StrassenbahnMarkerCircle"	markerWidth="5" markerHeight="5" refX="2" refY="3">
		<circle cx="3" cy="3" r="1" />
	</marker>
	<marker id="StrasseMarkerCircle" 		markerWidth="5" markerHeight="5" refX="2" refY="3">
		<circle cx="3" cy="3" r="1" />
	</marker>
	<marker id="WasserwegeMarkerCircle" 	markerWidth="5" markerHeight="5" refX="2" refY="3">
		<circle cx="3" cy="3" r="1" />
	</marker>
	<marker id="SteuerstreckenMarkerCircle" markerWidth="5" markerHeight="5" refX="2" refY="3">
		<circle cx="3" cy="3" r="1" />
	</marker>
	<marker id="GBSMarkerCircle" 			markerWidth="5" markerHeight="5" refX="2" refY="3">
		<circle cx="3" cy="3" r="1" />
	</marker>
	<marker id="KameraMarkerCircle" 		markerWidth="5" markerHeight="5" refX="2" refY="3">
		<circle cx="3" cy="3" r="1" />
	</marker>

	<marker id="EisenbahnMarkerArrow" 		markerWidth="5" markerHeight="5" refX="2" refY="3" orient="auto">
		<path d="M0,1 L0,5 L3,3 L0,1" />
	</marker>
	<marker id="StrassenbahnMarkerArrow" 	markerWidth="5" markerHeight="5" refX="2" refY="3" orient="auto">
		<path d="M0,1 L0,5 L3,3 L0,1" />
	</marker>
	<marker id="StrasseMarkerArrow" 		markerWidth="5" markerHeight="5" refX="2" refY="3" orient="auto">
		<path d="M0,1 L0,5 L3,3 L0,1" />
	</marker>
	<marker id="WasserwegeMarkerArrow" 		markerWidth="5" markerHeight="5" refX="2" refY="3" orient="auto">
		<path d="M0,1 L0,5 L3,3 L0,1" />
	</marker>
	<marker id="SteuerstreckenMarkerArrow" 	markerWidth="5" markerHeight="5" refX="2" refY="3" orient="auto">
		<path d="M0,1 L0,5 L3,3 L0,1" />
	</marker>
	<marker id="GBSMarkerArrow" 			markerWidth="5" markerHeight="5" refX="2" refY="3" orient="auto">
		<path d="M0,1 L0,5 L3,3 L0,1" />
	</marker>
	<marker id="KameraMarkerArrow" 			markerWidth="5" markerHeight="5" refX="2" refY="3" orient="auto">
		<path d="M0,1 L0,5 L3,3 L0,1" />
	</marker>

</defs>

<g id="sutrackp" class="svg-pan-zoom_viewport">
<!-- hier werden dynamisch die weiteren svg-Elemente der EEP Anlage eingefügt -->
</g>

</svg>

</section> <!-- container -->

<!-- local library -->
<!-- <script type="text/javascript" src="svg-pan-zoom/dist/svg-pan-zoom.js"></script>
<!-- remote library on GitHub pages -->
<script type="text/javascript" src="https://ariutta.github.io/svg-pan-zoom/dist/svg-pan-zoom.min.js"></script>
<!-- Not possible: "Cross-Origin Read Blocking (CORB) blocked cross-origin response with MIME type text/plain." 
See https://www.chromestatus.com/feature/5629709824032768 for more details. -->
<!-- <script type="text/javascript" src="https://raw.githubusercontent.com/ariutta/svg-pan-zoom/master/dist/svg-pan-zoom.js"></script>		-->
<!-- <script type="text/javascript" src="https://raw.githubusercontent.com/ariutta/svg-pan-zoom/master/dist/svg-pan-zoom.min.js"></script>	-->
<!-- not tested yet: Load specific version of the library -->
<!-- <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/svg-pan-zoom@3.6.0/dist/svg-pan-zoom.min.js"></script>	-->

<script type="text/javascript"> // svg-pan-zoom
"use strict";
function SvgPanZoom() { // <!-- github.com/ariutta/svg-pan-zoom -->

	const beforePan = function(oldPan, newPan) {
		msg();
		return; // Zoom-in near the border does not work well if we limt pan with fixed gutter

		// Limit pan to keep SVG content visible by not allowing panning over SVG borders.
		const gutterWidth = 100,
			  gutterHeight = 100;

		const sizes = this.getSizes();
		const leftLimit = -((sizes.viewBox.x + sizes.viewBox.width) * sizes.realZoom) + gutterWidth;
		const rightLimit = sizes.width - gutterWidth - (sizes.viewBox.x * sizes.realZoom);
		const topLimit = -((sizes.viewBox.y + sizes.viewBox.height) * sizes.realZoom) + gutterHeight;
		const bottomLimit = sizes.height - gutterHeight - (sizes.viewBox.y * sizes.realZoom);

		customPan = {};
		customPan.x = Math.max(leftLimit, Math.min(rightLimit,  newPan.x));
		customPan.y = Math.max(topLimit,  Math.min(bottomLimit, newPan.y));

		return customPan;
	};

	const onZoom = function(newZoom) {
		msg();
		showArea(this);
	};

	const onPan = function(newPan) {
		msg();
		showArea(this);
	};

	const panZoom = svgPanZoom("#svg", {
		viewportSelector: ".svg-pan-zoom_viewport" // Viewport selector. Can be querySelector string or SVGElement
		//, panEnabled: true // enable or disable panning (default enabled)
		, controlIconsEnabled: false // insert icons to give user an option in addition to mouse events to control pan/zoom (default disabled)
		// , zoomEnabled: true // enable or disable zooming (default enabled)
		// , dblClickZoomEnabled: true // enable or disable zooming by double clicking (default enabled)
		// , mouseWheelZoomEnabled: true // enable or disable zooming by mouse wheel (default enabled)
		// , preventMouseEventsDefault: true // enable or disable preventDefault for mouse events
		, zoomScaleSensitivity: 0.1 // Zoom sensitivity
		, minZoom: 0.1 // Minimum Zoom level
		, maxZoom: 5000 // Maximum Zoom level
		// , fit: true // enable or disable viewport fit in SVG (default true)
		// , contain: false // enable or disable viewport contain the svg (default false)
		// , center: true // enable or disable viewport centering in SVG (default true)
		// , refreshRate: "auto" // Maximum number of frames per second (altering SVG"s viewport)
		// , beforeZoom: function(oldZoom, newZoom){return true;}
		// , onZoom: function(ZoomScale){}
		, onZoom: onZoom
		// , beforePan: function(oldPan, newPan){return customPan} // oldPan.x, oldPan.y, newPan.x, newPan.y
		, beforePan: beforePan
		// , onPan: function(newPan){}
		, onPan: onPan
		// , customEventsHandler: { init : function(options){}, destroy : function(options){} }
		, customEventsHandler: {
			init : function(options) {
				this.listeners = {
					mouseenter: function(ev) {
						showPosition(options.instance, ev);
						showArea(options.instance, ev);
					},
					click: function(ev) {
						showArea(options.instance, ev);
						showElement(options.instance, ev);
					},
					mousemove: function(ev) {
						showPosition(options.instance, ev);
					},
					mouseleave: function(ev) {
						document.getElementById("cursorPosition").textContent = "";
					},
				};
				for (const eventName in this.listeners) {
					options.svgElement.addEventListener(eventName, this.listeners[eventName]);
				}
			},
			destroy: function(options) {
				for (const eventName in this.listeners) {
					options.svgElement.removeEventListener(eventName, this.listeners[eventName]);
				}
			}
		}
		// , eventsListenerElement: SVGElement
		// , onUpdatedCTM: function(){}
		, onUpdatedCTM: null // callback function which is triggered at the very end of pan or zoom effects
	});

	// Pan and zoom to used area
	showUsedArea(panZoom, true);

	global.timestamp.SvgPanZoom = Date.now();
	console.log('show svg:' + (global.timestamp.SvgPanZoom - global.timestamp.svgCreated) / 1000 + 'sec');	
		
	// resize SvgPanZoom after resizing the window
	window.addEventListener("resize", function(ev) {
		msg();
		ev.preventDefault();
		// Resize content
		panZoom.resize();
		//panZoom.fit();
		//panZoom.center();
		showArea(panZoom);
	});

	// arrow keys trigger page scrolling, + - trigger zooming
	// another solution to deal with multiple keys at same time: 
	// https://stackoverflow.com/questions/5203407/how-to-detect-if-multiple-keys-are-pressed-at-once-using-javascript
	window.addEventListener("keydown", function(ev) {
		//msg('Target: ' + ev.target.nodeName + ' Key: ' + ev.key);
		if (ev.target.nodeName !== "BODY" && ev.target.nodeName !== "BUTTON") { return; }
		
		// Check active keys
		if ( !( ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "+", "-"].includes(ev.key) )) {
			return;
		}

		// Zoom
		if 		  (ev.key === '+') {
			panZoom.zoomIn();
			ev.preventDefault();
			return false;
		} else if (ev.key === '-') {
			panZoom.zoomOut();
			ev.preventDefault();
			return false;
		}

		// Pan
		const sizes = panZoom.getSizes();	// width height of svg area
											// viewBox (x y width height)
											// realZoom = min(width/viewBox.width, height/viewBox.height)
		//const zoom 	= panZoom.getZoom();		// zoom factor
		if 		  (ev.key === 'ArrowUp') {
			panZoom.panBy({
				x: 0,
				y: (global.shiftDown ? +sizes.height / 2 : +5),
			});
		} else if (ev.key === 'ArrowDown') {
			panZoom.panBy({
				x: 0,
				y: (global.shiftDown ? -sizes.height / 2 : -5),
			});
		} else if (ev.key === 'ArrowLeft') {
			panZoom.panBy({
				x: (global.shiftDown ? +sizes.width  / 2 : +5),
				y: 0,
			});
		} else if (ev.key === 'ArrowRight') {
			panZoom.panBy({
				x: (global.shiftDown ? -sizes.width  / 2 : -5),
				y: 0,
			});
		} else {
			msg('nothing to do');
			return;
		}
		showArea(panZoom);
		ev.preventDefault();
		return false;
	});

	// Button swap
	document.getElementById("swap").addEventListener("click", function(ev) {
		msg();
		ev.preventDefault()
		// Toogle between flex-direction: column and flex-direction: row
		document.getElementById("main").classList.toggle("column");
		document.getElementById("main").classList.toggle("row");
		// Swapping changes the size of the svg element
		oldSizes = panZoom.getSizes();
		panZoom.resize();
		newSizes = panZoom.getSizes();
		// The top left point keeps its position. We need to pan to keep the center being centered.
		panZoom.panBy({
			x: (newSizes.width - oldSizes.width) 	/ 2 ,
			y: (newSizes.height - oldSizes.height)	/ 2 ,
		});
		showArea(panZoom);
	});

	// Button Zoom-In
	document.getElementById("zoom-in").addEventListener("click", function(ev) {
		msg();
		ev.preventDefault();
		panZoom.zoomIn();
	});
	// Button Zoom-Out
	document.getElementById("zoom-out").addEventListener("click", function(ev) {
		msg();
		ev.preventDefault();
		panZoom.zoomOut();
	});
	// Button Reset
	document.getElementById("reset").addEventListener("click", function(ev) {
		msg();
		ev.preventDefault()
		panZoom.fit();
		panZoom.center();
		panZoom.resetZoom();
		// Pan and zoom to used area
		showUsedArea(panZoom, true);
	});
	// Button ResetZoom
	document.getElementById("resetzoom").addEventListener("click", function(ev) {
		msg();
		ev.preventDefault();
		panZoom.resetZoom();
		// Zoom to used area
		showUsedArea(panZoom);
	});
	// Slider strokeWidth (in case of very large files, it might be better to use "change" event instead of "input" event to switch off live updates)
	document.getElementById("strokeWidth").addEventListener("input", function(ev) {
		msg();
		ev.preventDefault();
		changeStrokeWidth(ev.target.value);
		localStorage.setItem('strokeWidth', ev.target.value);
	});
	// Slider fontSize (in case of very large files, it might be better to use "change" event instead of "input" event to switch off live updates)
	document.getElementById("fontSize").addEventListener("input", function(ev) {
		msg();
		ev.preventDefault();
		changefontSize(ev.target.value);
		localStorage.setItem('fontSize', ev.target.value);
	});
	// Button "enable controls"
/*
	document.getElementById("enable").addEventListener("click", function() {
		msg();
		ev.preventDefault();
		panZoom.enableControlIcons();
	})
*/
	// Button "disable controls"
/*
	document.getElementById("disable").addEventListener("click", function() {
		msg();
		ev.preventDefault();
		panZoom.disableControlIcons();
	})
*/	

	// Button savePNG
	document.getElementById("savePNG").addEventListener("click", function(ev) {
		msg();
		ev.preventDefault();
		showExportWindow();		
	});
	// Button setColors
	document.getElementById("setColors").addEventListener("click", function(ev) {
		msg();
		ev.preventDefault();
		showColorPickerWindow();		
	});
	
	// Button centerItem
	document.getElementById("centerItem").addEventListener("click", function(ev) {
		msg();
		ev.preventDefault();
		centerItem();
	});

	// Listen for checkbox change events - store checkbox settings in local storage
	document.querySelector(".fieldset").addEventListener("change", function(ev) {
		const target = ev.target;
		localStorage.setItem(`checkbox_${target.name}`, target.checked);
	});

// Broadcast Channel to receive messages from EEP_Inventar.html
// https://developer.mozilla.org/en-US/docs/Web/API/Broadcast_Channel_API

// // Initialization: Connection to a broadcast channel
const EEPchannel = new BroadcastChannel('EEP');

// Event handler
EEPchannel.onmessage = function(ev) {
	const GleissystemID = '' + ev.data.GleissystemID;	// Gleis
	const GleisID		= '' + ev.data.GleisID;
	
	const ID			= ev.data.ID;				// Signal oder Weiche
	const KontaktID		= ev.data.KontaktID;		// Kontakt
	const KameraID		= ev.data.KameraID;			// Kamera
	global.shiftDown 	= ev.data.shiftDown;		// Status of keys 
	global.strgDown 	= ev.data.strgDown;
	global.altDown 		= ev.data.altDown;

	if (ID) {	// Signal oder Weiche
	
		const Meldung = global.Meldungen[Number(ID)];
		if (Meldung) {
			// Signal gefunden
			centerPosition(Meldung.mPos);
			msg(`Das Signal ${ID} befindet sich auf ${GleissystemText[Meldung.GleissystemID]} ${Meldung.GleisID}`);
			
			showSignalInfo(ID, GleissystemID, GleisID);
			return true;
		}

		const Gleis = global.Weichen[Number(ID)];
		if (Gleis) {
			// Weiche gefunden
			//const GleissystemID = Gleissystem.getAttribute("GleissystemID");
			const GleisID = Gleis.getAttribute("GleisID");
			centerPosition(Gleis.mEnd);
			msg(`Die Weiche ${ID} befindet sich auf ${GleissystemText[Gleis.GleissystemID]} ${GleisID}`);
			
			showWeicheInfo(ID, GleissystemID, GleisID);
			return true;
		}

	} else if (KontaktID) {	// Kontakt

		const Kontakt = global.Kontakte[KontaktID];
		centerPosition(Kontakt.mPos);

		showKontaktInfo(KontaktID, GleissystemID, GleisID);
		return true;

	} else if (KameraID) {	// Kamera

		const Kamera = global.KameraSet[KameraID];
		if (!Kamera) {
			msg(`Kamera ${KameraID} existiert nicht`);
			return false;
		}

		centerPosition(Kamera.mPos);

		showKameraInfo(Kamera.Name);
		return true;

	} else if (GleissystemID && GleisID) {	// Gleis

		const Gleissystem = global.Gleissysteme[GleissystemID];
		if (!Gleissystem) {
			msg(`Gleissystem ${GleissystemID} ${GleissystemText[GleissystemID]} existiert nicht`);
			return false;
		}
		const Gleis = Gleissystem[GleisID];
		if (!Gleis) {
			msg(`${GleissystemText[GleissystemID]} ${GleisID} existiert nicht`);
			return false;
		}

		centerPosition(Gleis.mMid); // Mitte des Gleises
		msg(`Positionierung auf ${GleissystemText[GleissystemID]} ${GleisID}`);

		showGleisInfo(GleissystemID, GleisID);
		return true;
	
	} else {
		console.log(ev); 
	}
};

// Disconnect the channel
//EEPchannel.close();

// End: Broadcast Channel 

	return { // public interface
		centerItem: centerItem,
		centerPosition: centerPosition,
	}

function centerItem() {
	// Get input values
	//const text 	= o.options[o.selectedIndex].text;		// e.g. Eisenbahn
	const o 	= document.getElementById("select");
	const sel 	= o.options[o.selectedIndex].value;			// e.g. 1-6, I (statt W, S), K
	const val 	= Number(document.getElementById("number").value);

	if (sel >= "1" && sel <= "6") { // Gleissystem

		const GleissystemID = Number(sel);
		const GleisID 		= val;

		const Gleissystem = global.Gleissysteme[GleissystemID];
		if (!Gleissystem) {
			msg(`Gleissystem ${GleissystemID} ${GleissystemText[GleissystemID]} existiert nicht`);
			return false;
		}
		const Gleis = Gleissystem[GleisID];
		if (!Gleis) {
			msg(`${GleissystemText[GleissystemID]} ${GleisID} existiert nicht`);
			return false;
		}

		centerPosition(Gleis.mMid); // Mitte des Gleises
		msg(`Positionierung auf ${GleissystemText[GleissystemID]} ${GleisID}`);
		return true;

	} else if (sel === "I" || sel === 'S' || sel === 'W') {		// I = Signal/Weiche (Nummern übergreifend über alle Gleissysteme)
		// Gleis.getAttribute("Key_Id") bzw. Gleis.getAttribute("Meldung").getAttribute("Key_Id")
		const ID 		= val;

		const Meldung = global.Meldungen[Number(ID)];
		if (Meldung) {
			// Signal gefunden
			centerPosition(Meldung.mPos);
			msg(`Das Signal ${ID} befindet sich auf ${GleissystemText[Meldung.GleissystemID]} ${Meldung.GleisID}`);
			return true;
		}

		const Gleis = global.Weichen[Number(ID)];
		if (Gleis) {
			// Weiche gefunden
			//const GleissystemID = Gleissystem.getAttribute("GleissystemID");
			const GleisID = Gleis.getAttribute("GleisID");
			centerPosition(Gleis.mEnd);
			msg(`Die Weiche ${ID} befindet sich auf ${GleissystemText[Gleis.GleissystemID]} ${GleisID}`);
			return true;
		}

		msg(`Signal/Weiche ${ID} existiert nicht`);
		return false; // Signal/Weiche nicht gefunden

	} else if (sel === "K") {		// Kontakt
		//...
	}
	return false;
}

function centerPosition(Position) {
	const width 	= panZoom.getSizes().width;
	const height	= panZoom.getSizes().height;
	const realZoom	= panZoom.getSizes().realZoom;

	const posX = 12, posY = 13, posZ = 14;
	const panX 		= width/2	- Position[posX] * realZoom;
	const panY 		= height/2	- (Position[posY]) * realZoom;

	panZoom.pan({x: panX, y: panY});
}

}

// Handle special keys
global.shiftDown 	= false;
global.strgDown 	= false;
global.altDown 		= false;
// Clear key status when window gets focus (mainly to omit Alt key)
window.addEventListener("focus", function(event) { 
	global.shiftDown 	= false;
	global.strgDown 	= false;
	global.altDown 		= false;
});
//window.addEventListener("blur", function(event) {});
// Activate key
document.addEventListener('keydown', function(event){
    if			(event.keyCode === 16 || event.charCode === 16){
        global.shiftDown = true;
    } else if	(event.keyCode === 17 || event.charCode === 17){
        global.strgDown = true;
    } else if	(event.keyCode === 18 || event.charCode === 18){
        global.altDown = true;
    }
});
// Deactivate key
document.addEventListener('keyup', function(event){
    if			(event.keyCode === 16 || event.charCode === 16){
        global.shiftDown = false;
    } else if	(event.keyCode === 17 || event.charCode === 17){
        global.strgDown = false;
    } else if	(event.keyCode === 18 || event.charCode === 18){
        global.altDown = false;
    }
});

// Show cursor position
function showPosition(t, event) {
	const pan 	= t.getPan();	// (x y)
	const sizes = t.getSizes();	// width height of svg area
								// viewBox (x y width height)
								// realZoom = min(width/viewBox.width, height/viewBox.height)
	//const zoom 	= t.getZoom();	// zoom factor

	const posX	= ( event.offsetX - pan.x) / sizes.realZoom;
	const posY	= ( event.offsetY - pan.y) / sizes.realZoom;

	/* Show cursor position */
	const text = "(" + (posX).toFixed(0) + " " + (-posY).toFixed(0) + ")";
	document.getElementById("cursorPosition").textContent = text;
}

// Show coordinates of visible area
function showArea(t, event) {
	const pan 		= t.getPan();	// (x y)
	const sizes 	= t.getSizes();	// width height of svg area
								// viewBox (x y width height)
								// realZoom = min(width/viewBox.width, height/viewBox.height)
	//const zoom 		= t.getZoom();	// zoom factor

	const minX		= (-pan.x) / sizes.realZoom;
	const minY		= (-pan.y) / sizes.realZoom;
	const centerX	= (-pan.x + sizes.width/2)  / sizes.realZoom;
	const centerY	= (-pan.y + sizes.height/2)	/ sizes.realZoom;
	const maxX		= (-pan.x + sizes.width)  	/ sizes.realZoom;
	const maxY		= (-pan.y + sizes.height) 	/ sizes.realZoom;

	/* Show coordinates of visible area */
	let text = "("  + (minX).toFixed(0) + " " + (-minY).toFixed(0) + ") .. ("
					+ (maxX).toFixed(0) + " " + (-maxY).toFixed(0) + ")";
	document.getElementById("visibleArea").textContent = text;
	/* Show center position */
	text = "(" + (centerX).toFixed(0) + " " + (-centerY).toFixed(0) + ")";
	document.getElementById("centerPosition").textContent = text;
}

// Show element
function showElement(t, event) {
	if (!event || event.target.id === "svg") { return; }
/*
console.log("");

console.log(
"target|" +
event.target.tagName + ":" +
event.target.id + ":" +
event.target.classList[0]
)
if (event.target.parentElement) {
console.log(
"target.parentElement|" +
event.target.parentElement.tagName + ":" +
event.target.parentElement.id  + ":" +
event.target.parentElement.classList[0]
)
if (event.target.parentElement.parentElement) {
	console.log(
	"target.parentElement.parentElement|" +
	event.target.parentElement.parentElement.tagName + ":" +
	event.target.parentElement.parentElement.id  + ":" +
	event.target.parentElement.parentElement.classList[0]
	)
}
}
if (event.rangeParent) {
console.log(
"rangeParent|" +
event.rangeParent.tagName + ":" +
event.rangeParent.id  + ":" +
event.rangeParent.classList[0]
)
if (event.rangeParent.parentElement) {
	console.log(
	"rangeParent.parentElement|" +
	event.rangeParent.parentElement.tagName + ":" +
	event.rangeParent.parentElement.id  + ":" +
	event.rangeParent.parentElement.classList[0]
	)
}
}
*/
/*
Track
target						|path::stil-1353
target.parentElement		|g:G1-3:Weiche
rangeParent					|g:G1-3:Weiche
rangeParent.parentElement	|g:Eisenbahn:undefined

Track text
target						|text::undefined
target.parentElement		|g:G1-51:Normal
rangeParent					|text::undefined
rangeParent.parentElement	|g:G1-51:Normal

Track stil
target|text::Stil
target.parentElement		|g:G1-51:Normal
rangeParent					|text::Stil
rangeParent.parentElement	|g:G1-51:Normal

Track Hoehe
target|text::Hoehe
target.parentElement		|g:G1-51:Normal
rangeParent					|text::Hoehe
rangeParent.parentElement	|g:G1-51:Normal

Weiche text
target						|text:W2:WeicheText
target.parentElement		|g:G1-17:Weiche
rangeParent					|text:W2:WeicheText
rangeParent.parentElement	|g:G1-17:Weiche

Signal text
target						|text::Signal
target.parentElement		|g:S39:Signal
target.parentElement.parentElement|g:G1-47:Normal
rangeParent					|text::Signal
rangeParent.parentElement	|g:S39:Signal

Signal symbol
target						|use::undefined
target.parentElement		|g:S39:Signal
target.parentElement.parentElement|g:G1-47:Normal
rangeParent					|symbol:SymbolSignal:undefined

Signal circle
target						|circle::undefined
target.parentElement		|g:S39:Signal
rangeParent					|g:S39:Signal
rangeParent.parentElement	|g:G1-47:Normal

Kontakt symbol
target						|use::undefined
target.parentElement		|g:K1:Kontakt
target.parentElement.parentElement|g:G1-47:Normal

Kontakt circle
target						|circle::undefined
target.parentElement		|g:G1-47:Normal
rangeParent					|g:G1-47:Normal
rangeParent.parentElement	|g:Eisenbahn:undefined
*/

	if (event.target.parentElement.classList[0] === "Signal") {			// Signal
		const SignalCode 		= event.target.parentElement.id;
		const SignalID 			= Number(SignalCode.substring(1));

		const GleisCode 		= event.target.parentElement.parentElement.id;
		const GleisTextArray 	= GleisCode.substring(1).split("-");
		const GleissystemID 	= GleisTextArray[0];
		const GleisID 			= GleisTextArray[1];

		showSignalInfo(SignalID, GleissystemID, GleisID);
		
	} else if (event.target.parentElement.classList[0] === "Kontakt") {	// Kontakt
		const KontaktCode		= event.target.parentElement.id;
		const KontaktID 		= KontaktCode.substring(1);

		const GleisCode 		= event.target.parentElement.parentElement.id;
		const GleisTextArray 	= GleisCode.substring(1).split("-");
		const GleissystemID 	= GleisTextArray[0];
		const GleisID 			= GleisTextArray[1];
	
		showKontaktInfo(KontaktID, GleissystemID, GleisID);
		
	} else if (event.target.classList[0] === "WeicheText") { 			// Weiche
		const WeicheCode 		= event.target.id;
		const WeicheID 			= WeicheCode.substring(1)

		const GleisCode 		= event.target.parentElement.id;
		const GleisTextArray 	= GleisCode.substring(1).split("-");
		const GleissystemID 	= GleisTextArray[0];
		const GleisID 			= GleisTextArray[1];

		showWeicheInfo(WeicheID, GleissystemID, GleisID);

	} else if (event.target.parentElement.parentElement.id === 'Kamera') {	// Kamera
		const Name 				= event.target.parentElement.id;

		showKameraInfo(Name);
	
	} else if (event.target.parentElement.id !== "general") {			// Gleis (hopefully)
		const GleisCode 		= event.target.parentElement.id;
		const GleisTextArray 	= GleisCode.substring(1).split("-");
		const GleissystemID 	= GleisTextArray[0];
		const GleisID 			= GleisTextArray[1];

		showGleisInfo(GleissystemID, GleisID);
	}
}

function showUsedArea(panZoom, pan) {
	// Pan and zoom to used area
	// zoomAtPoint(scale, {x:0,y:0});   or   pan({x:0,y:0}); zoom(scale);
	const width 		= panZoom.getSizes().width;
	const height		= panZoom.getSizes().height;
	const usedwidth 	= global.usedArea.max.x - global.usedArea.min.x;
	const usedheight	= global.usedArea.max.y - global.usedArea.min.y;
	const realZoom		= panZoom.getSizes().realZoom;

	const panX 			= width/2  - ( global.usedArea.min.x + usedwidth/2  ) * realZoom;
	const panY 			= height/2 - ( global.usedArea.min.y + usedheight/2 ) * realZoom;
	const scale 		= Math.min( width  / usedwidth,
									height / usedheight ) / realZoom;

	if (pan) {
		panZoom.pan({x: panX, y: panY});
	}
	panZoom.zoom(scale);
}
</script>

<script type="text/javascript"> // Main screen
"use strict";
// Toggle visibility of elements
function toggleElements(selector, visible) {
	msg();
	
	// Instead of modifying all elements we could modify CSS rules as well, but it seems that this does not improve performance very much
	for (const ele of document.getElementById("svg").querySelectorAll(selector)) {
		if (visible) {
			ele.classList.remove("hidden");
		} else {
			ele.classList.add("hidden");
		}
	}
}

// Toggle visibility of marker
function toggleMarker(visible) {
	msg();
	// Modify svg css (nice, but only works in the browser, not during PNG export)
	/*
	const cssVariables = document.getElementById("css-marker-colors").sheet.rules[0].style;
	["Eisenbahn", "Strassenbahn", "Strasse", "Wasserwege", "Steuerstrecken", "GBS"].forEach(function(name) {
		if (visible) {
			cssVariables.setProperty(`--${name}-marker-color`, `var(--${name}-color)`);
		} else {
			cssVariables.setProperty(`--${name}-marker-color`, `none`);
		}
	});
	*/
	
	// Modify svg css to use same setting during PNG export
	if (visible) {
		document.getElementById("css-marker-colors").textContent =
			`svg {
				--Eisenbahn-marker-color: var(--Eisenbahn-color);
				--Strassenbahn-marker-color: var(--Strassenbahn-color);
				--Strasse-marker-color: var(--Strasse-color);
				--Wasserwege-marker-color: var(--Wasserwege-color);
				--Steuerstrecken-marker-color: var(--Steuerstrecken-color);
				--GBS-marker-color: var(--GBS-color);
				--Kamera-marker-color: var(--Kamera-color);
			}`;
	} else {
		document.getElementById("css-marker-colors").textContent =
			`svg {
				--Eisenbahn-marker-color: none;
				--Strassenbahn-marker-color: none;
				--Strasse-marker-color: none;
				--Wasserwege-marker-color: none;
				--Steuerstrecken-marker-color: none;
				--GBS-marker-color: none;
				--Kamera-marker-color: none;
			}`;
	}	
}

function msg(text) {
	if (text) {
		document.getElementById("message").textContent = text; // Text only therefore we do not need to use innerHTML
	} else {
		document.getElementById("message").textContent = "";
	}
}

function changeStrokeWidth(value) {
	// Use exponential function to convert the slider value into range [0.11 .. 2.12] with f(75) = 1
	// f = 0.1054 * exp(0.03 * v)
	const factor = 0.1054 * Math.exp(0.03 * value);

	// Modify svg css (nice, but only works in the browser, not during PNG export)
	/*
	const cssVariables = document.getElementById("css-strokeWidth-variables").sheet.rules[0].style;
	cssVariables.setProperty("--normal-stroke-width", `${0.5 * factor}px`);
	cssVariables.setProperty("--narrow-stroke-width", `${0.25 * factor}px`);
	*/
	
	// Modify svg css to use same setting during PNG export
	document.getElementById("css-strokeWidth-variables").textContent =
		`svg {
			--normal-stroke-width: ${0.5 * factor}px;
			--narrow-stroke-width: ${0.25 * factor}px;
		}`	
}

function changefontSize(value) {
	// Use exponential function to convert the slider value into range [0.11 .. 2.12] with f(75) = 1
	// f = 0.1054 * exp(0.03 * v)
	const factor = 0.1054 * Math.exp(0.03 * value);

	// Modify svg css (nice, but only works in the browser, not during PNG export)
	// (we maybe could use calc(3 * var(--font-size-factor, 1) * 1px) as well to avoid the constants here)
	/*
	const cssVariables = document.getElementById("css-fontSize-variables").sheet.rules[0].style;
	cssVariables.setProperty("--normal-font-size", `${3 * factor}px`);
	*/
	
	// Modify svg css to use same setting during PNG export
	document.getElementById("css-fontSize-variables").textContent =
		`svg {
			--normal-font-size: ${4 * factor}px;
		}`;
}

function changeHeightRange(valueLow, valueHigh) {
	// skip call during initialization
	if (!global.usedArea) {
		return;
	}

	// localStorage.setItem('heightRange', valueLow + ','+ valueHigh);

	// Show min/max height
	const delta = ( global.usedArea.max.z - global.usedArea.min.z) / 100; // valueLow, valueHigh run from 0 to 100
	const minZ = global.usedArea.min.z + delta * valueLow;
	const maxZ = global.usedArea.min.z + delta * valueHigh;
	document.getElementById("heightArea").textContent = minZ.toFixed(1) + " .. " + maxZ.toFixed(1);
	
	// Adjust svg group elements
	const svgElem = document.getElementById("svg");
	for (const groupElem of svgElem.getElementsByTagName("g")) {
		for (const className of groupElem.classList){
			if (className.substring(0,7) == "height=") {  // Example: "height=123"
				const height = +className.substring(7);
				if (height < minZ || height > maxZ) {
					groupElem.classList.add("hiddenZ");
				} else {
					groupElem.classList.remove("hiddenZ");
				}
			}
		}
	}
}
</script>

<link rel="stylesheet" href="toolwindow/toolwindow.css"/>
<!-- Not possible, see same issue above -->
<!-- <link rel="stylesheet" href="https://raw.githubusercontent.com/fluffynuts/toolwindow/master/dist/toolwindow.css"/> -->
<script type="text/javascript" src="toolwindow/toolwindow.js"></script>
<!-- Not possible, see same issue above -->
<!-- <script type="text/javascript" src="https://raw.githubusercontent.com/fluffynuts/toolwindow/master/dist/toolwindow.js"></script> -->
<!-- <script type="text/javascript" src="https://raw.githubusercontent.com/fluffynuts/toolwindow/master/dist/toolwindow.min.js"></script> -->

<aside id="infoPopup"> <!-- Info Window -->
<script type="text/javascript" src="EEP_Signale_Daten.js"></script> <!-- Lade Zusatzdaten zu Signalen: Name, Signalstellungen -->
<script type="text/javascript">  // Show information in Info Box
"use strict";
function objectToHTML(object) {
	let s = '';
	
	if (global.altDown) {							// only if alt-key is pressed
		s = object.outerHTML;						// get HTML representation of object
		s = s.replace(/</g,"&lt;");					// escapeing of < is required
		s = s.replace(/>(?![a-zA-Z0-9])/g,"&gt;<br>");	// escapeing of > is optional but allows adding line breaks (unless followed by Pos, Dir, Nor or Bin)
		s = s.replace(/\t/g," ");					// replace tabs
		s = s.replace(/\s{2,}/g, ' ');				// replace duplicate spaces
		s = s.replace(/(\r\n|\n|\r)/g,"");			// remove line breaks
		s = '<br><br><code>' + s + '</code>';		// <br> at the end allows easy copy & paste
	}

	return s;
}

function showGleisInfo(GleissystemID, GleisID) {
	const Gleissystem = global.Gleissysteme[GleissystemID];
	if (!Gleissystem){ return; }
	
	const Gleis 	= Gleissystem[GleisID];
	if (!Gleis){ return; }

	const clsid 	= Gleis.getAttribute("clsid");		// Gleisart
	const stil 		= Gleis.getAttribute("stil");		// Gleisstil
	const gsbname 	= Gleis.getAttribute("gsbname");	// Dateiname

	const Key_Id	= Gleis.getAttribute("Key_Id"); 	// Id einer Weiche
	const GleisData	= Gleis.getAttribute("data"); 		// Bitfeld einer Weiche
														// 1: Oberleitung
														// 18: DKW (Weichen und zentrale Gleise)
														// 16: Zentrale Strecken einer Straßen-T-Kreuzung
														// 20: Weichen einer Straßen-T-Kreuzung

	let GleisobjektText = '';
	let KollektorID;
	if (global.KollektorTracks[GleissystemID]) {
		if (global.KollektorTracks[GleissystemID][GleisID]) {
			KollektorID = global.KollektorTracks[GleissystemID][GleisID].KollektorID;
		}
	}
	if (KollektorID) {
		const Gleisobjekt = global.Gleisobjekte[KollektorID];
		
		GleisobjektText = '<br>Gleisobjekt: ' + Gleisobjekt.gsbname
			+ '<br>Immobilie: ' + GebaeudesammlungText[Gleisobjekt.GebaudesammlungID] + ' ' + Gleisobjekt.ImmoIdx
	}

	// Kurzform in msg-Element
	msg(`${GleissystemText[GleissystemID]} ${GleisID}, ${Gleisart[clsid]}, Stil ${stil}, ${gsbname}`);

	// Ausführlich im Info Popup
	const posX = 12, posY = 13, posZ = 14;
	
	// Show connected tracks
	let connectionText = '';
	const connections = global.trackConnections[GleissystemID][GleisID] || {};
	for (const connection in connections) {
		const connectedGleisID = connections[connection].GleisID;
		const connectedGleis = Gleissystem[connectedGleisID];
		connectionText += '<br>' + connection
			+': ' 
			+ `<a href="javascript:void(0);" onclick="javascript:global.SvgPanZoom.centerPosition([${connectedGleis.mMid}])">${connectedGleisID}<\/a>`
			+ ' ' + ( connections[connection].Flags ? 'virtuell' : '' )
	}
	
	const _i = "</i>", _a = "</a>";
	showInfoWindow({
		code: 'G' + GleissystemID + '-' + GleisID,
		title: `${GleissystemText[GleissystemID]} ${GleisID}`,
		content: 
			`Position Anfang: (<a href="javascript:void(0);" onclick="javascript:global.SvgPanZoom.centerPosition([${Gleis.mPos}])">${Gleis.mPos[posX].toFixed(0)}m, ${-Gleis.mPos[posY].toFixed(0)}m<\/a>)`
			+ `<br>Mitte: (<a href="javascript:void(0);" onclick="javascript:global.SvgPanZoom.centerPosition([${Gleis.mMid}])">${Gleis.mMid[posX].toFixed(0)}m, ${-Gleis.mMid[posY].toFixed(0)}m<\/a>)`
			+ `<br>Ende: (<a href="javascript:void(0);" onclick="javascript:global.SvgPanZoom.centerPosition([${Gleis.mEnd}])">${Gleis.mEnd[posX].toFixed(0)}m, ${-Gleis.mEnd[posY].toFixed(0)}m<\/a>)`
			+ `<br>Typ: ${Gleisart[clsid]}` + (Key_Id != null ? " " + Key_Id : "" )
			+ (GleisData != 0 ? `<br>${GleisDataText[GleisData]}` : '')
			+ `<br>Stil: ${stil}`
			+ (gsbname != null ? `<br>Datei: ${gsbname}` : "")
			+ GleisobjektText
			+ `<br>Länge: ${Gleis.Laenge.toFixed(0)}m`
			+ `<br>Höhe: ${Gleis.mPos[posZ].toFixed(2)}m`
			+ (Gleis.CurveType == 'classic' || Gleis.CurveType == 'EEPCurve' ? '' : `<br>Gleisart: ${Gleis.CurveType}`)
			+ connectionText
			+ objectToHTML(Gleis)
	});
}

function showWeicheInfo(WeicheID, GleissystemID, GleisID) {
	const Gleissystem = global.Gleissysteme[GleissystemID];
	if (!Gleissystem){ return; }

	const Gleis 	= Gleissystem[GleisID];
	if (!Gleis){ return; }

	const clsid 	= Gleis.getAttribute("clsid");		// Gleisart
	const stil 		= Gleis.getAttribute("stil");		// Gleisstil
	const gsbname 	= Gleis.getAttribute("gsbname");	// Dateiname

	const KontaktZiel 	= Gleis.getElementsByTagName('KontaktZiel')[0].textContent;
	const weichenstellung = Gleis.getAttribute('weichenstellung');
	const GleisData	= Gleis.getAttribute("data"); 		// Bitfeld einer Weiche
														// 1: Oberleitung
														// 18: DKW (Weichen und zentrale Gleise)
														// 16: Zentrale Strecken einer Straßen-T-Kreuzung
														// 20: Weichen einer Straßen-T-Kreuzung

	// Kurzform in msg-Element
	msg(`Weiche ${WeicheID} auf ${GleissystemText[GleissystemID]} ${GleisID}`);
	
	// Show connected tracks
	let connectionText = '';
	const connections = global.trackConnections[GleissystemID][GleisID] || {};
	for (const connection in connections) {
		if (connection != 'Anfang') {
			const connectedGleisID = connections[connection].GleisID;
			const connectedGleis = Gleissystem[connectedGleisID];
			connectionText += '<br>' + connection
				+': ' 
				+ `<a href="javascript:void(0);" onclick="javascript:global.SvgPanZoom.centerPosition([${connectedGleis.mMid}])">${connectedGleisID}<\/a>`
				+ ' ' + ( connections[connection].Flags ? 'virtuell' : '' )
		}
	}

	// Ausführlich im Info Popup
	showInfoWindow({
		code: 'W' + WeicheID,
		title: `Weiche ${WeicheID}`,
		content: 
			`<i>Position: `
				+ `<a href="javascript:void(0);" onclick="javascript:global.SvgPanZoom.centerPosition([${Gleis.mEnd}]);">${GleissystemText[GleissystemID]} ${GleisID}<\/a>`
				+ `<\/i>`
			+ `<br>Gleisart: ${Gleisart[clsid]}`
			+ (GleisData   != 0 ? `<br>` + GleisDataText[GleisData] : '')
			+ `<br>Weichenstellung: ${WeichenstellungText[weichenstellung]}`
			+ `<br>Stil: ${stil}`
			+ (gsbname != null ? `<br>Datei: ${gsbname}` : "")
			+ (KontaktZiel != null && KontaktZiel != 0 ? `<br>KontaktZiel: ${KontaktZiel}` : '')
			+ connectionText
			+ objectToHTML(Gleis)
		});
}

function showSignalInfo(SignalID, GleissystemID, GleisID) {
	const Meldung 		= global.Meldungen[SignalID];
	if (!Meldung) { return; }
	
	const File 			= Meldung.getAttribute("name");		// Dateiname
	const Position		= Meldung.getAttribute('Position') / 100;
	const ParaOderAnti 	= Meldung.getAttribute('ParaOderAnti');

	const KontaktZiel 	= Meldung.getElementsByTagName("KontaktZiel")[0].textContent;

	const Stellung		= Meldung.getElementsByTagName("Signal")[0].getAttribute("stellung");
	const SignalData	= Meldung.getElementsByTagName('Signal')[0].getAttribute('SignalData');
 	const Distanz		= Meldung.getElementsByTagName('Signal')[0].getAttribute('wirkungsdistanz') / 100;

	// Fahrstraßen
	const Routes		= Meldung.getAttribute('Routes');
	const RouteList	 	= Meldung.getElementsByTagName("Route");

	const SignalType 	= (File === 'system\\Route_SignalS.3ds' ? 'Fahrstraße Startsignal' 
							: (File === 'system\\Route_SignalZ.3ds' ? 'Fahrstraße Endesignal'
								: 'Signal' ));
	
	let SignalstellungText = "";
	// Die Bedeutung der Signalstellung für Fahrstraßen ist noch unklar
	if (SignalType === 'Signal') {
		if (Signalstellung[File]) {
			// 1st try: Get texts (case sensitive file name)
			SignalstellungText = Signalstellung[File].Pos[Stellung];
		} else {
			// 2nd try: Get texts (case insensitive file name)
			for (const SignalFile in Signalstellung) {
console.log('SignalFile.toLowerCase() == File.toLowerCase()' + ' : ' + typeof(SignalFile.toLowerCase()) + ' == ' + typeof(File.toLowerCase()));
				if (SignalFile.toLowerCase() == File.toLowerCase()) {
					SignalstellungText = Signalstellung[SignalFile].Pos[Stellung];
				}
			}
		}
	}
	
	// Kurzform in msg-Element
	msg(`${SignalType} ${SignalID} ${File} auf ${GleissystemText[GleissystemID]} ${GleisID}` 
		+ `, Stellung ${Stellung} ${SignalstellungText}` 
		+ (KontaktZiel != null && KontaktZiel != 0 ? `, Kontaktziel=` + KontaktZiel : ""));

	// Ausführlich im Info Popup

	// Fahrstraßen
	const ColorText = { // <color> modulo 8
		0: { name: 'grau',		color: 'rgb(180,180,180)', 	},
		1: { name: 'rot',		color: 'rgb(220,0,0)', 		},
		2: { name: 'grün',		color: 'rgb(0,220,0)', 		},
		3: { name: 'blau',		color: 'rgb(0,0,220)', 		},
		4: { name: 'gelb',		color: 'rgb(220,220,0)', 	},
		5: { name: 'pink',		color: 'rgb(220,0,220)', 	},
		6: { name: 'hellblau', 	color: 'rgb(0,180,220)', 	},
		7: { name: 'orange',	color: 'rgb(220,110,0)',	},
	}
	let RoutesText = '';
	for (const Route of RouteList) {
		const Target 	= Route.getAttribute('Target');
		const Color 	= Route.getAttribute('Color');
		
		RoutesText += `<br>Zielsignal: ${Target}, <span style="color:${ColorText[Color%8].color};">Farbe: ${Color} ${ColorText[Color%8].name}`+'</span>';
	}

	showInfoWindow({
		code: 'S' + SignalID,
		title: `${SignalType} ${SignalID}`,
		content:
			`<i>Position: `
				+ `<a href="javascript:void(0);" onclick="javascript:global.SvgPanZoom.centerPosition([${Meldung.mPos}]);">${GleissystemText[GleissystemID]} ${GleisID}`
				+ ` +${Position.toFixed(1)}m<\/a><\/i>`
			+ `<br>Name: ${File}`
			+ (Signalstellung[File] && File !== Signalstellung[File].Name ? `<br>${Signalstellung[File].Name}` : "")
			+ `<br>Stellung ${Stellung}: ${SignalstellungText}`
			+ (Distanz !=0 ? `<br>Distanz zum Hauptsignal: ${Distanz.toFixed(0)}m` : '')
			+ `<br>Gleisrichtung: ${ParaOderAnti} ` + (ParaOderAnti == 1 ? 'in Gleisrichtung' : 'gegen Gleisrichtung')
			+ (SignalData != null ? `<br>SignalData: ${SignalData}` : '')			
			+ (KontaktZiel != null && KontaktZiel != 0 ? `<br>Kontaktziel: ${KontaktZiel}` : "")
			+ (Routes ? `<br>Fahrstraßen: ${Routes}` : "")
			+ (RoutesText !== '' ? RoutesText : '')
			+ objectToHTML(Meldung)
		});
}

function getKontaktIcon(GleissystemID, SetType, SetValue) {
	// https://www.compart.com/de/unicode/category/So
	const KontaktIcon = { 	// Sometimes the symbol works fine but sometime the unicode-code is neccessary in Notepad++
		0 		: '⭢', 		// Weiche/Signal			⭢ \u2B62 → \u8594 &rarr; 
		1 		: '🚆', 	// Fahrzeug +v km/h max		🚆 \u1F686 🚗 \u1f697 ⛴ \u26f4 ⛟ \u26DF 	
		2 		: '🚆', 	// Fahrzeug +v km/h min
		3 		: '🚆', 	// Fahrzeug +v km/h soll
		//4		: '',		// not used 
		5 		: '🚆', 	// Fahrzeug -v km/h max
		6 		: '🚆', 	// Fahrzeug -v km/h min
		7 		: '🚆', 	// Fahrzeug -v km/h soll
		8 		: '🛑', 	// Halt nach x m			🛑 \u1f6d1
		// 17, 33, 34 unbekannt
		128 	: '🧍', 		// Omegas					🧍 \u1F9CD						
		256 	: '\u266C', // Sound					🔊 \u1F50A ♫ \u266B ♬ \u266C 	 	
		512 	: '📷', 	// Kamera 					📷 \u1F4F7
		768 	: '🏠', 	// Immobilie				🏠 \u1F3E0	
		1024 	: '\u2387', // DKW/EKW					💢 ⎇ \u2387
		1280 	: '\u21E5', // Einfahrt Depot			⇥ \u21E5 ⍖ \u2356 ⭢
		1536 	: '\u21A6', // Ausfahrt Depot			↦ \u21A6 ⍏ \u234F ⭢
		2048 	: '\u2398', // Animationen				⮔ 2B94 ⎘ \u2398 ↬ \u21AC ↝ \u219D
		32768	: '\u2042',	// Gruppe					⁂ \u2042 ⭢	
							// 							⌂ \u2302 ⌥ \u2325   → = &rarr; = \u8594;   ⭢ = \u2B62		
	}

	let Icon = (KontaktIcon[SetType] ? KontaktIcon[SetType] : '');

	// spezielle Kontakte
	if (SetType >= 1 && SetType <= 7) {				// Fahrzeug je nach Gleissystem
		// Eisenbahn:	🚂🚃🚄🚅🚆🚇🚈🚉🚊🚝🚞
		// Straßenbahn:	🚎🚟🚠🚡
		// Straße:		🚌🚍🚐🚑🚒🚓🚔🚕🚖🚗🚘🚙🚚🚛🚜🚲🚴🚵⛟
		// Wasserwege:	⛴🚢🚣🚤⛵🚀🚁✈
		// Immobilien:	🏠🏡🏢🏣🏤🏥🏦🏧🏨🏩🏪🏫🏬🏭🏮🏯🏰
		Icon = { 1: '🚂', 2: '🚎', 3: '🚗', 4: '⛴', 5: '🚕', 6: ''}[GleissystemID];

	} else if (SetType == 256 && SetValue && global.Sounds[SetValue]) { // Sound vorhanden
			Icon = '🔊';
	}

	return Icon;
}

function getKontaktText(GleissystemID, SetType, SetValue, VolDist, ConnectF) {
	// Achtung: die Variablen v, x, t werden ersetzt
	const KontaktText = {
		0 		: 'Weiche/Signal',
		1 		: 'Fahrzeug +v km/h max',	
		2 		: 'Fahrzeug +v km/h min',
		3 		: 'Fahrzeug +v km/h soll',
		//4		: '',							// not used 
		5 		: 'Fahrzeug -v km/h max',
		6 		: 'Fahrzeug -v km/h min',
		7 		: 'Fahrzeug -v km/h soll',
		8 		: 'Halt x m',
		// 17, 33, 34 unbekannt
		128 	: 'Omegas',						
		256 	: 'Sound',	 	
		512 	: 'Kamera',
		768 	: 'Immobilie',
		1024 	: 'DKW/EKW',
		1280 	: 'Einfahrt Depot',
		1536 	: 'Ausfahrt Depot',
		2048 	: 'Animationen',
		32768 	: 'Gruppen KP',
	}

	let Text 	= (KontaktText[SetType] ? KontaktText[SetType] : 'unbekannt');

	// Spezielle Kontakt-Typen
	if 		  (SetType == 0) {	// Weiche/Signal
		//if      (Weichen.find(function(Weiche) { return Weiche.ID == KontaktZiel}) ) 	{ KontaktTypText = 'Weiche'; } 
		//else if (Signale.find(function(Signal) { return Signal.ID == KontaktZiel}) ) 	{ KontaktTypText = 'Signal'; }
		//else 																			{ KontaktTypText = 'Kontaktziel nicht gefunden'; }

	} else if (SetType >= 1 && SetType <= 7) {	// Fahrzeug
		Text = Text.replace('v', SetValue);		// 'Fahrzeug +v km/h max'
		
	} else if (SetType == 8) {
		Text = Text.replace('x', SetValue);		// 'Halt x m'
		
	} else if (SetType == 256 && SetValue && global.Sounds[SetValue]) {	// Sound vorhanden
			Text 	= global.Sounds[SetValue];
		
	} else if (SetType == 512) {	// Kamera
		/* ConnectF: 4 Byte Ganzzahl
			Byte 1 (LSB):	KameraID Start
			Byte 2:			Perspektive Start
			Byte 3:			KameraID Ende
			Byte 4:			Perspektive Ende
			*/	
			const Perspektive = {		
				0 : 'keine Perspektive festgelegt', 
				1 : 'Fahrzeug von links',
				2 : 'Fahrzeug von rechts',
				3 : 'Fahrzeug von links oben',
				4 : 'Fahrzeug von rechts oben',
				5 : 'Sicht in Fahrtrichtung',
				6 : 'Rückwärtige Sicht',
				7 : 'Folgemodus',
				8 : 'Sicht in Kabine',
			}
			
		// convert 32bit int to array of 4 bytes
		function convertIntToBytes( x ) {
			const bytes = [0, 0, 0, 0,];
			let i = 4;
			do {
				bytes[--i] = x & (255);
				x = x>>8;
			} while ( i && x > 0 )
			return bytes;
		}

		if (ConnectF) {
			const [EndePerspektive, EndeKameraID, StartPerspektive, StartKameraID] = convertIntToBytes( ConnectF );
			const StartKamera = global.KameraSet[StartKameraID];
			const EndeKamera = global.KameraSet[EndeKameraID];

console.log('Kamera'
	+ ' StartKameraID=' + StartKameraID
	+ ' StartPerspektive=' + StartPerspektive
	+ ' EndeKameraID=' + EndeKameraID
	+ ' EndePerspektive=' + EndePerspektive
)
	
			Text = ''		// <Kamera Icon> <Start Kamera> [<Perspektive>] / <Ende Kamera> nach <t> Sek. [<Perspektive>]
				+ (StartKamera	
					? `<a href="javascript:void(0);" onclick="javascript:global.SvgPanZoom.centerPosition([${StartKamera.mPos}])">${StartKamera.Name}<\/a>`		
					: '' )
				+ (StartPerspektive > 0 
					? ` [${Perspektive[StartPerspektive]}]`	
					: '' )
				+ (EndeKamera
					? ` / <a href="javascript:void(0);" onclick="javascript:global.SvgPanZoom.centerPosition([${EndeKamera.mPos}])">${EndeKamera.Name}<\/a> nach ${SetValue} Sek.`			
					: '' )
				+ (EndePerspektive > 0 	
					? ` [${Perspektive[EndePerspektive]}]` 	
					: '' );	
		} else {
			Text = 'Kamera';
		}
		
	} else if (SetType == 1024) {	// DKW/EKW Weichenstellung
		const VolDistText = {
			0 : 'Umschalter',
			1 : 'links-links',
			2 : 'links-rechts',
			3 : 'rechts-rechts',
			4 : 'rechts-links',
		}
		
		Text += ' ' + VolDistText[VolDist];
		
	}

	return Text;
}

function showKontaktInfo(KontaktID, GleissystemID, GleisID) {
//<Kontakt Position="2186.82" ParaOderAnti="0" fireOnPara="1" fireOnAnti="0" Teiler="1" ActTeiler="0" TrainSide="0" Route="0" Route2="0" SetType="0" SetValue="0" Delay="0" ActDelay="0" TrainID="0" TrainID2="0" Light="2" LastTrainID="6" LastOfs="2213.881" ConnectF="2" ConnectR="2" VolDist="28" zuStellung="1" Wartender="0" AxisPos="0" AxisFilter="" NameFilter="" TrainNewName="" KontaktDist="0" TrainDist="0" LuaFn="" Group="0" SignalData="0" KontaktZiel="1" Wechseln="0" clsid="5E9A3049-D465-4602-A285-6A9774DCF1BF"/>
	const Kontakt		= global.Kontakte[KontaktID];
	const SetType 		= Kontakt.getAttribute('SetType');
	const SetValue 		= Kontakt.getAttribute('SetValue');
	const KontaktZiel 	= Number(Kontakt.getAttribute('KontaktZiel'));
	const Position		= Kontakt.getAttribute('Position') / 100;
	const ParaOderAnti 	= Kontakt.getAttribute('ParaOderAnti'); // Gleisrichtung 0: Ende -> Anfang, 1: Anfang -> Ende
	const fireOnPara 	= Kontakt.getAttribute('fireOnPara');
	const fireOnAnti 	= Kontakt.getAttribute('fireOnAnti');
	const Teiler 		= Kontakt.getAttribute('Teiler');
	const ActTeiler 	= Kontakt.getAttribute('ActTeiler');
	const Delay 		= Kontakt.getAttribute('Delay');
	const ActDelay 		= Kontakt.getAttribute('ActDelay');
	const TrainSide 	= Kontakt.getAttribute('TrainSide');
	const RouteID 		= Kontakt.getAttribute('Route');
	const TrainID 		= Kontakt.getAttribute('TrainID');
	const NameFilter 	= Kontakt.getAttribute('NameFilter');
	const TrainNewName 	= Kontakt.getAttribute('TrainNewName');
	const zuStellung 	= Kontakt.getAttribute('zuStellung');
	const Wechseln 		= Kontakt.getAttribute('Wechseln');
	const ConnectF 		= Kontakt.getAttribute('ConnectF');
	const ConnectR 		= Kontakt.getAttribute('ConnectR');
	const VolDist 		= Kontakt.getAttribute('VolDist');
	const SignalData 	= Kontakt.getAttribute('SignalData');
	const LuaFn 		= Kontakt.getAttribute('LuaFn');

	const TrainSidetext = {
		0 : 'Spitze',
		1 : 'Schluss',
		[-1] : 'GrKP',
	}
	
	// SignalData 
	/*
	Byte 1 - 2 (LSB)
		Key-ID des abgefragten Signals oder Weiche
	Byte 3 - 4 (MSB) 
		Signal- oder Weichenstellung, die gegeben sein muss, damit der Kontakt schaltet
		Signal: 
			1=Fahrt
			2=Halt
		Weiche: 
			1=Durchfahrt
			2=Abzweig
			3=Koabzweig
		EKW: 
			1=von links nach rechts
			2=von rechts nach rechts
			3=von rechts nach links 
		DKW: 
			1=von links nach links
			2=von links nach rechts
			3=von rechts nach rechts
			4=von rechts nach links 
	*/
	const SignalDataStellung = Math.floor(SignalData / 65536);
	const SignalDataID   	 = SignalData - SignalDataStellung * 65536;
	
	let Meldung, Gleis;
	const Ziel = global.KontaktZiele[KontaktZiel];
	if (Ziel) {
		Meldung = global.Meldungen[Number(Ziel.ID)];
		Gleis = global.Weichen[Number(Ziel.ID)];
	}

	// Zugverband`
	//const Zugverband = Zugverbaende.get(Number(TrainID)); // Zugverbaende.find(function(Zugverband) { return Zugverband.ID == TrainID});

	// Kurzform in msg-Element
	msg(`Kontakt auf ${GleissystemText[GleissystemID]} ${GleisID}`);

	// Ausführlich im Info Popup
	showInfoWindow({
		code: 'K' + KontaktID,
		title: `Kontakt`,
		content:  
			`<i>Position: `
				+ `<a href="javascript:void(0);" onclick="javascript:global.SvgPanZoom.centerPosition([${Kontakt.mPos}]);">`
				+ `${GleissystemText[GleissystemID]} ${GleisID} +${Position.toFixed(1)}m<\/a><\/i>`
			+ `<br>Kontakttyp ` + SetType + ': ' 
			// KontaktTyp[SetType] mit Modifikation
			+ getKontaktIcon(GleissystemID, SetType, SetValue) + ' '
			+ getKontaktText(GleissystemID, SetType, SetValue, VolDist, ConnectF)
			+ (SetType == 768 ||  SetType == 1024 ? `<br>ImmoIdx: ` + SetValue : '')	// Verweis auf ImmoIdx 
			//+ (SetType == 512 && ConnectF != 0 ? `<br>ConnectF: ` + ConnectF : '')
			+ (KontaktZiel != null && KontaktZiel != 0 
				? `<br>Kontaktziel ${KontaktZiel}: ` 
					+ ( Ziel ? 
							`<a href="javascript:void(0);" onclick="javascript:global.SvgPanZoom.centerPosition([${(Meldung ? Meldung.mPos : (Gleis ? Gleis.mEnd : undefined))}]);">`
							+ `${Ziel.Typ} ${Ziel.ID} auf ${GleissystemText[Ziel.GleissystemID]} ${Ziel.GleisID}`
							+ `<\/a>` 
						  : 'unbekannt'
					  )
				: '') 
			+ `<br>Auslösung: `		+ (			fireOnPara == 1 && fireOnAnti == 0 ? (ParaOderAnti == 1 ? 'in Gleisrichtung' : 'gegen Gleisrichtung') 
											: ( 	fireOnPara == 0 && fireOnAnti == 1 ? (ParaOderAnti == 0 ? 'in Gleisrichtung' : 'gegen Gleisrichtung') 
												: ( fireOnPara == 1 && fireOnAnti == 1 ? 'beide Richtungen' : '' )
											  )
										  ) 
			+ (Teiler != 0 			? `<br>Zug-Zähler: ` + Teiler : '')
			+ (ActTeiler != 0 		? `<br>Zählerstand: `		+ ActTeiler : '')
			+ (Delay != 0 			? `<br>Zeitverzögerung: `	+ Delay : '')
			+ (ActDelay != 0 		? `<br>Zeit abgelaufen: `	+ ActDelay : '')
			+ `<br>Zugposition: `		+ (TrainSidetext[TrainSide] ? TrainSidetext[TrainSide] : TrainSide) 
			+ (RouteID != 0 		? `<br>für Route: ` + global.Routen[RouteID] : '') 
			+ (TrainID != 0 		? `<br>für Zug: ` + TrainID /*+ ' ' + (Zugverband ? Zugverband.Name : 'nicht vorhanden') */ : '') 
			+ (NameFilter !== ''	? `<br>Zug-Filter: `		 + NameFilter : '') 
			+ (TrainNewName !== ''	? `<br>Neuer Zugname: `	 + TrainNewName : '')
			+ (zuStellung > 0 && Wechseln == 0 ? `<br>zu Stellung: ` + zuStellung : (Wechseln == 1 ? 'Umschalter' : '')) 
			+ (SignalData != 0 		? `<br>SignalData: ID=${SignalDataID} Stellung=${SignalDataStellung}` : '') 
			+ (LuaFn && LuaFn !== '' ? `<br>LuaFn: ${LuaFn}` : '') 
			+ objectToHTML(Kontakt)
	});
}

function showKameraInfo(Name) {
//<Kammera name="..." DOF="0" Dynamic="0" FocalIdx="193" FStopIdx="13" SubDist="100" DOFSubDist="100" DOFShiftNear="9.65" DOFShiftFar="12.965" FOV="0" TakeSwitch="0">
	function angle(rad) {
		return (rad*180/Math.PI).toFixed(1) + '°'
	}

	const Kamera 		= global.Kameras[Name];
	if (!Kamera) { return; }

	const Dynamic 	= Kamera.getAttribute("Dynamic");

	const [DirX, DirY, DirZ, d0, NorX, NorY, NorZ, n0, BinX, BinY, BinZ, b0, PosX, PosY, PosZ, scale ] = Kamera.mPos;

	// https://www.matheplanet.com/default3.html?call=viewtopic.php?topic=140833&ref=https%3A%2F%2Fwww.google.com%2F

	// https://www.java-forum.org/thema/rotationswinkel-aus-einer-tansformationsmatrix-berechnen.158869/
	// oder  https://de.wikipedia.org/wiki/Roll-Nick-Gier-Winkel#Berechnung_aus_Rotationsmatrix
	// beta	= atan2( -r[2][0], sqrt(pow(r[0][0], 2) + pow(r[1][0], 2)) )
	// if beta <> Math.PI/2
	// 	 alpha = atan2( r[1][0]/cos(beta), r[0][0]/cos(beta) )
	// 	 gamma = atan2( r[2][1]/cos(beta), r[2][2]/cos(beta) )
	// else
	// 	 alpha = 0
	// 	 gamma = sign(beta) * atan2( r[0][1], r[1][1] );

/*
Deep Ocean						X°					Y° 					Z°
													Neigung					Richtung
								atan2(NorZ, BinZ)	-asin(DirZ)			-acos( DirX/cos(angleY) )
Anleger ELSA Kurhotel 			X: 0.0° 			Y: -2.4° 			Z: -72.0°
Bhf Einstädt					X: 0.0° 			Y: 9.6° 			Z: -162.0°
DANGER! Frachter 				X: 0.0° 			Y: 16.8° 			Z: -150.0°
Des Käptn´s Häuschen 			X: 0.0° 			Y: 2.4° 			Z: -72.0°
Industrieruine  				X: 0.0° 			Y: 12.0° 			Z: 36.0°
Kamerarundblick 				X: 0.0° 			Y: 2.4° 			Z: -90.0°
Kuhl bleiben 					X: 0.0° 			Y: -4.8° 			Z: -107.9°
Leuchtturmidylle 				X: 0.0° 			Y: 31.2° 			Z: 126°
Lokverladung in die VOGELFLUG 	X: 0.0° 			Y: 9.6° 			Z: -113.7°
Motorbootanleger 				X: 0.0° 			Y: -2.4° 			Z: -138.0°
Roofer 							X: 0.0° 			Y: 40.8° 			Z: -18.0°
Schuettgutverladung 			X: 0.0° 			Y: 7.2° 			Z: -42.2°
*/

	const angleY 	= -Math.asin( DirZ );
				//	= Math.acos( BinZ );
				//	= -Math.atan2( DirZ, BinZ );
				
	const angleX 	= ( Math.cos(angleY) == 0 ? 0 :  
						 Math.asin( Math.min(1, Math.max(-1, NorZ/Math.cos(angleY)) )) 	// protect against rounding errors 
						 );
				//	= Math.atan2( NorZ, BinZ );
				
	const angleZ 	= ( Math.cos(angleY) == 0 ? 'error' : 
						-Math.acos( Math.min(1, Math.max(-1, DirX/Math.cos(angleY)) )) 	// protect against rounding errors
						* (DirY<0 ? -1 : 1) );											// adjust sign			

/*console.log(Name
//	+ '\nasin( DirX )=\t' + angle( -Math.asin( DirX ) ) 
//	+ '\nacos( DirX )=\t' + angle( Math.acos( DirX ) )
	+ '\nY: asin( DirZ )=\t' + angle( -Math.asin( DirZ ) ) 
//	+ '\nacos( DirZ )=\t' + angle( Math.acos( DirZ ) )
//	+ '\nasin( BinX )=\t' + angle( -Math.asin( BinX ) ) 
//	+ '\nacos( BinX )=\t' + angle( Math.acos( BinX ) )
//	+ '\nasin( BinZ )=\t' + angle( -Math.asin( BinZ ) ) 
	+ '\nY: acos( BinZ )=\t' + angle( Math.acos( BinZ ) )

//	+ '\natan2( DirX, NorX )=\t' + angle( Math.atan2( DirX, NorX ) )
//	+ '\natan2( NorX, BinX )=\t' + angle( Math.atan2( NorX, BinX ) )
//	+ '\natan2( BinX, DirX )=\t' + angle( Math.atan2( BinX, DirX ) )

//	+ '\natan2( DirZ, NorZ )=\t' + angle( Math.atan2( DirZ, NorZ ) )
	+ '\nX: atan2( NorZ, BinZ )=\t' + angle( Math.atan2( NorZ, BinZ ) )
//	+ '\natan2( BinZ, DirZ )=\t' + angle( Math.atan2( BinZ, DirZ ) )

//	+ '\natan2( DirX, BinX )=\t' + angle( Math.atan2( DirX, BinX ) )
//	+ '\natan2( NorX, DirX )=\t' + angle( Math.atan2( NorX, DirX ) )
//	+ '\natan2( BinX, NorX )=\t' + angle( Math.atan2( BinX, NorX ) )

	+ '\nY: atan2( DirZ, BinZ )=\t' + angle( -Math.atan2( DirZ, BinZ ) )
//	+ '\natan2( NorZ, DirZ )=\t' + angle( Math.atan2( NorZ, DirZ ) )
//	+ '\natan2( BinZ, NorZ )=\t' + angle( Math.atan2( BinZ, NorZ ) )

//	+ '\nasin( DirX/cos(y) )=\t' + angle( Math.asin( DirX/Math.cos(angleY) ) )
//	+ '\nasin( NorX/cos(y) )=\t' + angle( Math.asin( NorX/Math.cos(angleY) ) )
//	+ '\nasin( BinX/cos(y) )=\t' + angle( Math.asin( BinX/Math.cos(angleY) ) )

//	+ '\nasin( DirY/cos(y) )=\t' + angle( Math.asin( DirY/Math.cos(angleY) ) )
//	+ '\nasin( NorY/cos(y) )=\t' + angle( Math.asin( NorY/Math.cos(angleY) ) )
//	+ '\nasin( BinY/cos(y) )=\t' + angle( Math.asin( BinY/Math.cos(angleY) ) )
	
//	+ '\nasin( DirZ/cos(y) )=\t' + angle( Math.asin( DirZ/Math.cos(angleY) ) )
	+ '\nX: nasin( NorZ/cos(y) )=\t' + angle( Math.asin( NorZ/Math.cos(angleY) ) )
//	+ '\nasin( BinZ/cos(y) )=\t' + angle( Math.asin( BinZ/Math.cos(angleY) ) )

	+ '\nZ: acos( DirX/cos(y) )=\t' + angle( -Math.acos( DirX/Math.cos(angleY) ) * (DirY<0 ? -1 : 1) )
//	+ '\nacos( NorX/cos(y) )=\t' + angle( Math.acos( NorX/Math.cos(angleY) ) )
//	+ '\nacos( BinX/cos(y) )=\t' + angle( Math.acos( BinX/Math.cos(angleY) ) )

//	+ '\nacos( DirY/cos(y) )=\t' + angle( Math.acos( DirY/Math.cos(angleY) ) )
//	+ '\nacos( NorY/cos(y) )=\t' + angle( Math.acos( NorY/Math.cos(angleY) ) )
//	+ '\nacos( BinY/cos(y) )=\t' + angle( Math.acos( BinY/Math.cos(angleY) ) )
	
//	+ '\nacos( DirZ/cos(y) )=\t' + angle( Math.acos( DirZ/Math.cos(angleY) ) )
//	+ '\nacos( NorZ/cos(y) )=\t' + angle( Math.acos( NorZ/Math.cos(angleY) ) )
//	+ '\nacos( BinZ/cos(y) )=\t' + angle( Math.acos( BinZ/Math.cos(angleY) ) )

)*/

	// Kurzform in msg-Element
	msg(`Kamera ${Name}`);

	// Ausführlich im Info Popup
	showInfoWindow({
		code: 'Kamera ' + Name,
		title: '📷 ' + Name, // 📷 \u1F4F7
		content: //`<b>${Name}<\/b><br>` +
			  `Position: (<a href="javascript:void(0);" onclick="javascript:global.SvgPanZoom.centerPosition([${Kamera.mPos}])">${PosX.toFixed(0)}m, ${-PosY.toFixed(0)}m<\/a>)`			
			+ `<br>Höhe: ${PosZ.toFixed(0)}m`
			+ `<br>Blickrichtung: ` 		 + angle( angleZ )			// Neigung Z
			+ ' ' + ['W', 'WSW', 'SW', 'SSW', 'S', 'SSO', 'SO', 'OSO', 'O', 'ONO', 'NO', 'NNO', 'N', 'NNW', 'NW', 'WNW', 'W',][Math.floor(8+0.5+angleZ/Math.PI*8)]
			+ `<br>Neigung: ` 				 + angle( angleY )			// Neigung Y
			+ (angleX < -0.01 || angleX > 0.01 ? `<br>Kippung: ` + angle( angleX ) : '')	// Neigung X
			+ (Dynamic == 0 ? `<br>statisch` : `<br>dynamisch`)
			+ objectToHTML(Kamera)
	});
}
</script>
<script type="text/javascript"> // toolwindow
"use strict";
(function(api) {
// public api
api.showInfoWindow = showInfoWindow;

let infoWindow = { count: 0, };
function showInfoWindow(options) {
	let code = 'default';
	if (global.shiftDown) {
		code = options.code;
	}
	if (!infoWindow[code]) {
		infoWindow.count = (infoWindow.count+1)%10;
		infoWindow[code] = new ToolWindow({
			title: options.title, // goes in the title bar,
			//closeButtonText: "x", // ✖ = &#x2716;
			top: 120+infoWindow.count*32,
			left: 120+infoWindow.count*32, // optional: when no top or left are given, this window attempts to center itself
			width: 225, // starting width
			height: 200, // starting height
			minWidth: 100, // don't go thinner than this
			minHeight: 100, // don't go shorter than this
			//placement: "inside,auto",
			//relativeToElement: "#container",
			animated: true,
			content: {
				type: "html",
				value: options.content,
			},
			buttons: [/*{	//  to omit all buttons
				text: "Dismiss",
				clicked: function() {
					// button click handlers are invoked with the infoWindow as the `this` parameter
					this.hide();
				}
				}, {
				text: "Refresh",
				clicked: function() {
					// note that we can completely replace the content
					// here and that content.value can be any one of:
					// - string
					// - function producing a string
					// - async function producing a string (ie, promise)
					this.content = {
						type: "html",
						value: "<hr/>This is html<hr/>"
					};
					this.refresh();
				}
			}*/]
		});
	} else {
		infoWindow[code].title = options.title;
		infoWindow[code].content.value = options.content;
		infoWindow[code].fitContent();
	}
	infoWindow[code].show();
}
})(this);
</script>
</aside>

<aside id="exportPopup"> <!-- Export Window -->

<script type="text/javascript"> // toolwindow
"use strict";
(function(api) {
// public api
api.showExportWindow = showExportWindow;

let exportWindow;
function showExportWindow() {
	if (!exportWindow) {
		const content = `
<p>Wähle die Größe <input type="number" name="exportSize" id="exportSize" value="3000" min="1" autocomplete="off" \/> und das gewünschte Datenformat:<\/p>
<dl>
<dt>PNG<\/dt>
<dd>Verlustfreie Pixel-Graphik in bestimmter Größe; ideal für Computergraphik<\/dd>
<dt>JPG<\/dt>
<dd>Verlustbehaftetes Pixel-Bild in bestimmter Größe und Qualität; ideal für Fotos.<br>
Qualität (%): <input type="number" name="jpgQuality" id="jpgQuality" value="92" min="1" max="100" step="1" autocomplete="off" \/><br><br>
Nur Bilder in diesem Format können direkt in das <a href="https:\/\/www.eepforum.de\/gallery\/" target="_blank">EEP-Forum<\/a> hochgeladen werden: <i>Die Bilder dürfen die Dateiendungen jpg, jpeg besitzen und sie dürfen maximal 2 MB groß sein. Die minimale Bildgröße beträgt 800×500 Pixel und die maximale Größe beträgt 1920×1080 Pixel.<\/i> Daher wird die Größe der exportieren Graphik nach Möglichkeit auf diese Werte begrenzt.<\/dd>
<dt>SVG<\/dt>
<dd>Beliebig zoombare, verlustfreie Vektor-Graphik; ideal zur Weiterverarbeitung in anderen Programmen<br>
Beim Export wird die gesamte Graphik exportiert auch wenn dann nur der gewählte Ausschnitt gezeigt wird.<\/dd>
<\/dl>
				`;
	
		exportWindow = new ToolWindow({
			title: "Gleisplan exportieren",
			//closeButtonText: "x", // ✖ = &#x2716;
			//top: 120+exportWindow,
			//left: 120+exportWindow, // optional: when no top or left are given, this window attempts to center itself
			width: 225, // starting width
			height: 200, // starting height
			minWidth: 100, // don't go thinner than this
			minHeight: 100, // don't go shorter than this
			//placement: "inside,auto",
			//relativeToElement: "#container",
			animated: true,
			content: {
				type: "html",
				value: content,		
			},
			buttons: [
				{
					text: "PNG",
					clicked: function() {
						exportGraphic("png");
					}
				}, {
					text: "JPG",
					clicked: function() {
						exportGraphic("jpg");
					}
				}, {
					text: "SVG",
					clicked: function() {
						exportGraphic("svg");
					}
				},
			],
		});
	}
	exportWindow.show();
}

function exportGraphic(fileType) {
	// Get target size of the raster graphic (png/jpg)
	let   exportSize = Number(document.getElementById("exportSize").value);
	const jpgQuality = Number(document.getElementById("jpgQuality").value) / 100;

	// Read svg
	const svg 		= document.getElementById("svg");
	const svgSize 	= svg.getBoundingClientRect();	// Firefox requires explicit sizes for XMLSerializer ..
	svg.setAttribute("width", svgSize.width);
	svg.setAttribute("height", svgSize.height);
	let svgString	= new XMLSerializer().serializeToString(svg);
	svg.removeAttribute("width");					// .. but SvgPanZoom manages the size by itself, therefore we have to remove the size again
	svg.removeAttribute("height");

	if (fileType === 'svg') {
		// reduce precission (not required anymore because already done in svgAppend)
		// svgString = svgString.replace(/(\.\d{0,5})\d*/g, '$1');
	}

	// Convert svg to png/jpg and export it
	const svgType = "image/svg+xml;charset=utf-8";
	const svgBlob = new Blob([svgString], {type: svgType});
	
	// Create object url
	const url = URL.createObjectURL(svgBlob);

	if (fileType === 'svg') {
		// Export svg
		exportData(url, fileType);
		return;
	}

	// Create canvas
	const canvas = document.createElement("canvas");

	// Set size of canvas
	const ratio = svgSize.width / svgSize.height;

	if (ratio > 1) {
		if (fileType === 'jpg') {
			exportSize 	= Math.max(800, Math.min(1920, exportSize));
			if (exportSize / ratio < 500) {
				exportSize = 500 * ratio
			}
			if (exportSize / ratio > 1080) {
				exportSize = 1080 * ratio
			}
		}
		canvas.width 	= exportSize;
		canvas.height 	= exportSize / ratio;
	} else {
		if (fileType === 'jpg') {
			exportSize 	= Math.max(500, Math.min(1080, exportSize));
			if (exportSize / ratio < 800) {
				exportSize = 800 * ratio
			}
			if (exportSize / ratio > 1920) {
				exportSize = 1920 * ratio
			}
		}
		canvas.width 	= exportSize / ratio;
		canvas.height 	= exportSize;
	}

	const ctx = canvas.getContext("2d");

	// Create image from object url
	const img = new Image();
	img.onload = function() {
		// Paint image into canvas
		ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
		
		// Remove temporary data
		URL.revokeObjectURL(url);

		// Convert canvas to png/jpg
		// Firefox might raise exception NS_ERROR_FAILURE
		let mimeType;
		if 		(fileType === 'png') { mimeType = "image/png"; }
		else if (fileType === 'jpg') { mimeType = "image/jpeg"; }
		else {
			msg("Dateityp nicht unterstützt: " + fileType);
			return false;
		}
		
		let DataURL;
		try{
			const encoderOptions = jpgQuality; // jpg quality (default 0.92) 
			DataURL = canvas.toDataURL(mimeType, encoderOptions);
		} catch(err){
			console.log(err);
			msg("Zu groß: Export nicht möglich (toDataURL()): " + mimeType);
			return false;
		}
		// We might get a very short result which is another type of error
		if ( DataURL.length <= 6 ) {
			msg("Zu groß, Export nicht möglich (DataURL.length): " + mimeType)
			return false;
		}

		const rc = exportData(DataURL, fileType);
		msg(`${fileType}-Graphik in Größe ${canvas.width}x${canvas.height} exportiert`);
		return rc;
	};
	// Load img
	img.src = url;
}
function exportData(dataURL, fileType) {
	// Get file name without extension
	const filename = document.getElementById("filename").textContent;

	// Create download link and click it
	const link = document.createElement("a");
	link.setAttribute("href", dataURL);
	link.setAttribute("download", filename + "." + fileType);
	//link.setAttribute("target", "_blank"); // not required
	link.style.display = "none";
	document.body.appendChild(link); // Required for Firefox(?)
	// Download
	try{
		link.click(); // We might get a network error in case of very huge results (but it"s not possible to catch the error)
	} catch(err){
		console.log(err);
		msg("Zu groß: Export nicht möglich (link.click)");
		document.body.removeChild(link);
		URL.revokeObjectURL(dataURL);
		return false;
	}
	// Remove temporary data
	document.body.removeChild(link);
	URL.revokeObjectURL(dataURL);
	return true;
}
})(this);
</script>
</aside>

<aside id="colorPopup"> <!-- Color Picker Window -->
<script type="text/javascript"> // colorPicker
"use strict";
(function(api) {
// public api
api.loadColors = loadColors;
api.showColorPickerWindow = showColorPickerWindow;

const GleissystemFarbDefinition = [{
	name: 'Eisenbahn',
	color: '#FF0000'	/* red; */
}, {
	displayName: 'Straßenbahn',
	name: 'Strassenbahn',
	color: '#A9A9A9'	/* darkgray; */
}, {
	displayName: 'Straße',
	name: 'Strasse',
	color: '#808080'	/* grey; */
}, {
	name: 'Wasserwege',
	color: '#0000FF'	/* blue; */
}, {
	name: 'Steuerstrecken',
	color: '#800080'	/* purple; */
}, {
	name: 'GBS',
	color: '#A52A2A'	/* brown; */
}, {
	name: 'Kamera',
	color: '#00FF00'	/* green; */
}, {
	name: 'Hintergrund',
	color: '#FFFFFF'	/* white; */
}];
let GleissystemFarbe;
function loadColors() {
	GleissystemFarbe = JSON.parse(localStorage.getItem('GleissystemFarbe'));

	if (GleissystemFarbe) {
		setColors();
	} else {
		resetColors();
	}
}
function resetColors() {
	// reset color values
	GleissystemFarbe = {};
	GleissystemFarbDefinition.forEach(function(farbe) {
		GleissystemFarbe[farbe.name] = farbe.color;
	});
	
	// set SVG CSS variables
	setColors();

	// purge local storage
	localStorage.removeItem('GleissystemFarbe');
}
function setColors() {
	// set SVG CSS variables
	const defaultColorVariables = GleissystemFarbDefinition.map(function(farbe) {
		return `--${farbe.name}-color: ${GleissystemFarbe[farbe.name] || farbe.color};`;
	}).join('');
	document.getElementById("css-track-colors").textContent = `svg { ${defaultColorVariables} }`;

	// Update color in storage
	localStorage.setItem('GleissystemFarbe', JSON.stringify(GleissystemFarbe));
}

let colorPickerWindow;
function showColorPickerWindow() {
	if (!colorPickerWindow) {
		const content = GleissystemFarbDefinition.map(function(farbe) {
			return `<div><label><input type="color" class="colorPicker" id="colorPicker-${farbe.name}" name="${farbe.name}">&nbsp;${farbe.displayName || farbe.name}<\/label><\/div><br>`;
		}).join('');

		colorPickerWindow = new ToolWindow({
			title: "Farben wählen",
			//closeButtonText: "x", // ✖ = &#x2716;
			//top: 120,
			//left: 120, // optional: when no top or left are given, this window attempts to center itself
			width: 225, // starting width
			height: 200, // starting height
			minWidth: 100, // don't go thinner than this
			minHeight: 100, // don't go shorter than this
			//placement: "inside,auto",
			//relativeToElement: "#container",
			animated: true,
			content: {
				type: "html",
				value: content,		
			},
			buttons: [
				{
					text: "Reset",
					clicked: function() {
						resetColors();
						this.hide();
					},
				},
			],
		});
	}
	colorPickerWindow.show();

	GleissystemFarbDefinition.forEach(function(farbe) {
		const colorPicker = document.getElementById('colorPicker-' +  farbe.name);
		colorPicker.value = GleissystemFarbe[farbe.name] || farbe.color;
		// Add event handlers again (because the popup)
		colorPicker.addEventListener("input", setColor);
	});
} // end function showColorPickerWindow

function setColor(event) {
	const name 	= event.target.name;
	const color = event.target.value;

	GleissystemFarbe[name] = color;
	setColors();
}
})(this); // end module
</script>
</aside>

<style id="modCSS"> /* mod default CSS */
/* Instead of inserting CSS modifications here, you can use the bookmark trick described at http://mcdlr.com/css-inject/ 

Example with 3 modification rules:
1. remove marker of .Prellbock
2. show .inactive track like other tracks
3. highlight specific track type .Helix after reducing the visibility of all track types .EEPCurve, .Line, .Arc, .Rotator, .Cubic, .Helix
Title: mod EEP
Code (6 lines):
javascript:(function(){document.getElementById(%27modCSS%27).textContent=%27
.Prellbock { marker-end: none} 
.inactive { stroke-opacity: 1.0} 
.EEPCurve, .Line, .Arc, .Rotator, .Cubic, .Helix { stroke-width: calc(var(--normal-stroke-width)/2); stroke-opacity: 0.2; }
.Helix { stroke-width: calc(var(--normal-stroke-width)*2); stroke-opacity: 1.0; }
%27;})();

Example to reset modifications:
Title: 	reset EEP
Code:	javascript:(function(){document.getElementById(%27modCSS%27).textContent=%27%27;})();

*/

</style>

</main> <!-- Main screen --> 

</body>
</html>
