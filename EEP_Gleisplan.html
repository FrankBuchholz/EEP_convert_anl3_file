<!DOCTYPE html>
<html lang="de">
<!-- https://www.w3.org/International/questions/qa-html-language-declarations -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<META http-equiv="Content-Script-Type" content="text/javascript">
<title>Interaktive Anzeige des Gleisplans zu einer EEP-Anlage-Datei (.anl3)</title>
<meta name="description" content="Dieses Programm nutzt die Javascript-Funktion DOMParser um eine .anl3-Datei von EEP, die aus XML aufgebaut ist, zu interpretieren und in das Document Object Model (DOM) umzuwandeln. Anschließend wird dynamisch mit Javascript die Graphik des Gleisplanes mit SVG-Befehlen aufgebaut. Die Formatierung der graphischen Elemente erfolgt getrennt von der Definition der Graphik mit der SVG-Variante von CSS. Der Browser kann solche SVG-Graphiken direkt anzeigen. Zusätzlich werden die Bibliotheken svg-pan-zoom zum Verschieben und Zoomen und toolwindow zur Anzeige von Popups verwendet.">
<meta name="author" content="Frank Buchholz">
<meta name="keywords" content="EEP,.anl3,Gleisplan" />
<meta name="language" content="de" />
<!-- <link rel="icon" href="https://www.eepforum.de/images/favicon.ico" type="image/x-icon"> -->
<link rel="icon" href="images/favicon.ico" type="image/x-icon">

<script type="text/javascript" src="js/EEP_Texts.js"></script> <!-- Load texts and translations -->
<link rel="stylesheet" href="css/EEP_Texts.css">

<script type="text/javascript"> // Experiment to load scripts dynamically either from relative path or from fixed URL - not used yet
"use strict";
/* Interface
required standard objects:
	document
public api:
	loadScript
*/
(function(api) {
// public api
api.loadScript = loadScript;

/* Source: https://humanwhocodes.com/blog/2009/07/28/the-best-way-to-load-external-javascript/
Usage:
<s.cript type="text/javascript">
loadScript("http://your.cdn.com/script.js", function(){
    //initialization code
});
</s.cript>
*/
function loadScript(url, callback){
	const script = document.createElement("script");
	script.type = "text/javascript";
	script.onload = function(){	// IE would require different calls
		callback();
	};
	script.src = url;
	document.getElementsByTagName("head")[0].appendChild(script);
}
})(this); // end module
</script>

<style> /* html page */
/* <![CDATA[ */
html, body { /* deactivate default settings */
	margin: 0;
	padding: 0;
}

body {
	--header-background-color: STEELBLUE; /* ThreeDHighlight; */
	--header-text-color: WHITE; /* CaptionText; */

	--body-background-color: WhiteSmoke; /* AZURE; Window; */
	--body-text-color: BLACK; /* WindowText; */

	--footer-background-color: CADETBLUE; /* ButtonFace; */
	--footer-text-color: WHITE; /* ButtonText; */
}

.hidden {
	display: none;
}

 /* no select/copy to clipboard. Firefox prevents selection even in case of Ctrl-A, but with Chrome it's not reliably. */
.no-select,
fieldset,
select,
input,
button {
	user-select: none;
	-webkit-user-select: none;	/* WebKit-specific values */
}
/* ]]> */
</style>
</head>

<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
<body>

<section id="fileselector"> <!-- Selection screen -->

<header class="flexRow"> <!-- Show heading and language selection buttons, see EEP_Texts.css -->
<div> <!-- left part -->
<h3><span lang="de">EEP-Gleisplan</span><span lang="en">EEP Track plan</span><span lang="fr">EEP Plan des voies</span></h3>
</div>

<div> <!-- right part -->
<label for="german" class="langBtn">Deutsch</label>
<label for="english" class="langBtn">English</label>
<label for="french" class="langBtn">Français</label>
</div>
</header>

<article>
<form action="#" onsubmit="return false;"> <!-- better not to use inline listener, explicit register is better -->
<label for="fileinput">
<span lang="de">Wähle (auch mit Drag&amp;Drop möglich) und lade eine EEP-Anlage-Datei (.anl3).</span>
<span lang="en">Select (or use Drag&amp;Drop) and load an EEP file (.anl3).</span>
<span lang="fr">Sélectionnez un réseau EEP (nom_du_réseau.anl3) ou utilisez la fonction glisser-déposer.</span>
</label>
	<input type="file" id="fileinput" accept=".anl3" onchange="loadFile(this.files && this.files[0])" />
	<!-- An extra button is not necessary -->
	<!-- <input type="button" id="btnLoad" value="Load" onclick="loadFile();"> -->
</form>

<p lang="de">	<!-- Mausfunktionen -->
<small><strong>Mausfunktionen</strong><br>
Verschieben: Klick+Halten+Bewegen<br>
An der Stelle des Cursors hineinzoomen: Doppelklick<br>
Herauszoomen: <kbd>&#x21E7; Shift</kbd>+Doppelklick<br>
Details anzeigen: Klick auf Gleis, Symbol oder Text<br>
<span class="li">wenn zusammen mit <kbd>&#x21E7; Shift</kbd>, dann wird jeweils ein neues Popup geöffnet</span>
<span class="li">wenn zusammen mit <kbd>alt</kbd>, dann wird zusätzlich der Code aus der Anlage-Datei für dieses Objekt angezeigt</span>
</small></p>

<p lang="en">
<small><strong>Mouse functions</strong><br>
Move: Click+Hold+Move<br>
Zoom in at position of the cursor: Double click<br>
Zoom out: <kbd>&#x21E7; Shift</kbd>+Double click<br>
Show details: Click on track, symbol or text<br>
<span class="li">if together with <kbd>&#x21E7; Shift</kbd>, then you get another new popup window</span>
<span class="li">if together with <kbd>alt</kbd>, then you will get the code from the file for this object, too</span>
</small></p>

<p lang="fr">
<small><strong>Fonctions de la souris</strong><br>
Déplacer: Clic+Tenir+Mouvoir<br>
Zoomer à l‘endroit précis du curseur: double-clic<br>
Dézoomer: <kbd>&#x21E7; Shift</kbd>+double-clic<br>
Afficher les détails: Cliquer sur voie, symbole ou texte<br>
<span class="li">en appuyant simultanément également sur <kbd>&#x21E7; Shift</kbd>, un nouveau pop-up s‘ouvrira</span>
<span class="li">en appuyant simultanément également sur <kbd>alt</kbd>, tout le code du fichier *.anl3 correspondant à cet objet s‘affichera</span>
</small></p>


<p lang="de">	<!-- Tastaturfunktionen -->
<small><strong>Tastaturfunktionen</strong><br>
<kbd>&larr;</kbd> <kbd>&uarr;</kbd> <kbd>&rarr;</kbd> <kbd>&darr;</kbd> : Verschieben der Graphik (wenn zusammen mit <kbd>&#x21E7; Shift</kbd>, dann jeweils um eine halbe Seite)<br>
<kbd>+</kbd> <kbd>-</kbd> : Zoomen</small></p>

<p lang="en">
<small><strong>Key functions</strong><br>
<kbd>&larr;</kbd> <kbd>&uarr;</kbd> <kbd>&rarr;</kbd> <kbd>&darr;</kbd> : Move graphic (if together with <kbd>&#x21E7; Shift</kbd>, then you move it by half of a page)<br>
<kbd>+</kbd> <kbd>-</kbd> : Zoom</small></p>

<p lang="fr">
<small><strong>Fonctions du clavier</strong><br>
<kbd>&larr;</kbd> <kbd>&uarr;</kbd> <kbd>&rarr;</kbd> <kbd>&darr;</kbd> : Déplacer le graphique (ensemble avec la touche <kbd>&#x21E7; Shift</kbd>, alors d‘une demi-page à la fois)<br>
<kbd>+</kbd> <kbd>-</kbd> : Zoomer</small></p>


<p lang="de">	<!-- Interaktive Funktionen -->
<small><strong>Interaktive Funktionen</strong><br>
Wechsel zwischen vertikaler und horizontaler Ausrichtung (Fullscreen mit <kbd>F11</kbd>)<br>
Zoom-in, -out, -reset<br>
Auswahl der anzuzeigenden Gleissysteme<br>
Auswahl der anzuzeigenden Informationen (GleisID, Kurventyp, Gleisstil, Höhe, Weichen, Signale, Kontakte, Marker, Gleisobjekte, Kamera, Rahmen)<br>
Auswahl der anzuzeigenden Gleise (aktive/inaktive Gleise mit/ohne Rollmaterialien, sichtbare/unsichtbare Gleise, virtuelle Verbindungen)<br>
Aktuelle Darstellung als Bild (png/jpg/svg) speichern<br>
Gleisplan auf bestimmtes Gleis, bzw. das Gleis eines Signals oder Weiche positionieren<br>
Die Positionierung ist auch über das <a href="EEP_Inventar.html" target="_blank">Inventar</a>-Programm möglich!<br>
Einstellung der Linienbreite und der Schriftgröße<br>
Auswahl der Gleise mit minimalem und maximalen Höhenfilter<br>
Farben der Gleissysteme anpassen
</small></p>

<p lang="en">
<small><strong>Interactive functions</strong><br>
Switch between vertical and horizontal alignment (Full screen using <kbd>F11</kbd>)<br>
Zoom-in, -out, -reset<br>
Choose displayed track systems<br>
Choose displayed information (TrackID, curve type, track style, height, switches, signals, contacts, marker, track objects, cameras, border)<br>
Choose displayed tracks (active/inactive tracks with/without rolling stocks, visible/invisible tracks, virtual connections)<br>
Store current view as picture (png/jpg/svg)<br>
Position track plan at specific track, respective track of a signal or switch<br>
You can use the <a href="EEP_Inventar.html" target="_blank">inventory</a> program as well to position the view!<br>
Define line thickness and font size<br>
Filter tracks by min./max. height<br>
Define colors of the track systems
</small></p>

<p lang="fr">
<small><strong>Fonctions interactives</strong><br>
Alterner la position de la barre entre horizontale et verticale (<kbd>F11</kbd> pour plein écran)<br>
Zoom-in, -out, -reset<br>
Sélection des systèmes de voies<br>
Sélection des informations à visualiser (ID voie, variante de voie, style de voie, hauteur, aiguillages, signaux, contacts,marqueurs,objets de voie, caméras, cadre)<br>
Sélection des voies à visualiser (voies actives/inactives. avec/sansmatériels roulants, connexion virtuelle)<br>
Mémoriser l‘image actuelle au format (png/jpg/svg)<br>
Concentrer la vue sur une voie déterminée, resp. sur la voie d‘un signal ou d‘un aiguillage<br>
Le postionnement est également possible par le programme <a href="EEP_Inventar.html" target="_blank">Inventaire</a>!<br>
Réglage de la largeur des lignes et des textes<br>
Sélection des voies à l‘aide du filtre de hauteur minimale et maximale<br>
Adapter les couleurs des systèmes de voie
</small></p>


<p lang="de">	<!-- Referenzen / verwandte Programme -->
<small><strong>Referenzen / verwandte Programme</strong><br>
Diskussionsbeitrag im <a href="https://www.eepforum.de/forum/thread/26770-eep-gleisplan-im-browser-anzeigen-javascript-projekt" target="_blank">EEP-Forum</a><br>
Entwicklungsprojekt auf <a href="https://github.com/FrankBuchholz/EEP_convert_anl3_file" target="_blank">GitHub</a><br>
Anzeige einer <a href="https://frankbuchholz.github.io/EEP_convert_anl3_file/EEP_Inventar.html" target="_blank">Inventarliste</a> zu einer EEP-Anlage<br>
Übersicht zu den <a href="https://frankbuchholz.github.io/EEP_convert_anl3_file/EEP_Signale.html" target="_blank">Signalstellungen</a> anhand der extrahierten .ini-Dateien zu Signalen (siehe EEP &rarr; Extras &rarr; Ressourcen-Extraktor)</small></p>

<p lang="en">
<small><strong>References / related programs</strong><br>
Thread in the <a href="https://www.eepforum.de/forum/thread/26770-eep-gleisplan-im-browser-anzeigen-javascript-projekt" target="_blank">EEP Forum</a><br>
Development project at <a href="https://github.com/FrankBuchholz/EEP_convert_anl3_file" target="_blank">GitHub</a><br>
Show <a href="https://frankbuchholz.github.io/EEP_convert_anl3_file/EEP_Inventar.html" target="_blank">inventory list</a> of an EEP file<br>
Overview about <a href="https://frankbuchholz.github.io/EEP_convert_anl3_file/EEP_Signale.html" target="_blank">signal positions</a> according to the extracted data from the .ini files of signals (see EEP &rarr; Extras &rarr; Ressourcen-Extraktor)</small></p>

<p lang="fr">
<small><strong>Références / Programmes associés</strong><br>
Discussions dans le <a href="https://www.eepforum.de/forum/thread/26770-eep-gleisplan-im-browser-anzeigen-javascript-projekt" target="_blank">EEP-Forum</a><br>
Projet de développement sur <a href="https://github.com/FrankBuchholz/EEP_convert_anl3_file" target="_blank">GitHub</a><br>
Afficher une <a href="https://frankbuchholz.github.io/EEP_convert_anl3_file/EEP_Inventar.html" target="_blank">liste de l‘inventaire</a> d‘un réseau EEP<br>
Aperçu des <a href="https://frankbuchholz.github.io/EEP_convert_anl3_file/EEP_Signale.html" target="_blank">positions de signaux</a> à l‘aide des données extraites des fichiers *.ini des signaux (voir EEP &rarr; Extras &rarr; Ressourcen-Extraktor)</small></p>


<p lang="de">	<!-- Technische Beschreibung -->
<small><strong>Technische Beschreibung</strong><br>
Dieses Programm nutzt die Javascript-Funktion <a href="https://www.w3schools.com/xml/xml_parser.asp" target="_blank">DOMParser</a> um eine <i>.anl3</i>-Datei von EEP, die aus <a href="https://www.w3schools.com/xml/xml_tree.asp" target="_blank">XML</a> aufgebaut ist, zu interpretieren und in das <a href="https://www.w3schools.com/xml/xml_dom.asp" target="_blank">Document Object Model (DOM)</a> umzuwandeln.<br>
Anschließend wird dynamisch mit Javascript die Graphik des Gleisplanes mit <a href="https://www.w3schools.com/html/html5_svg.asp" target="_blank">SVG</a>-Befehlen aufgebaut. Die Formatierung der graphischen Elemente erfolgt getrennt von der Definition der Graphik mit der SVG-Variante von <a href="https://www.w3schools.com/html/html_css.asp" target="_blank">CSS</a>.<br>
Der Browser kann solche SVG-Graphiken direkt anzeigen. Zusätzlich werden die Bibliotheken <a href="https://github.com/bumbu/svg-pan-zoom" target="_blank">svg-pan-zoom</a> zum Verschieben und Zoomen und <a href="https://github.com/fluffynuts/toolwindow" target="_blank">toolwindow</a> zur Anzeige von Popups verwendet.<br>
Das Programm läuft in aktuellen Versionen von Google Chrome, Firefox oder MS Edge, nicht jedoch im Internet Explorer.</small></p>

<p lang="en">
<small><strong>Technical description</strong><br>
This program uses the Javascript function <a href="https://www.w3schools.com/xml/xml_parser.asp" target="_blank">DOMParser</a> to analyse an <i>.anl3</i> file of EEP,  which contains <a href="https://www.w3schools.com/xml/xml_tree.asp" target="_blank">XML</a> structured data, and to transform it into the <a href="https://www.w3schools.com/xml/xml_dom.asp" target="_blank">Document Object Model (DOM)</a>.<br>
Then it dynamically creates the graphic of the track plan using Javascript using <a href="https://www.w3schools.com/html/html5_svg.asp" target="_blank">SVG</a> commands. The formatting of the graphical elements using the SVG variant of <a href="https://www.w3schools.com/html/html_css.asp" target="_blank">CSS</a> is separated from the definition of the graphic.<br>
The Browser shows such SVG graphics directly. The programs uses the libraries <a href="https://github.com/bumbu/svg-pan-zoom" target="_blank">svg-pan-zoom</a> for pan  and zoom and <a href="https://github.com/fluffynuts/toolwindow" target="_blank">toolwindow</a> to show popup windows.<br>
The program runs with current versions of Google Chrome, Firefox or MS Edge, but not with Internet Explorer.</small></p>

<p lang="fr">
<small><strong>Description technique</strong><br>
Ce programme utilise la fonction javascript <a href="https://www.w3schools.com/xml/xml_parser.asp" target="_blank">DOMParser</a> pour interpréter un fichier <i>.anl3</i> de EEP conçu en <a href="https://www.w3schools.com/xml/xml_tree.asp" target="_blank">XML</a>, pour le transformer au format <a href="https://www.w3schools.com/xml/xml_dom.asp" target="_blank">Document Object Model (DOM)</a>.<br>
Ensuite le graphique du plan de voies est reconstitué dynamiquement en javascript avec des instructions <a href="https://www.w3schools.com/html/html5_svg.asp" target="_blank">SVG</a>. Le formatage des éléments graphiques s‘effectue séparément de la définition du graphique avec la variante SVG de <a href="https://www.w3schools.com/html/html_css.asp" target="_blank">CSS</a>.<br>
Le navigateur est capable d‘afficher directement les graphiques SVG. En plus celui-ci utilise les bibliothèques <a href="https://github.com/bumbu/svg-pan-zoom" target="_blank">svg-pan-zoom</a> pour les déplacements et le zooming, ainsi que <a href="https://github.com/fluffynuts/toolwindow" target="_blank">toolwindow</a> pour visualiser les pop-ups.<br>
Le programme fonctionne correctement avec les versions actuelles de Google Chrome, Firefox et MS Edge. Internet Explorer n‘est plus supporté.</small></p>

</article>

<footer>
<hr>

<p lang="de">
<small>(c) Frank Buchholz, 2021, mit Unterstützung von <a href="https://github.com/campersau" target="_blank">campersau</a> und <a href="https://github.com/EEP-Benny" target="_blank">Benny</a> sowie <a href="https://www.eepforum.de/user/6-michael89/" target="_blank">Michael89</a> (EEP 16 Anlagen), <a href="https://www.eepforum.de/user/3932-messina/" target="_blank">Messina</a> (französische Übersetzung) und <a href="https://www.eepforum.de/user/6783-hstoni54/" target="_blank">HStoni54</a> (Berechnung von Helix-Gleisen)</small></p>

<p lang="en">
<small>(c) Frank Buchholz, 2021, with support by <a href="https://github.com/campersau" target="_blank">campersau</a> and <a href="https://github.com/EEP-Benny" target="_blank">Benny</a> as well as <a href="https://www.eepforum.de/user/6-michael89/" target="_blank">Michael89</a> (EEP 16 track plans), <a href="https://www.eepforum.de/user/3932-messina/" target="_blank">Messina</a> (French translation) and <a href="https://www.eepforum.de/user/6783-hstoni54/" target="_blank">HStoni54</a> (Calculation of helix tracks)</small></p>

<p lang="fr">
<small>(c) Frank Buchholz, 2021, avec le soutien de <a href="https://github.com/campersau" target="_blank">campersau</a> et <a href="https://github.com/EEP-Benny" target="_blank">Benny</a> aussi <a href="https://www.eepforum.de/user/6-michael89/" target="_blank">Michael89</a> (EEP 16 Plan des voies), <a href="https://www.eepforum.de/user/3932-messina/" target="_blank">Messina</a> (traduction en français) et <a href="https://www.eepforum.de/user/6783-hstoni54/" target="_blank">HStoni54</a> (Calcul de voies d'hélice)</small></p>
</footer>

<style> /* Selection screen */
/* <![CDATA[ */
#fileselector {
	margin: 15px;
}
#fileselector span.li {
	display: list-item;
	padding-top: 0.2em;
	margin-left: 2em;
}
/* ]]> */
</style>

<script type="text/javascript" src="js/matrix.js"></script> <!-- Matrix operations optimized for this program -->
<script type="text/javascript" src="js/bezier_curve_arc_length.js"></script> <!-- getArcLength of Bezier Curve -->
<script type="text/javascript" src="js/convexhull.js"></script> <!-- Convex hull algorithm --> 

<script type="text/javascript"> // Load and process file
"use strict";
/* Interface
required standard objects:
	DOMParser
	Event
	FileReader
	Promise
	console 
	document
	localStorage
	requestAnimationFrame
	window
required global data:
	EEP_Texts
required functions:
	_
	SvgPanZoom
	changefontSize
	createSVG
	loadColors
public data:
	global
public api:
	loadFile
*/
(function(api) {
// public api
api.loadFile = loadFile;
// public data
const global = {}; // Collection of all global variables
api.global = global;

function loadFile(file) {
	let fr;	// upvalue for function processFile
	if (typeof window.FileReader !== "function") {
		bodyAppend("p", _("err", "001")); // The file API isn't supported on this browser yet.
		return;
	}

	if (!file) {
		bodyAppend("p", EEP_Texts.getText("err", "002")); // Please select a file before clicking 'Load'
		return;
	} else {
		global.timestamp = {};
		global.timestamp.start = Date.now();

		fr = { FileReader: new FileReader() }; // strict mode does not allow to unset read-only property 'result' directly, therfore we have to put the FileReader into an object
		fr.FileReader.onload = processFile;
		fr.FileReader.readAsText(file);
	}

	// process file (local function to get access to local variable fr)
	function processFile() {
		global.timestamp.fileLoaded = Date.now();
		console.log('load file:' + (global.timestamp.fileLoaded - global.timestamp.start) / 1000 + 'sec');

		updateUi(function() {
			// Hide file selector
			document.getElementById("fileselector").classList.add("hidden");

			// Show loading
			document.getElementById("loading").classList.remove("hidden");
		}).then(function() {
			// Create parser
			const parser = new DOMParser();
			// Parse xml into DOM
			const xmlDoc = parser.parseFromString(fr.FileReader.result, "text/xml");
			//fr.FileReader.result = null; 	// we do not need the file content anymore, but in strict mode we cannot unset the property directly
			delete fr.FileReader;			// however, we can remove the whole thing (see http://perfectionkills.com/understanding-delete/ )

			global.timestamp.fileParsed = Date.now();
			console.log('parse file:' + (global.timestamp.fileParsed - global.timestamp.fileLoaded) / 1000 + 'sec');

			return xmlDoc;
		}).then(function(xmlDoc) {
			let progress = document.getElementById("progress");

			// Process root node (documentElement always represents the root node)
			const sutrackp = xmlDoc.documentElement;
			global.sutrackp = sutrackp;
			return createSVG(sutrackp, initProgress, incrementProgress);

			function initProgress(progressMax) {
				return updateUi(function() {
					progress.max = progressMax;
					progress.value = 0;
					progress.classList.remove("hidden");
				});
			}
			function incrementProgress() {
				return updateUi(function() {
					progress.value++;
				});
			}
		}).then(function() {
			// Hide loading
			document.getElementById("loading").classList.add("hidden");

			// Show main area
			document.getElementById("main").classList.remove("hidden");

			// Show file name
			const filename = file.name.substring(0, file.name.length -1 -1 -3);
			document.getElementById("filename").textContent = filename;
			document.getElementById("svgTitle").textContent = filename;

			// Read settings from localStorage
			const strokeWidth = localStorage.getItem("strokeWidth") || document.getElementById("strokeWidth").value;
			document.getElementById("strokeWidth").value = strokeWidth;
			const fontSize = localStorage.getItem("fontSize") || document.getElementById("fontSize").value;
			document.getElementById("fontSize").value = fontSize;
			// Checkboxes require spectial treatment
			for (let i = 0; i < localStorage.length; i++) {
				const key = localStorage.key(i);
				if (key.indexOf("checkbox_") === 0) { // Read checkbox settings
					const checkbox = document.querySelector(`input[type="checkbox"][name="${key.substring(9)}"]`);
					if (checkbox) {
						const value = localStorage.getItem(key) === "true";
						if (checkbox.checked !== value) {
							checkbox.checked = value;
							checkbox.dispatchEvent(new Event("change"));
						}
					}
				} else {
				}
			}

			loadColors();

			// Activate Pan and Zoom
			global.SvgPanZoom = SvgPanZoom();
			changefontSize(fontSize);
			return;

		}, function(err) {
			// `</pre>` confuses syntax detection within Notepad++, therefore I've to use "</pre>"
			document.getElementById("loading").innerHTML =
				EEP_Texts.getText("err", "003") // Fehler beim Lesen der Datei
				+ `:<br>${err.name}: "${err.message}"`
				+ EEP_Texts.getText("err", "003a") // in line
				+ `${err.lineNumber}<br><pre>${err.stack}` + "</pre>";
			console.log(err);
		});
	}

	// helper method which waits some time to let the browser update the ui
	function updateUi(fn) {
		return new Promise(function(resolve) {
			requestAnimationFrame(function() {
				const result = fn();
				requestAnimationFrame(function() {
					resolve(result);
				});
			});
		});
	}

	function bodyAppend(tagName, innerHTML) {
		var elm = document.createElement(tagName);
		elm.textContent = innerHTML;
		document.body.appendChild(elm);
	}
}	// loadFile
})(this); // end module
</script>

<script type="text/javascript"> // DOM2SVG
"use strict";
/* Interface
required standard objects:
	console
	document
required global data:
	matrix
	global
required functions:
	_
	convexhull
	getKontaktIcon
public api:
	TrackSystemText
	createSVG
	loadStaticTexts
public data:
	GebaeudesammlungText
	GleisDataText
	Gleisart
	TrackSystemCode
	TrackSystemTexts
	WeichenstellungText
	unsichtbar
*/
/* [Access to public data does not work this way.]
(function(api) {
// public api
api.TrackSystemText = TrackSystemText;
api.createSVG = createSVG;
api.loadStaticTexts = loadStaticTexts;
// public data
*/
let GebaeudesammlungText, GleisDataText, Gleisart, TrackSystemCode, TrackSystemTexts, WeichenstellungText, unsichtbar;
/*
api.GebaeudesammlungText = GebaeudesammlungText;
api.GleisDataText = GleisDataText;
api.Gleisart = Gleisart;
api.TrackSystemCode = TrackSystemCode;
api.TrackSystemTexts = TrackSystemTexts;
api.WeichenstellungText = WeichenstellungText;
api.unsichtbar = unsichtbar;
*/

// Process root node (sutrackp)
// EEP: Static texts

function TrackSystemText(GleissystemID) {
	return TrackSystemTexts[global.TrackSystem[GleissystemID]];
}
	
function loadStaticTexts() {

TrackSystemTexts = { 			// per TrackSystemNumber 1-6 (caution: GleissystemID could show other numbers, too) 
	1 : _('Eisenbahn'),
	2 : _('Strassenbahn'),
	3 : _('Strasse'),
	4 : _('Wasserwege'),
	5 : _('Steuerstrecken'),		// nicht in EEP 9
	6 : _('GBS'),					// nicht in EEP 9
};

Gleisart = { 					// clsid
	"2E25C8E2-ADCD-469A-942E-7484556FF932" : _('Normal'),
	"C889EADB-63B5-44A2-AAB9-457424CFF15F" : _('Weiche'),
	"B0818DD8-5DFD-409F-8022-993FD3C90759" : _('3-Weg-Weiche'),
	"06D80C90-4E4B-469B-BFE0-509A573EBC99" : _('Prellbock'),
};

// GleisData
GleisDataText = {
	1	: _('Oberleitung'),
	2	: _('Weichenlaterne verstecken'),
	3	: _('Oberleitung') + ', ' + _('Weichenlaterne verstecken'),
	4	: _('Weichenlaterne rechts'),
	5	: _('Oberleitung') + ', ' + _('Weichenlaterne rechts'),
	8	: _('Weichenlaterne links'),
	9	: _('Oberleitung') + ', ' + _('Weichenlaterne links'),
	16	: _('Weichenlaterne als Immobilie/Straßen-T-Kreuzung'),
	18	: _('Doppelkreuzungsweiche'),
	19	: _('Oberleitung') + ', ' + _('Doppelkreuzungsweiche'),
	20	: _('Straßen-T-Kreuzung'),
};

// Weichenstellung
WeichenstellungText = {
	1 : _('Durchfahrt'),
	2 : _('Abzweig'),
	3 : _('KoAbzweig'),
	5 : _('Spezial'),
};

GebaeudesammlungText = {		// GebaeudesammlungID : Text,
	1 : _('Eisenbahn'),
	2 : _('Strassenbahn'),
	3 : _('Gleisobjekte Straßen'),
	4 : _('Immobilien'),
	5 : _('Landschaftselemente'),
	6 : _('Sonstiges'),			//  (Wasserwege)
};

} // end function loadStaticTexts

TrackSystemCode = { 			// TracksystemID : Code,
	1 : "Eisenbahn",
	2 : "Strassenbahn",
	3 : "Strasse",
	4 : "Wasserwege",
	5 : "Steuerstrecken",			// nicht in EEP 9
	6 : "GBS",						// nicht in EEP 9
};

/* Gleisstile:
http://up.picr.de/33875489iu.pdf
http://bahn.hersacher.de/splinekatalog/spkat_intro.htm
*/
unsichtbar = [			// unsichtbare Gleisstile
17,		// \Gleisstile\Sonstiges\Wasserweg_unsichtbar.3dm
28,		// Gleis
35,		// Straßenbahn
34,		// \Gleisstile\Sonstiges\Wasserweg_unsichtbar.3dm
36,		// \Gleisstile\Strassen\unsichtbar.3dm
562,	// Gleis
1346,	// Gleis
2052,	// \Gleisstile\Gleise\Unsichtbares_Gleis_m_OL_UB3.3dm
3425, 	// \Gleisstile\Strassen\1Spur_unsichtbar_AS3.3dm
5100,	// \Gleisstile\Gleise\Unsichtbar_RB2.3dm
100000,	// Kamerafahrweg
/*
18,		// \Gleisstile\Sonstiges\telegraph.3dm
70,		// \Gleisstile\Sonstiges\Stuetzmauer_Lauscha.3dm
85,		// \Gleisstile\Strassen\Leitplanke.3dm
92,		// \Gleisstile\Gleise\Bahnsteig.3dm
102,	// \Gleisstile\Sonstiges\Gitterzaun.3dm
134,	// \Gleisstile\Gleise\Bahnsteig_KoelnHbf.3dm
184,	// \Gleisstile\Sonstiges\Gelaender.3dm
264,	// \Gleisstile\Gleise\Bahnsteig_Hohenfels.3dm
731,	// \Gleisstile\Gleise\Bhst900_Kreihnsdoerp.3dm
732,	// \Gleisstile\Gleise\Bhst1350_Kreihnsdoerp.def
851,	// \Gleisstile\Sonstiges\851_Gelaender_mit_Stuetze_AF1.3dm
927,	// \Gleisstile\Sonstiges\Schallschutzwand.3dm
1246,	// \Gleisstile\Sonstiges\Sicherheitszaun.3dm
1307,	// \Gleisstile\Sonstiges\Gleis_Abdeckung_C_LW1.3dm
1380,	// \Gleisstile\Sonstiges\Fuehrungsschiene_R_LW1.3dm
1381,	// \Gleisstile\Sonstiges\Nur Fahrdraht_MM_LW1.3dm
1393,	// \Gleisstile\Sonstiges\LW1_Gleis_Fahrdraht_mitte.3dm
1399,	// \Gleisstile\Sonstiges\LW1_Gleis_Fahrdraht_ende.3dm
1401,	// \Gleisstile\Sonstiges\LW1_Gleis_Quertraeger_unten.3dm
1402,	// \Gleisstile\Sonstiges\LW1_Gleis_Quertraeger_oben.3dm
1412,	// \Gleisstile\Sonstiges\LW1_Gleis_Fahrdraht_anf.3dm
1414,	// \Gleisstile\Sonstiges\LW1_Gleis_Fahrdraht_spann.3dm
1445,	// \Gleisstile\Sonstiges\LW1_Gleis_Quertraeger_Stahl_LW1.3dm
1448,	// \Gleisstile\Sonstiges\LW1_Gleis_Quertraeger_leer.3dm
1449,	// \Gleisstile\Sonstiges\LW1_Gleis_Schallschutz_Stuetzmauer_LW1.3dm
1450,	// \Gleisstile\Sonstiges\LW1_Gleis_Spannungsver_A.3dm
1601,	// \Gleisstile\Sonstiges\1601_Gelaender_mit_Stuetze_AF1.3dm
1738,	// \Gleisstile\Sonstiges\Kabelkanal1_MA1.3dm
1958,	// \Gleisstile\Sonstiges\3DVersion\Lattenzaun-3D_SM1.3dm
1959,	// \Gleisstile\Sonstiges\3DVersion\Jaegerzaun-3D_SM1.3dm
1974,	// \Gleisstile\Sonstiges\Steinmauer3_SM1.3dm
1978,	// \Gleisstile\Sonstiges\Arkadenmauer-2gl_SM1.3dm
1979,	// \Gleisstile\Sonstiges\Arkadenmauer-4gl_SM1.3dm
1982,	// \Gleisstile\Sonstiges\3DVersion\Arkadenmauer-einseitig-3D_SM1.3dm
1995,	// \Gleisstile\Sonstiges\Schutzmauer_2_MA1.3dm
2304,	// \Gleisstile\Sonstiges\DB-Gelaender_SB3.3dm
2381,	// \Gleisstile\Sonstiges\DB-Gelaender_10_SB3.3dm
2386,	// \Gleisstile\Sonstiges\Schallschutzwand_grau_SB3.3dm
2387,	// \Gleisstile\Sonstiges\Schallschutzwand_gruen_SB3.3dm
2581,	// \Gleisstile\Sonstiges\BMauer_eben_0_HW1.3dm
5008,	// \Gleisstile\Sonstiges\3DVersion\Sicherheitszaun_mit_Stacheldragt_3D.3dm
5085,	// \Gleisstile\Sonstiges\3DVersion\Hedge_1m_Cypress.3dm
5138,	// \Gleisstile\Sonstiges\3DVersion\ParkHotel_Harz_Zaun.3dm
5145, 5146, 5147, // Farm track
5213,	// \Gleisstile\Sonstiges\3DVersion\Ebrzgl.3dm
5261,	// \Gleisstile\Sonstiges\3DVersion\Schutzplanke_einfach_MA1.3dm
5262,	// \Gleisstile\Sonstiges\3DVersion\Schutzplanke_zweifach_MA1.3dm
5263,	// \Gleisstile\Sonstiges\3DVersion\Schutzplanke_doppel_MA1.3dm
5271,	// \Gleisstile\Sonstiges\IndZaun_Zaun_AE1.3dm
5272,	// \Gleisstile\Sonstiges\IndZaun_Zaun_TT1_AE1.3dm
5274,	// \Gleisstile\Sonstiges\IndZaun_Zaun_TT3_AE1.3dm
5602,	// Fence
7411,	// \Gleisstile\Strassen\Leitpl_3D_mit_Pf_UFS_DH1.3dm
7412,	// \Gleisstile\Sonstiges\Doppel_T_Trg_30x30_blau_DH1.3dm
*/
	];

function createSVG(sutrackp, initProgress, incrementProgress) {
	loadStaticTexts();

	const Gleissysteme = prepareGleissysteme(sutrackp);

	// Append new svg elements to this root node which we append to the svg node later
	const SVGfragment = document.createDocumentFragment();

	return initProgress(Gleissysteme.length).then(function() {
		let promise = null;
		for (const Gleissystem of Gleissysteme) {
			if (promise === null) {
				createSVGforGleissystem(Gleissystem, SVGfragment);
				promise = incrementProgress();
			} else {
				promise = promise.then(function() {
					createSVGforGleissystem(Gleissystem, SVGfragment);
					return incrementProgress();
				});
			}
		}
		return promise;

	}).then(function() {
		createSVGfinalize(SVGfragment);
		return;
	});

function prepareGleissysteme(sutrackp) {

	// Verwendeter Bereich der Anlage
	global.usedArea = {
		min : {x : 0, y : 0, z : 0},
		max : {x : 0, y : 0, z : 0},
	};

	const Version = sutrackp.getElementsByTagName("Version")[0];
	if (Version) {
		global.EEPversion = Version.getAttribute("EEP");
		if (global.EEPversion >= 16) {
			document.getElementById("CheckboxCurveType").classList.remove("hidden");
		}
	}

	// Collections for direct access
	global.Gleissysteme 	= {};	// Verwendung: Gleis = global.Gleissysteme[GleissystemID][GleisID];
	global.Meldungen 		= {};
	global.waitingTrains 	= [], 	// ID (des Zugverbandes), speed
	global.Weichen 			= {};
	global.Kontakte			= {};
	global.KontaktZiele		= {};
	global.EndRouteSignals	= {};	// Start-route-signals of end-route-signals 
	global.KameraSet 		= {};	// Verwendung: Kamera = global.KameraSet[index];
	global.Zugverband 		= {};	// Verwendung: Train = global.Zugverband[GleissystemID][trainName];
	global.Gleisobjekte		= {};
	global.Routen			= {};
	global.Sounds			= {};

	// <Options RouteItems="5" SndId_0="6" SndName_0="ZIEGEN.WAV" SoundItems="1" RouteId_0="1" RouteName_0="Nahverkehr" RouteId_1="2" RouteName_1="Schnellzug" RouteId_2="3" RouteName_2="Gueter" RouteId_3="4" RouteName_3="Nebenbahn" RouteId_4="5" RouteName_4="Sonderzug"/>
	const Options = sutrackp.getElementsByTagName("Options")[0];
	const RouteItems = +Options.getAttribute("RouteItems");
	for (let i = 0; i < RouteItems; i++) {
		const RouteID	= Options.getAttribute("RouteId_" + i);
		const RouteName = Options.getAttribute("RouteName_" + i);

		global.Routen[RouteID] = RouteName;
	}
	const SoundItems 	= +Options.getAttribute("SoundItems");
	for (let i = 0; i < SoundItems; i++) {
		const SoundID 	= Options.getAttribute("SndId_" + i);
		const SoundName = Options.getAttribute("SndName_" + i);

		global.Sounds[SoundID] = SoundName;
	}

	// Preparation: Collect "active" tracks
	const activeTracks = [];		// Gleise, auf denen Züge stehen oder die Kontakte enthalten (Signale werden ignoriert)
									// oder die mit solchen Gleisen verbunden sind
	// Preparation: Collect connected tracks
	const trackConnections = [];	// Gleisverbindungen

	// Preparation: Collect signals on tracks
	const trackSignals = [];		// Vor- und Hauptsignale
	// Start-route-signals of end-route-signals 

	const Gleissysteme 	= sutrackp.getElementsByTagName("Gleissystem");
	for (const Gleissystem of Gleissysteme) {
		// Use both attributes GleissystemID and TrackSystemNumber if available
		let GleissystemID     = Gleissystem.getAttribute('GleissystemID');
		let TrackSystemNumber = Gleissystem.getAttribute('TrackSystemNumber');
		if (GleissystemID && !TrackSystemNumber) {
			TrackSystemNumber = GleissystemID;
		} else if (!GleissystemID && TrackSystemNumber) {
			GleissystemID = TrackSystemNumber;
		}
		
		// Store relationship between GleissystemID and TrackSystemNumber 
		if (!global.TrackSystem) {
			global.TrackSystem = {};
		}
		if (!global.TrackSystem[GleissystemID]) {
			global.TrackSystem[GleissystemID] = TrackSystemNumber;
		}

		global.Gleissysteme[GleissystemID] = {};
		activeTracks[GleissystemID] = [];
		trackSignals[GleissystemID] = [];

		const Gleise 			= Gleissystem.getElementsByTagName("Gleis");
		for (const Gleis of Gleise) {
			const GleisID 	= Gleis.getAttribute("GleisID");
			Gleis.GleissystemID = GleissystemID;
			global.Gleissysteme[GleissystemID][GleisID] = Gleis;

			// Weichen
			const WeicheID = Number(Gleis.getAttribute("Key_Id"));
			if (WeicheID > 0) {
				Gleis.WeicheID = WeicheID;
				global.Weichen[WeicheID] = Gleis;
				//console.log("global.Weichen["+WeicheID+"] on "+GleissystemID+"-"+GleisID)
			}

			// Weichen mit KontaktZiel
			const KontaktZielEntry 	= Gleis.getElementsByTagName("KontaktZiel")[0];
			if (KontaktZielEntry) {
				const KontaktZiel 	= KontaktZielEntry.textContent;
				if (KontaktZiel != null && KontaktZiel != 0) {
					global.KontaktZiele[KontaktZiel] = {
						Typ				: _('Weiche'),	// 1st letter is used to show an svg text.
						ID				: WeicheID,
						GleissystemID 	: GleissystemID,
						GleisID			: GleisID,
					};
				}
			}

			// Collect Meldungen to be able to create individual symbols for Vor- and Hauptsignal
			for (const Meldung of Gleis.getElementsByTagName("Meldung")) {
				const SignalID = Number(Meldung.getAttribute("Key_Id"));
				Meldung.GleissystemID = GleissystemID;
				Meldung.GleisID = GleisID;
				global.Meldungen[SignalID] = Meldung;

				if (!trackSignals[GleissystemID][GleisID]) {
					 trackSignals[GleissystemID][GleisID] = [];
				}
				trackSignals[GleissystemID][GleisID].push({Meldung : Meldung});
				
				// Signale mit wartenden Zügen 
				for (const Wartender of Meldung.getElementsByTagName('Wartender')) {
					const ZugID 		= Wartender.getAttribute('zugverbandID');
					const targetSpeed 	= +Wartender.getAttribute('sollgeschwindigkeit') * 3600 / 1000; // km/h

					global.waitingTrains[ZugID] = {
						SignalID		: SignalID,
						targetSpeed		: targetSpeed,
					};					
				}
				
				// Signale mit KontaktZiel
				const KontaktZielEntry 	= Meldung.getElementsByTagName("KontaktZiel")[0];
				if (KontaktZielEntry) {
					const KontaktZiel 	= KontaktZielEntry.textContent;
					if (KontaktZiel != null && KontaktZiel != 0) {
						global.KontaktZiele[KontaktZiel] = {
							Typ 			: _('Signal'),	// 1st letter is used to show an svg text.
							ID				: SignalID,
							GleissystemID 	: GleissystemID,
							GleisID			: GleisID,
						};
					}
				}
				
				// Signale für Fahrstraßen: Suche Start-Signale zu Ende-Signalen 
				const Routes		= Meldung.getAttribute('Routes');
				const RouteList	 	= Meldung.getElementsByTagName("Route");
				let RoutesText = '';
				for (const Route of RouteList) {
					const Target 	= Route.getAttribute('Target');
					const Color 	= Route.getAttribute('Color');

					if (!global.EndRouteSignals[Target]) {
						global.EndRouteSignals[Target] = []
					}
					global.EndRouteSignals[Target].push({
							StartSignal : SignalID,
							Color : Color,
					})
				}
			}

			// Signale, die nur zur Anzeige dienen und keine Züge beeinflussen sollen werden gerne auf "inaktive" Gleise gesetzt.
			// Alternativ könnte man nicht-verbundene Einzelgleise als "inaktive" interpretieren.
			// A track having a Signal is an "active" track
			/*
			for (const Meldung of Gleis.getElementsByTagName("Meldung")) {
				if (!activeTracks[GleissystemID].includes(GleisID)) {
					 activeTracks[GleissystemID].push(GleisID);
				}
			}
			*/

			// Kontakte
			// A track having a Kontakt is an "active" track
			for (const Kontakt of Gleis.getElementsByTagName("Kontakt")) {
				if (!activeTracks[GleissystemID].includes(GleisID)) {
					 activeTracks[GleissystemID].push(GleisID);
				}
			}
		} // Gleise

		// Gleisverbindungen
		trackConnections[GleissystemID] = [];
		const Gleisverbindungen = Gleissystem.getElementsByTagName("Gleisverbindung");
		for (const Gleisverbindung of Gleisverbindungen) {
			// <Gleisverbindung GleisID1="1" Anschluss1="Anfang" GleisID2="5" Anschluss2="Anfang" Flags="1"/>
			// Verwendung:
			// prevGleisID   		= trackConnections[GleissystemID][GleisID].Anfang.GleisID
			// prevGleisAnschluss 	= trackConnections[GleissystemID][GleisID].Anfang.Anschluss
			// nextGleisID   		= trackConnections[GleissystemID][GleisID].Ende.GleisID
			// nextGleisAnschluss	= trackConnections[GleissystemID][GleisID].Ende.Anschluss
			// ..
			const GleisID1 		= Gleisverbindung.getAttribute("GleisID1");
			const Anschluss1 	= Gleisverbindung.getAttribute("Anschluss1");
			const GleisID2 		= Gleisverbindung.getAttribute("GleisID2");
			const Anschluss2 	= Gleisverbindung.getAttribute("Anschluss2");
			const Flags 		= Gleisverbindung.getAttribute("Flags");		// undefined: normal connection, 1: virtual connection

			// Store relation GleisID1 -> GleisID2
			if (!trackConnections[GleissystemID][GleisID1]) {
				 trackConnections[GleissystemID][GleisID1] = {};
			}
			trackConnections[GleissystemID][GleisID1][Anschluss1] = { GleisID : GleisID2, Anschluss : Anschluss2, Flags : Flags, Direction : 1 };

			// Store relation GleisID2 -> GleisID1
			if (!trackConnections[GleissystemID][GleisID2]) {
				 trackConnections[GleissystemID][GleisID2] = {};
			}
			trackConnections[GleissystemID][GleisID2][Anschluss2] = { GleisID : GleisID1, Anschluss : Anschluss1, Flags : Flags, Direction : 2 };
		}
	}
	// Now we are able to show connections on detail popups
	global.trackConnections = trackConnections;

	// Meldungen analysieren um Fahrstraßen sowie Vor- zu Hauptsignele zu separieren
	for (const GleissystemID in trackSignals) {
		for (const GleisID in trackSignals[GleissystemID]) {
			for (const entry of trackSignals[GleissystemID][GleisID]) {
				if (entry.signalType) { continue; } // we have added the entry during the loop, however, for..of does not process new entries anyway

				let currentGleisID 	= GleisID;	// Let's start with the current track

				const SignalID		= entry.Meldung.getAttribute("Key_Id");
				let   Position		= entry.Meldung.getAttribute("Position") / 100; 	// Wert zwischen 0 und Gleis.Laenge
				let   ParaOderAnti 	= entry.Meldung.getAttribute("ParaOderAnti"); 	//Gleisrichtung: 0 = Ende -> Anfang, 1 = Anfang -> Ende
				const Distanz		= entry.Meldung.getElementsByTagName("Signal")[0].getAttribute("wirkungsdistanz") / 100; // immmer positiv

				const Name 			= entry.Meldung.getAttribute("name"); // Fahrstraßen: name = "system\Route_SignalS.3ds" bzw. "system\Route_SignalZ.3ds"
				const Routes		= entry.Meldung.getAttribute("Routes"); // Fahrstraßen Start: Routes > 0

				// Store signal data
				entry.SignalID		= SignalID;
				entry.Position 		= Position;
				entry.ParaOderAnti 	= ParaOderAnti;

				// Für Fahrstraßen gilt: name="system\Route_SignalS.3ds" für den Start bzw. name="system\Route_SignalZ.3ds" für das Ziel
				// (Außerdem besitzt die Meldung zu Beginn einer Fahrstraße weitere Elemente <Route> usw.
				if (Name === "system\\Route_SignalS.3ds") {
					entry.signalType 	= "FStart";					// Fahrstraße Start
					continue;
				} else if (Name === "system\\Route_SignalZ.3ds") {
					entry.signalType 	= "FZiel";					// Fahrstraße Ziel
					continue;
				} else if (Distanz === 0) {
					entry.signalType 	= "single";					// Einzel-Signal
					continue;
				}

				// Store Vorsignal
				entry.signalType 	= "pre";						// Vorsignal

				// Now we can follow the tracks to find the position of the main signal on the track
				let Gleis 	= global.Gleissysteme[GleissystemID][currentGleisID];	// current track
				let Laenge, near, far;	//###
				if (global.EEPversion && global.EEPversion >= 16) { /* EEP 16 */
					const Interval 	= Gleis.getElementsByTagName("Interval")[0];
					near			= +Interval.getAttribute("near");
					far 			= +Interval.getAttribute("far");
					Laenge	= Math.abs( far - near );
				} else {  /* EEP 15 */
					const Charakteristik = Gleis.getElementsByTagName("Charakteristik")[0];
					Laenge	= +Charakteristik.getAttribute("Laenge") / 100;
				}

				// Do we find the main signal on the same track?
				Position = Position + Distanz * (ParaOderAnti == 1 ? 1 : -1) * (near > far ? -1 : 1);	//###
				if (Position >= 0 && Position <= Laenge) {
					// The main signal is on the same track
					trackSignals[GleissystemID][currentGleisID].push({
						Meldung 		: entry.Meldung,
						SignalID		: SignalID,
						signalType 		: "main",
						Position 		: Position,
						ParaOderAnti	: ParaOderAnti,
					});
					continue;
				}

				if (Position > Laenge) { 					// look forward
					Position	= Position - Laenge;		// remaining position on next track
				} else {									// look backward
					Position	= -Position;				// remaining position on previous track
				}

				// The main signal is on a different track
				while (Position > 0) {
					let nextGleisID, Anschluss;

					if (!trackConnections[GleissystemID][currentGleisID]) { // should not happen
						console.log(`Error: Signal ${SignalID} no connected track for ${TrackSystemText(GleissystemID)} ${currentGleisID}`);
						break;
					}

					if (ParaOderAnti == 1) { // look forward

						if (trackConnections[GleissystemID][currentGleisID].Ende) { 
							nextGleisID		= trackConnections[GleissystemID][currentGleisID].Ende.GleisID;
							Anschluss		= trackConnections[GleissystemID][currentGleisID].Ende.Anschluss;
							ParaOderAnti	= (Anschluss === "Anfang" ? ParaOderAnti : 1-ParaOderAnti);
						
						} else if (trackConnections[GleissystemID][currentGleisID].EndeAbzweig) {  // should not happen
							console.log(`Error: no connected track for ${TrackSystemText(GleissystemID)} ${currentGleisID}.Ende`);
							nextGleisID		= trackConnections[GleissystemID][currentGleisID].EndeAbzweig.GleisID;
							Anschluss		= trackConnections[GleissystemID][currentGleisID].EndeAbzweig.Anschluss;
							ParaOderAnti	= (Anschluss === "Anfang" ? ParaOderAnti : 1-ParaOderAnti);
						
						} else {
							console.log(`Error: no connected track for ${TrackSystemText(GleissystemID)} ${currentGleisID}.EndeAbzweig`);
							break;
						}

					} else {				// look backward

						if (!trackConnections[GleissystemID][currentGleisID].Anfang) { // should not happen
							console.log(`Error: Signal ${SignalID} no connected track for ${TrackSystemText(GleissystemID)} ${currentGleisID}.Anfang`);
							break;
						}

						nextGleisID		= trackConnections[GleissystemID][currentGleisID].Anfang.GleisID;
						Anschluss		= trackConnections[GleissystemID][currentGleisID].Anfang.Anschluss;
						ParaOderAnti	= (Anschluss !== "Anfang" ? ParaOderAnti : 1-ParaOderAnti);
					}

					Gleis 	= global.Gleissysteme[GleissystemID][nextGleisID];
					if (!Gleis) { // should not happen
						console.log(`Error: Signal ${SignalID} no track for ${GleissystemID}-${nextGleisID}`);
						break;
					}

					let Laenge;
					if (global.EEPversion && global.EEPversion >= 16) { /* EEP 16 */
						const Interval 	= Gleis.getElementsByTagName("Interval")[0];
						const near		= +Interval.getAttribute("near");
						const far 		= +Interval.getAttribute("far");
						Laenge	= Math.abs( far - near );
					} else {  /* EEP 15 */
						const Charakteristik = Gleis.getElementsByTagName("Charakteristik")[0];
						Laenge	= +Charakteristik.getAttribute("Laenge") / 100;
					}

					if (Position <= Laenge) {
						// The main signal is on the this track
						if (!trackSignals[GleissystemID][nextGleisID]) {
							 trackSignals[GleissystemID][nextGleisID] = [];
						}
						trackSignals[GleissystemID][nextGleisID].push({
							Meldung 		: entry.Meldung,
							SignalID		: SignalID,
							signalType 		: "main",
							Position 		: (Anschluss === "Anfang" ? Position : Laenge - Position),
							ParaOderAnti	: ParaOderAnti,
						});
						break;

					} else {
						// keep going
						currentGleisID 	= nextGleisID;
						Position 		= Position - Laenge;
					}
				} // while searching for tracks

				// Now we can follow the tracks to find the position of the stop point on the track (duplicate code as above)
				const StopAt 	= entry.Meldung.getElementsByTagName("Signal")[0].getAttribute("StopAt") / 100; // immmer positiv
				if (StopAt > 0) {
					let currentGleisID 	= GleisID;	// Let's start with the current track
					let Position		= entry.Meldung.getAttribute("Position") / 100; 	// Wert zwischen 0 und Gleis.Laenge
					let ParaOderAnti 	= entry.Meldung.getAttribute("ParaOderAnti"); 	//Gleisrichtung: 0 = Ende -> Anfang, 1 = Anfang -> Ende
					let Gleis 	= global.Gleissysteme[GleissystemID][currentGleisID];	// current track
					let Laenge, near, far;	//###
					if (global.EEPversion && global.EEPversion >= 16) { /* EEP 16 */
						const Interval 	= Gleis.getElementsByTagName("Interval")[0];
						near			= +Interval.getAttribute("near");
						far 			= +Interval.getAttribute("far");
						Laenge	= Math.abs( far - near );
					} else {  /* EEP 15 */
						const Charakteristik = Gleis.getElementsByTagName("Charakteristik")[0];
						Laenge	= +Charakteristik.getAttribute("Laenge") / 100;
					}
					// Do we find the stop position on the same track?
					Position = Position + (Distanz - StopAt) * (ParaOderAnti == 1 ? 1 : -1) * (near > far ? -1 : 1);	//###
					if (Position >= 0 && Position <= Laenge) {
						// The stop point is on the same track
						trackSignals[GleissystemID][currentGleisID].push({
							Meldung 		: entry.Meldung,
							SignalID		: SignalID,
							signalType 		: "StopAt",
							Position 		: Position,
							ParaOderAnti	: ParaOderAnti,
						});
						continue;
					}

					if (Position > Laenge) { 					// look forward
						Position	= Position - Laenge;		// remaining position on next track
					} else {									// look backward
						Position	= -Position;				// remaining position on previous track
					}

					// The stop point is on a different track
					while (Position > 0) {
						let nextGleisID, Anschluss;

						if (!trackConnections[GleissystemID][currentGleisID]) { // should not happen
							console.log(`Error: Signal ${SignalID} no connected track for ${TrackSystemText(GleissystemID)} ${currentGleisID}`);
							break;
						}

						if (ParaOderAnti == 1) { // look forward

							if (trackConnections[GleissystemID][currentGleisID].Ende) { 
								nextGleisID		= trackConnections[GleissystemID][currentGleisID].Ende.GleisID;
								Anschluss		= trackConnections[GleissystemID][currentGleisID].Ende.Anschluss;
								ParaOderAnti	= (Anschluss === "Anfang" ? ParaOderAnti : 1-ParaOderAnti);
							
							} else if (trackConnections[GleissystemID][currentGleisID].EndeAbzweig) {  // should not happen
								console.log(`Error: no connected track for ${TrackSystemText(GleissystemID)} ${currentGleisID}.Ende`);
								nextGleisID		= trackConnections[GleissystemID][currentGleisID].EndeAbzweig.GleisID;
								Anschluss		= trackConnections[GleissystemID][currentGleisID].EndeAbzweig.Anschluss;
								ParaOderAnti	= (Anschluss === "Anfang" ? ParaOderAnti : 1-ParaOderAnti);
							
							} else {
								console.log(`Error: no connected track for ${TrackSystemText(GleissystemID)} ${currentGleisID}.EndeAbzweig`);
								break;
							}

						} else {				// look backward

							if (!trackConnections[GleissystemID][currentGleisID].Anfang) { // should not happen
								console.log(`Error: Signal ${SignalID} no connected track for ${TrackSystemText(GleissystemID)} ${currentGleisID}.Anfang`);
								break;
							}

							nextGleisID		= trackConnections[GleissystemID][currentGleisID].Anfang.GleisID;
							Anschluss		= trackConnections[GleissystemID][currentGleisID].Anfang.Anschluss;
							ParaOderAnti	= (Anschluss !== "Anfang" ? ParaOderAnti : 1-ParaOderAnti);
						}

						Gleis 	= global.Gleissysteme[GleissystemID][nextGleisID];
						if (!Gleis) { // should not happen
							console.log(`Error: Signal ${SignalID} no track for ${GleissystemID}-${nextGleisID}`);
							break;
						}

						let Laenge;
						if (global.EEPversion && global.EEPversion >= 16) { /* EEP 16 */
							const Interval 	= Gleis.getElementsByTagName("Interval")[0];
							const near		= +Interval.getAttribute("near");
							const far 		= +Interval.getAttribute("far");
							Laenge	= Math.abs( far - near );
						} else {  /* EEP 15 */
							const Charakteristik = Gleis.getElementsByTagName("Charakteristik")[0];
							Laenge	= +Charakteristik.getAttribute("Laenge") / 100;
						}

						if (Position <= Laenge) {
							// The main signal is on the this track
							if (!trackSignals[GleissystemID][nextGleisID]) {
								 trackSignals[GleissystemID][nextGleisID] = [];
							}
							trackSignals[GleissystemID][nextGleisID].push({
								Meldung 		: entry.Meldung,
								SignalID		: SignalID,
								signalType 		: "StopAt",
								Position 		: (Anschluss === "Anfang" ? Position : Laenge - Position),
								ParaOderAnti	: ParaOderAnti,
							});
							break;

						} else {
							// keep going
							currentGleisID 	= nextGleisID;
							Position 		= Position - Laenge;
						}
					} // while searching for tracks
				}


			} // Signale
		} // Gleise
	} // Gleissysteme

	// Now we are able to show all signals in the svg-output
	global.trackSignals = trackSignals;

	// Analyse Fuhrpark to identify "active" tracks
	const Fuhrpark = sutrackp.getElementsByTagName("Fuhrpark")[0];
	if (Fuhrpark) {
	for (const Zugverband of Fuhrpark.getElementsByTagName("Zugverband")) {
		// <Gleisort gleissystemID="3" gleisID="41" parameter="1177.944" ausrichtung="0"/>
		const Gleisort		= Zugverband.getElementsByTagName("Gleisort")[0];
		const GleissystemID	= Gleisort.getAttribute("gleissystemID");
		const GleisID		= Gleisort.getAttribute("gleisID");

		// A track with a Zugverband is an "active" track
		if (!activeTracks[GleissystemID].includes(GleisID)) {
			 activeTracks[GleissystemID].push(GleisID);
		}
		
		// Store Zugverband (used by blockControl)
		if (!global.Zugverband[GleissystemID]) {
			global.Zugverband[GleissystemID] = {};
		}
		const trainName		= Zugverband.getAttribute("name");

		// Current speed
		const currentSpeed 	= +Zugverband.getAttribute('Geschwindigkeit') * 3600 / 1000;		// km/h
		const lastDir 		= Zugverband.getAttribute('LastDir');	// if currentSpeed is zero: currentSpeed = (lastDir == 1 ? '+0' : '-0')

		// Target speed as long as the train is not influenced by a signal
		let targetSpeed 	= +Zugverband.getAttribute('sollgeschwindigkeit') * 3600 / 1000;	// km/h

		// Target speed for trains which are influenced by a signal
		// <Signal>...<Wartender fuhrparkID="1" zugverbandID="7" sollgeschwindigkeit="11.11111"/>
		const ZugID			= Zugverband.getAttribute('ZugID');
		const waitingTrain 	= global.waitingTrains[ZugID];
		if (waitingTrain && waitingTrain.speed != 0) {
			targetSpeed = waitingTrain.targetSpeed;
		}
		
		const depot			= Zugverband.getAttribute("Hide");

		const position		= Gleisort.getAttribute("parameter") / 100; 	// m
		const direction		= Gleisort.getAttribute("ausrichtung");

		const routeID		= Zugverband.getAttribute("Route");
		const routeName		= global.Routen[routeID] || "";

		global.Zugverband[GleissystemID][trainName] = {
			// train data
			routeName		: routeName,

			currentSpeed	: currentSpeed,
			lastDir			: lastDir,		

			targetSpeed		: targetSpeed,

			// position of train
			GleisID		: GleisID,
			position	: position,
			direction	: direction,
			depot		: depot,
		}
		
	}
	}

	// Lade Kollektor-Einträge, die Gleise miteinander verbinden, z.B. bei bestimmten Drehscheiben
	/* Beispiel:
	<Kollektor id="8">
		<Gleis gleisID="171" gleissystemID="1"/>
		<Gleis gleisID="172" gleissystemID="1"/>
		<Gleis gleisID="173" gleissystemID="1"/>
		...
	</Kollektor>
	*/
	const Gleisobjekte = {};
	let countGleisobjekte = 0;
	const KollektorTracks = {};
	for (const Kollektor of sutrackp.getElementsByTagName("Kollektor")) {
		const KollektorID = Kollektor.getAttribute("id");

		const Dreibein 	= Kollektor.getElementsByTagName("Dreibein")[0];
		const Vektor 	= Dreibein.getElementsByTagName("Vektor")[0];
		const PosZ 		= +Vektor.getAttribute("z") / 100;

		const Kollektors = Kollektor.getElementsByTagName("Gleis");

		for (const Gleis of Kollektors) {
			const GleissystemID = Gleis.getAttribute("gleissystemID");
			const GleisID 		= Gleis.getAttribute("gleisID");

			// First entry of Kollektor
			if (!Gleisobjekte[KollektorID]) {
				countGleisobjekte += 1;
				Gleisobjekte[KollektorID] = {
					GleissystemID 	: GleissystemID,
					PosZ 			: PosZ,
					Gleise 			: [],
				};
			}
			// Store Gleis of Kollektor
			Gleisobjekte[KollektorID].Gleise.push({GleissystemID : GleissystemID, GleisID : GleisID, });

			// connected tracks
			// First entry of Gleissystem
			if (!KollektorTracks[GleissystemID]) {
				KollektorTracks[GleissystemID] = {};
			}
			// New Gleis (we assume that a Gleis is part of exactly 1 Gleisobjekt only)
			KollektorTracks[GleissystemID][GleisID] = [];
			KollektorTracks[GleissystemID][GleisID].KollektorID = KollektorID;
			// connected tracks
			for (const Gleis of Kollektor.getElementsByTagName("Gleis")) {
				const GleissystemID2 = Gleis.getAttribute("gleissystemID");
				const GleisID2 		 = Gleis.getAttribute("gleisID");
				if (GleisID !== GleisID2) {
					KollektorTracks[GleissystemID][GleisID].push({
						GleissystemID : GleissystemID2,
						GleisID : GleisID2,
					});
				}
			}
		}
	}

	// Load Immobilien if there exist Gleisobjekte
	if (countGleisobjekte > 0) { //# How to identity empty objects?
		for (const Gebaeudesammlung of sutrackp.getElementsByTagName("Gebaeudesammlung")) {
			const GebaudesammlungID = Gebaeudesammlung.getAttribute("GebaudesammlungID");
			for (const Immobile of sutrackp.getElementsByTagName("Immobile")) {
				const KollektorID 	= Immobile.getAttribute("kollektorID");
				if (KollektorID) {
					const ImmoIdx 	= Immobile.getAttribute("ImmoIdx");
					const gsbname 	= Immobile.getAttribute("gsbname");

					// Take care of inconsistend data: Immobilie without Kollektor
					if (!Gleisobjekte[KollektorID]) {
						Gleisobjekte[KollektorID] = { Error : 'missing Collector', };
					}

					Gleisobjekte[KollektorID].GebaudesammlungID	= GebaudesammlungID;
					Gleisobjekte[KollektorID].ImmoIdx 			= ImmoIdx;
					Gleisobjekte[KollektorID].gsbname 			= gsbname;
				}
			}
		}
	}
	global.Gleisobjekte = Gleisobjekte;
	global.KollektorTracks = KollektorTracks;

	// Add connected tracks as "active" tracks because they can be reached by trains as well
	for (const GleissystemID in activeTracks) {
		const usedGleiseArray = activeTracks[GleissystemID];

		// Extend "active" tracks
		for (let i = 0; i < usedGleiseArray.length; i++){ // old-fashioned for statement because we need to extend the array within the loop
			const GleisID1 = usedGleiseArray[i];

			// Get connected tracks of "active" tracks
			const connectedTracks = trackConnections[GleissystemID][GleisID1];
			if (connectedTracks) {
				for (const Anschluss in connectedTracks) {
					// Add new connected tracks
					// These tracks will be processed, too
					if (!activeTracks[GleissystemID].includes(connectedTracks[Anschluss].GleisID)) {
						 activeTracks[GleissystemID].push(connectedTracks[Anschluss].GleisID);
					}
				}
			}

			// Get related tracks from Kollektors
			if (KollektorTracks[GleissystemID]) {
				const collectedTracks = KollektorTracks[GleissystemID][GleisID1];
				if (collectedTracks) {
					for (const Gleis of collectedTracks) {
						// Add new connected tracks
						// These tracks will be processed, too
						if (!activeTracks[Gleis.GleissystemID].includes(Gleis.GleisID)) {
							 activeTracks[Gleis.GleissystemID].push(Gleis.GleisID);
						}
					}
				}
			}


		}
	}
	// Now we are able to mark all "active" tracks in the svg-output
	global.activeTracks = activeTracks;

	return Gleissysteme;
} // end function prepareGleissysteme

function createSVGforGleissystem(Gleissystem, SVGfragment) {

	const GleissystemID 	= Gleissystem.getAttribute("GleissystemID");
	
	// Append groups to the root node; append other elements to these group nodes
	const svgGleissystemGroup = svgAppend(SVGfragment, {
		svg_tag	: `g`,
		id		: `${TrackSystemCode[global.TrackSystem[GleissystemID]]}`, // optional
		"class"	: `${TrackSystemCode[global.TrackSystem[GleissystemID]]}`,
	});

	const Gleise = Gleissystem.getElementsByTagName("Gleis");

	// Zeige die Checkbox zum ein-/ausblenden (und andere Elemente) nur dann an, wenn ein Gleissystem auch Gleise enthält
	if (Gleise.length > 0) {
		for (const ele of document.getElementsByClassName(TrackSystemCode[global.TrackSystem[GleissystemID]])) {
			ele.classList.remove("hidden");
		}
	}

	// Process Gleise
	for (const Gleis of Gleise) {

	/* Example:
	<Gleis GleisID="1" clsid="2E25C8E2-ADCD-469A-942E-7484556FF932" data="0" scale="1" ElectSideS="0" ElectSideE="0" stil="1353" gsbname="\Gleisstile\Gleise\Beton2_Sch_C_LW1.3dm" LockEd="0">
		<Dreibein>
			<Vektor x="-12359.88" y="-1854.389" z="30">Pos</Vektor>
			<Vektor x="0.699066" y="-0.715057" z="0">Dir</Vektor>
			<Vektor x="0.715057" y="0.699066" z="0">Nor</Vektor>
			<Vektor x="-0" y="0" z="1">Bin</Vektor>
		</Dreibein>
		<Anfangsfuehrungsverdrehung Wert="0"/>
		<Charakteristik Kruemmung="0" Torsion="0" Fuehrungsverdrehung="-0" Kurve="0" Laenge="2580"/>
	</Gleis>
	*/

	/*
	Das Kordinatensystem von SVG ist gegenüber dem üblichen Koordinatensystem (also auch dem von EEP) an der x-Achse gespiegelt.
	Die Spiegelung ließe sich über CSS einfach zurücknehmen:
	svg { transform: scale(1,-1); }
	Damit würde allerdings auch der Text gespiegelt und müsste daher erneut gespiegelt und verschoben werden.
	Daher werden hier stattdessen bei der Ausgabe alle y-Koordinaten und y-Winkel negativ angegeben (also z.Z. -PosY -DirY -NorY)
	Statt cm soll als Einheit m verwendet werden, daher wird Laenge, Kruemmung, PosX und PosY geeignet skaliert.
	*/

		const GleisID 	= Gleis.getAttribute("GleisID");
		const clsid 	= Gleis.getAttribute("clsid");		// Gleisart
		const stil 		= Gleis.getAttribute("stil");		// Gleisstil
		const gsbname 	= Gleis.getAttribute("gsbname");	// Dateiname
		const Key_Id	= Gleis.getAttribute("Key_Id"); 	// Id einer Weiche
		const GleisData	= Gleis.getAttribute("data"); 		// Bitfeld einer Weiche
															// 1: Oberleitung
															// 18: DKW (Weichen und zentrale Gleise)
															// 16: Zentrale Strecken einer Straßen-T-Kreuzung
															// 20: Weichen einer Straßen-T-Kreuzung

		let CurveType, Laenge, Kruemmung, mMatrix;
		let PosX, PosY, PosZ, DirX, DirY, DirZ, NorX, NorY, NorZ, BinX, BinY, BinZ;
		let near, far;	//###

		if (global.EEPversion && global.EEPversion >= 16) { /* EEP 16 */

			// Common attributes
			const Curve 	= Gleis.getElementsByTagName("Curve")[0];

			const Interval 	= Gleis.getElementsByTagName("Interval")[0];
			near 			= +Interval.getAttribute("near");	//###
			far 			= +Interval.getAttribute("far");	//###
			const Frame		= Gleis.getElementsByTagName("Frame")[0];
			const FramePos	= Frame.getElementsByTagName("Position")[0];
			const FrameDir	= Frame.getElementsByTagName("Vector")[0];
			/* Strange: Sometimes we need to swap Nor and Bin
			which would be a matrix multiplication with
			1 0 0 0
			0 1 0 0
			0 0 0 1
			0 0 1 0
			*/
			const swap = (   Math.abs(+Frame.getElementsByTagName("Vector")[1].getAttribute("dz")) > 0.99
						  && Math.abs(+Frame.getElementsByTagName("Vector")[2].getAttribute("dz")) < 0.01
						  ? true : false);
/*
Neue Anlage_Test_288 - repariert
Swap frame vektor Nor<->Bin for Eisenbahn 215

HSB_Sued
Swap frame vektor Nor<->Bin for Wasserwege 156
Swap frame vektor Nor<->Bin for Wasserwege 164

*/
if (swap) { console.log('Swap frame vektor Nor<->Bin for '
	+ TrackSystemText(GleissystemID) + ' ' + GleisID
);}
			const FrameNor	= Frame.getElementsByTagName("Vector")[(swap ? 2 : 1)];
			const FrameBin	= Frame.getElementsByTagName("Vector")[(swap ? 1 : 2)];

			Laenge	= Math.abs( far - near );

			// Depending on CurveType some adjustments will be done later
			PosX	= +FramePos.getAttribute("x");
			PosY	= +FramePos.getAttribute("y");
			PosZ	= +FramePos.getAttribute("z");

			DirX	= +FrameDir.getAttribute("dx");
			DirY	= +FrameDir.getAttribute("dy");
			DirZ	= +FrameDir.getAttribute("dz");

			NorX	= +FrameNor.getAttribute("dx");
			NorY	= +FrameNor.getAttribute("dy");
			NorZ	= +FrameNor.getAttribute("dz");

			BinX	= +FrameBin.getAttribute("dx");
			BinY	= +FrameBin.getAttribute("dy");
			BinZ	= +FrameBin.getAttribute("dz");

			if (DirX === 0 && DirY === 0 && DirZ === 1 && NorX !== 0 && NorY !== 0 && NorZ === 0) { // wrong order Bin - Dir - Nor
console.log('wrong order Bin - Dir - Nor for '
	+ TrackSystemText(GleissystemID) + ' ' + GleisID
);
				const FrameBin	= Frame.getElementsByTagName("Vector")[0];
				const FrameDir	= Frame.getElementsByTagName("Vector")[1];
				const FrameNor	= Frame.getElementsByTagName("Vector")[2];

				DirX		= +FrameDir.getAttribute("dx");
				DirY		= +FrameDir.getAttribute("dy");
				DirZ		= +FrameDir.getAttribute("dz");

				NorX		= +FrameNor.getAttribute("dx");
				NorY		= +FrameNor.getAttribute("dy");
				NorZ		= +FrameNor.getAttribute("dz");

				BinX		= +FrameBin.getAttribute("dx");
				BinY		= +FrameBin.getAttribute("dy");
				BinZ		= +FrameBin.getAttribute("dz");
			}
/*
if (DirX == NorY ) {
	console.log(TrackSystemText(GleissystemID) + ' ' + GleisID
		+ ' DirX == NorY'
	);
}
if (BinZ == -1 ) {
	console.log(TrackSystemText(GleissystemID) + ' ' + GleisID
		+ ' BinZ == -1'
	);
	//BinZ = 1;
}
*/

			//  	   0     1     2     3     4     5     6     7     8     9     10    11    12    13    14    15
			mMatrix = [DirX, DirY, DirZ, 0,    NorX, NorY, NorZ, 0,    BinX, BinY, BinZ, 0,    PosX, PosY, PosZ, 1 ];

			// Identify CurveType
			const EEPCurve  = Curve.getElementsByTagName("EEPCurve")[0];
			const Line		= Curve.getElementsByTagName("Line")[0];
			const Arc		= Curve.getElementsByTagName("Arc")[0];
			const Helix		= Curve.getElementsByTagName("Helix")[0];
			const Clothoid	= Curve.getElementsByTagName("Clothoid")[0];
			//const Cubic	= Curve.getElementsByTagName("Cubic")[0];			// This catches the first element of Curve.Cubic as well as from Curve.Spline.Cubic 
			const CubicList = Curve.getElementsByTagName("Cubic");				// This catches Curve.Cubic (one entry) as well as Curve.Spline.Cubic (multiple entries) 
			const Spline	= Curve.getElementsByTagName("Spline")[0];
			const Rotator	= Curve.getElementsByTagName("Rotator")[0];
			const RotatorChain	= Curve.getElementsByTagName("RotatorChain")[0];
			const PolygonalChain = Curve.getElementsByTagName("PolygonalChain")[0]; // Available as of EEP 17.1

			// Get track geometry per CurveType
			if (EEPCurve) {	// EEPCurve = Line or Arc
				CurveType 	= 'EEPCurve';
				Kruemmung	= +EEPCurve.getAttribute("Kruemmung") * 100;

				 // assumption: Gleis.Frame does not contain relevant data
				if (Math.abs(+FramePos.getAttribute("x")) > 1 ) {
					console.log(`EEPCurve ${TrackSystemText(GleissystemID)} ${GleisID} has Frame value`);
				}

				const Frame2	= EEPCurve.getElementsByTagName("Frame")[0];
				const Frame2Pos	= Frame2.getElementsByTagName("Position")[0];
				const Frame2Dir	= Frame2.getElementsByTagName("Vector")[0];
				const Frame2Nor	= Frame2.getElementsByTagName("Vector")[1];
				const Frame2Bin	= Frame2.getElementsByTagName("Vector")[2];

				PosX		= +Frame2Pos.getAttribute("x") / 100;
				PosY		= +Frame2Pos.getAttribute("y") / 100;
				PosZ		= +Frame2Pos.getAttribute("z") / 100;

				DirX		= +Frame2Dir.getAttribute("dx");
				DirY		= +Frame2Dir.getAttribute("dy");
				DirZ		= +Frame2Dir.getAttribute("dz");

				NorX		= +Frame2Nor.getAttribute("dx");
				NorY		= +Frame2Nor.getAttribute("dy");
				NorZ		= +Frame2Nor.getAttribute("dz");

				BinX		= +Frame2Bin.getAttribute("dx");
				BinY		= +Frame2Bin.getAttribute("dy");
				BinZ		= +Frame2Bin.getAttribute("dz");

/*
Problematische Gleise:

Makinista_GRAFENBURG 16

<Gleis GleisID="4944" clsid="2E25C8E2-ADCD-469A-942E-7484556FF932" data="0" scale="1" ElectSideS="0" ElectSideE="0" stil="17" gsbname="\Gleisstile\Sonstiges\Wasserweg_unsichtbar.3dm" LockEd="0">
<Frame>
<Position x="4.882813E-04" y="6.103516E-03" z="0"/>
<Vector dx="1" dy="0" dz="0"/>
<Vector dx="0" dy="1" dz="0"/>
<Vector dx="0" dy="0" dz="1"/>
</Frame>
<Interval near="0" far="2.3"/>
<Curve>
<EEPCurve Kruemmung="0" Torsion="0" Fuehrungsverdrehung="-0" Laenge="230" Kurve="0" Anfangsfuehrungsverdrehung="0">
<Frame>
<Position x="-572287.6" y="-28208.7" z="4840"/>
<Vector dx="0" dy="0" dz="1"/>
<Vector dx="-0.7071068" dy="0.7071068" dz="0"/>
<Vector dx="-0.7071068" dy="-0.7071068" dz="0"/>
</Frame>
</EEPCurve>
</Curve>

-> Falsche Reihenfolge von EEPCurve Vector: Bin - Dir - Nor

*/
//if (GleissystemID == "4" && GleisID == "4944") debugger;
//if (GleissystemID == "4" && GleisID == "5817") debugger;
				if (DirX === 0 && DirY === 0 && DirZ === 1 && NorX !== 0 && NorY !== 0 && NorZ === 0) { // wrong order Bin - Dir - Nor
console.log('wrong order Frame2 Bin - Dir - Nor for '
	+ TrackSystemText(GleissystemID) + ' ' + GleisID
);
					const Frame2Bin	= Frame2.getElementsByTagName("Vector")[0];
					const Frame2Dir	= Frame2.getElementsByTagName("Vector")[1];
					const Frame2Nor	= Frame2.getElementsByTagName("Vector")[2];

					DirX		= +Frame2Dir.getAttribute("dx");
					DirY		= +Frame2Dir.getAttribute("dy");
					DirZ		= +Frame2Dir.getAttribute("dz");

					NorX		= +Frame2Nor.getAttribute("dx");
					NorY		= +Frame2Nor.getAttribute("dy");
					NorZ		= +Frame2Nor.getAttribute("dz");

					BinX		= +Frame2Bin.getAttribute("dx");
					BinY		= +Frame2Bin.getAttribute("dy");
					BinZ		= +Frame2Bin.getAttribute("dz");
				}

				//  	   0     1     2     3     4     5     6     7     8     9     10    11    12    13    14    15
				mMatrix = [DirX, DirY, DirZ, 0,    NorX, NorY, NorZ, 0,    BinX, BinY, BinZ, 0,    PosX, PosY, PosZ, 1 ];

			} else if (Line) {
				CurveType 	= 'Line';
				Kruemmung	= 0;

				/* The line geometry is partly stored in <Gleis><Frame> as well as in
				<Line><VectorBundle><Position> 		Position of parameter s=0
				<Line><VectorBundle><Vector>   		.. and tangent of the line.
				<Line><Vector>						Up direction (always 0 0 1?)
				*/

				const Position	= Line.getElementsByTagName("VectorBundle")[0].getElementsByTagName("Position")[0];
				const Tangent	= Line.getElementsByTagName("VectorBundle")[0].getElementsByTagName("Vector")[0];
				const UpDirection = Line.getElementsByTagName("Vector")[1];	// Caution: getElementsByTagName searches in all decendant elements!
																			// Vector[0] is the vector within VectorBundle
/* Try this from https://stackoverflow.com/questions/1241525/java-element-getelementsbytagname-restrict-to-top-level/18090152
function getChildrenByTagName(parent, name) {
var nodeList = [];
for (var child = parent.firstChild; child != null; child = child.nextSibling) {
if (child.nodeType == 1 && name == child.nodeName) {
	nodeList.push(child);
}
}
return nodeList;
}
*/
				const PosX2		= +Position.getAttribute("x");		// dX
				const PosY2		= +Position.getAttribute("y");		// dY
				const PosZ2		= +Position.getAttribute("z");		// dZ

				const DirX2		= +Tangent.getAttribute("dx");		// cos(a)
				const DirY2		= +Tangent.getAttribute("dy");		// -sin(a)
				const DirZ2		= +Tangent.getAttribute("dz");		// ?

				const NorX2		= -DirY2;							// sin(a)
				const NorY2		= DirX2;  							// cos(a)
				const NorZ2		= 0;								// ?

				const BinX2		= +UpDirection.getAttribute("dx");
				const BinY2		= +UpDirection.getAttribute("dy");
				const BinZ2		= +UpDirection.getAttribute("dz");

// Special tracks
//if (GleissystemID == "3" && GleisID == "349") debugger;	// <Interval near="99.99991" far="0"/>
//if (GleissystemID == "3" && GleisID == "354") debugger;	// <Interval near="40.00005" far="0"/>; ist: 1728 -1805 soll: 1730 -1812 diff: +2 -7
//if (GleissystemID == "3" && GleisID == "362") debugger;	// <Interval near="59.9999" far="0"/>

				mMatrix = [
							mMatrix,
							[DirX2, DirY2, DirZ2, 0, NorX2, NorY2, NorZ2, 0, BinX2, BinY2, BinZ2, 0, PosX2, PosY2, PosZ2, 1 ],  // 321 354 ok
						  ].reduce(matrix.multiply);


			} else if (Arc) {
				CurveType 	= 'Arc';

				// relative position of center point of the Arc
				const Pos 	= Arc.getElementsByTagName("VectorBundle2")[0].getElementsByTagName("Position")[0];
				const PosX2 = +Pos.getAttribute("x");
				const PosY2 = +Pos.getAttribute("y");
				const PosZ2 = +Pos.getAttribute("z");

				// Tangent (= normalized direction vector with dx^2 + dy^2 + dz^2 = 1)
				const Dir 	= Arc.getElementsByTagName("VectorBundle2")[0].getElementsByTagName("Vector")[0];
				const DirX2 = +Dir.getAttribute("dx");
				const DirY2 = +Dir.getAttribute("dy");
				const DirZ2 = +Dir.getAttribute("dz");

				// The distance of the center point = curve radius is the length of the second vector
				const Nor 	= Arc.getElementsByTagName("VectorBundle2")[0].getElementsByTagName("Vector")[1];
				const CenterX2 = +Nor.getAttribute("dx");
				const CenterY2 = +Nor.getAttribute("dy");
				const CenterZ2 = +Nor.getAttribute("dz");

				const Radius = Math.sqrt(CenterX2*CenterX2 + CenterY2*CenterY2 + CenterZ2*CenterZ2)	// The curve radius is the length of the second vector
								 * (DirX2 >= 0 ? 1 : -1) * (CenterY2 >= 0 ? 1 : -1);				// Adjustment according to quadrant (1, 3 counter clockwise; 2, 4 clock wise)
				Kruemmung = 1 / Radius;
				
				// Rotate with tangent of circle defined by DirX, DirY
				const tangentAngle = ( DirX2 === 1 && DirY2 === 0 ? 0 : Math.atan2(DirY2, DirX2) );	// skip 0° Rotation

				// Rotate curve around center with angle defined by near
				// (Move point to origin, rotate, move point back)
				const startAngle = Math.min( near, far ) / Radius; 

				mMatrix = [
						mMatrix,
						matrix.translate(PosX2, PosY2, PosZ2),					// Relative position of center point of the Arc
						matrix.translate(- CenterX2, - CenterY2, - CenterZ2),	// Translate by distance of mid point of circle
						matrix.rotateZ( tangentAngle ),							// Rotate with tangent of circle
						[
							matrix.translate(+ CenterX2, + CenterY2, + CenterZ2),	// Translate center of circle
							matrix.rotateZ( startAngle ),							// Rotate with angle defined by starting point
							matrix.translate(- CenterX2, - CenterY2, - CenterZ2),	// Undo translate center point of circle
						].reduce(matrix.multiply),
					].reduce(matrix.multiply);

/* Special tracks
if (GleissystemID == "4" && GleisID == "52") debugger;
if (GleissystemID == "3" && GleisID == "351") debugger;	// <Interval near="26.99997" far="0"/>
if (GleissystemID == "3" && GleisID == "358") debugger;	//
if (GleissystemID == "3" && GleisID == "360") debugger;	// <Interval near="99.66833" far="0"/>
if (GleissystemID == "4" && GleisID == "156") debugger;	// <Interval near="99.66833" far="0"/>

Anlage "fehlerhaft_TM"
Eisenbahn 1	Arc	Länge: 47m	Anfang: 3	Ende: 4		Abzweigung: 28		near="70.18061" far="23.53859"
Eisenbahn 2	Arc	Länge: 46m	Anfang: 5	Ende: 27	Abzweigung: 29		near="68.94401" far="23.07648"
Eisenbahn 3	Arc	Länge: 70m	Anfang: 1									near="0"        far="70.18061"
*/

			} else if (Helix) {
				CurveType 	= 'Helix';

				// relative position of center point of the Helix
				const Pos2 	= Helix.getElementsByTagName("VectorBundle2")[0].getElementsByTagName("Position")[0];
				const PosX2 = +Pos2.getAttribute("x");
				const PosY2 = +Pos2.getAttribute("y");
				const PosZ2 = +Pos2.getAttribute("z");

				// Tangent (= normalized direction vector with dx^2 + dy^2 + dz^2 = 1)
				const Dir2 	= Helix.getElementsByTagName("VectorBundle2")[0].getElementsByTagName("Vector")[0];
				const DirX2 = +Dir2.getAttribute("dx");
				const DirY2 = +Dir2.getAttribute("dy");
				const DirZ2 = +Dir2.getAttribute("dz");

				// Normal (= normalized direction vector with dx^2 + dy^2 + dz^2 = 1)
				const Nor2 	= Helix.getElementsByTagName("VectorBundle2")[0].getElementsByTagName("Vector")[1];
				const NorX2 = +Nor2.getAttribute("dx");
				const NorY2 = +Nor2.getAttribute("dy");
				const NorZ2 = +Nor2.getAttribute("dz");

				// Radius and height per circle
				const a = +Helix.getAttribute("a");			// Radius (= offset) in x direction
				const b = +Helix.getAttribute("b");			// height per circle in z direction

				// Analyzed and developed by HStoni54, https://www.eepforum.de/user/6783-hstoni54/

				// Frame (= mMatrix)
				const mFrame = [			DirX,  DirY,  DirZ,  0,
											NorX,  NorY,  NorZ,  0,
											BinX,  BinY,  BinZ,  0,
											PosX,  PosY,  PosZ,  1,	];

				// VectorBundle2
				const mVectorBundle2 = [	DirX2, DirY2, DirZ2, 0,
											NorX2, NorY2, NorZ2, 0,
											0,     0,     1,     0,
											PosX2, PosY2, PosZ2, 1,	];

				// Orientation forward/backward
				const mOrientation = matrix.scale(1, (far > near ? 1 : -1), 1); //### Not correct yet: position ok, direction wrong 							

				// Helix

				// Rotation of point on helix related to start point (0° at start point = Identity)
				/*
				//const s 	= Math.atan(b/a); // better use atan2 to get the orientation automatically
				const s 	= Math.atan2(b, a);
				const w0 	= Math.cos(s);
				const w     = (-near) 		/ a * w0;
				const wMid	= (far-near)/2 / a * w0;
				const wEnd	= (far) 		/ a * w0;
				const dh 	= b * w; // * (DirX2 * NorY2 >= 0 ? 1 : -1);
				*/
				const r    = Math.sqrt(a*a + b*b);
				const wPos = (-near)		/ r;
				const wMid = (far-near)/2 	/ r;
				const wEnd = (far) 			/ r;

				// mPos
				mMatrix = [
							mFrame,
							mVectorBundle2,
							mOrientation,
							matrix.rotateZ(wPos),
							matrix.translate(a, 0, b*wPos),
							matrix.swapXY(),		// swap x/y and mirror at x axis because of upside-down orientation in SVG
						  ].reduce(matrix.multiply);
				const mPos = mMatrix;
				const mMid = [
							mFrame,
							mVectorBundle2,
							mOrientation,
							matrix.rotateZ(wMid),
							matrix.translate(a, 0, b*wPos),
							matrix.swapXY(),		// swap x/y and mirror at x axis because of upside-down orientation in SVG
						  ].reduce(matrix.multiply);
				const mEnd = [
							mFrame,
							mVectorBundle2,
							mOrientation,
							matrix.rotateZ(wEnd),
							matrix.translate(a, 0, b*wPos),
							matrix.swapXY(),		// swap x/y and mirror at x axis because of upside-down orientation in SVG
						  ].reduce(matrix.multiply);

				const Radius = a;
				Kruemmung 	= 1 / Radius;

				// Compare the endpoint of primitive projection of an Arc with the endpoint of the Helix
				// If the difference is small use the Arc, otherwise use a Cubic to interpolate the Helix

				const posX = 12, posY = 13, posZ = 14; // Index in mMatrix

				const Winkel 	= Kruemmung * Laenge;
				const DeltaX	= Math.sin(Winkel) * Radius;
				const DeltaY 	= (1 - Math.cos(Winkel)) * Radius;
				const DeltaZ	= 0;
				const d1		= Math.sqrt(DeltaX*DeltaX + DeltaY*DeltaY + DeltaZ*DeltaZ);
				const d2		= Math.sqrt(	  (mEnd[posX]-mPos[posX]) * (mEnd[posX]-mPos[posX])
												+ (mEnd[posY]-mPos[posY]) * (mEnd[posY]-mPos[posY])
												+ (mEnd[posZ]-mPos[posZ]) * (mEnd[posZ]-mPos[posZ])
												);
				const dDiff		= Math.abs(d1-d2);
				if (dDiff > 1) {	// difference is too large, go für Cubic interpolation
console.log("Helix Vergleich\t" + TrackSystemText(GleissystemID) + " " + GleisID
	+ "\tDelta:\t" + d1 + "\t" + d2 + "\t" + dDiff
);
					/* Interpolate Helix with Cubic:
					Analyzed and developed by HStoni54, https://www.eepforum.de/user/6783-hstoni54/

					f = |far - near| / 2 / sqrt(a^2 + b^2)
					B1 = mPos
					B2 = mPos * translate3d(a*f,  0,  b*f)
					B3 = mEnd * translate3d(-a*f, 0, -b*f)
					B4 = mEnd
					*/

					const f = Math.abs(far - near) / 2 / Math.sqrt(a*a + b*b);	// f = Math.abs(wMid);
					const mB1 = mPos;
					const mB2 = matrix.multiply(mPos, matrix.translate( a*f, 0,  b*f) );
					const mB3 = matrix.multiply(mEnd, matrix.translate(-a*f, 0, -b*f) );
					const mB4 = mEnd;

					// hack to split the result into absolute coordinates for the start point and relative coordinates for the bezier points
					mMatrix = matrix.translate(mPos[posX], mPos[posY], mPos[posZ]);
					Gleis.BezierPoints = []; // We need just one segment
					Gleis.BezierPoints[0] = [	
												[mB1[posX] - mPos[posX], mB1[posY] - mPos[posY], mB1[posZ] - mPos[posZ]],
												[mB2[posX] - mPos[posX], mB2[posY] - mPos[posY], mB2[posZ] - mPos[posZ]],
												[mB3[posX] - mPos[posX], mB3[posY] - mPos[posY], mB3[posZ] - mPos[posZ]],
												[mB4[posX] - mPos[posX], mB4[posY] - mPos[posY], mB4[posZ] - mPos[posZ]],
												getArcLength( 
																[mB1[posX] - mPos[posX], mB2[posX] - mPos[posX], mB3[posX] - mPos[posX], mB4[posX] - mPos[posX]], 
																[mB1[posY] - mPos[posY], mB2[posY] - mPos[posY], mB3[posY] - mPos[posY], mB4[posY] - mPos[posY]]
															),
											];

				}

console.log( 
      "\t" + CurveType 
	+ "\t" + GleisID
	+ "\tPos\t" + mPos[12] + "\t" + mPos[13]+ "\t" + mPos[14]
	+ "\tMid\t" + mMid[12] + "\t" + mMid[13]+ "\t" + mMid[14]
	+ "\tEnd\t" + mEnd[12] + "\t" + mEnd[13]+ "\t" + mEnd[14]
	+ "\tRadius\t" + a // Radius 
	+ "\tHeight\t" + b // Height
	+ "\tr\t" + r // Math.sqrt(a*a + b*b) 
)

				Gleis.Helix = {	// Store Helix parameters
					a: 		a,
					b: 		b,
					mPos:	mPos,
					mMid:	mMid,
					mEnd:	mEnd,
				};

// Error: wrong positions of Helix
/*
if ( 1 === 1
// generic
||	((PosX2 != 0 || PosY2 != 0) && (DirX2 != 1 || DirY2 != 0))
// Makinista_GRAFENBURG 16
||	(GleissystemID == "1" && GleisID == "5675"	)
||	(GleissystemID == "1" && GleisID == "5902"	)
||	(GleissystemID == "1" && GleisID == "5935"	)
||	(GleissystemID == "1" && GleisID == "6096"	)
||	(GleissystemID == "2" && GleisID == "888"	)
||	(GleissystemID == "2" && GleisID == "970"	)
||	(GleissystemID == "3" && GleisID == "4065"	)
||	(GleissystemID == "3" && GleisID == "5011"	)
||	(GleissystemID == "3" && GleisID == "5027"	)
||	(GleissystemID == "3" && GleisID == "5649"	)
||	(GleissystemID == "3" && GleisID == "5650"	)
||	(GleissystemID == "4" && GleisID == "3170"	)
||	(GleissystemID == "4" && GleisID == "5627"	)
||	(GleissystemID == "4" && GleisID == "6049"	)
||	(GleissystemID == "4" && GleisID == "6051"	)
||	(GleissystemID == "4" && GleisID == "6056"	)
||	(GleissystemID == "4" && GleisID == "6057"	)
||	(GleissystemID == "4" && GleisID == "6059"	)
||	(GleissystemID == "4" && GleisID == "6060"	)
||	(GleissystemID == "4" && GleisID == "6072"	)
// Gleismauerbau
||	(GleissystemID == "1" && GleisID == "687"	)
// Nouveau projet 18a
||	(GleissystemID == "1" && GleisID == "54"	)
||	(GleissystemID == "1" && GleisID == "55"	)
||	(GleissystemID == "1" && GleisID == "70"	)
||	(GleissystemID == "3" && GleisID == "87"	)
||	(GleissystemID == "3" && GleisID == "290"	)
||	(GleissystemID == "3" && GleisID == "546"	)
||	(GleissystemID == "3" && GleisID == "557"	)
||	(GleissystemID == "3" && GleisID == "559"	)
||	(GleissystemID == "3" && GleisID == "568"	)
||	(GleissystemID == "3" && GleisID == "573"	)
||	(GleissystemID == "3" && GleisID == "592"	)
){
	console.log('\t' + TrackSystemText(GleissystemID) + '\t' + GleisID
		+ '\t'
		+ '\tPos\t'  + PosX  + '\t' + PosY  + '\t' + PosZ
		+ '\tDir\t'  + DirX  + '\t' + DirY  + '\t' + DirZ
		+ '\tNor\t'  + NorX  + '\t' + NorY  + '\t' + NorZ
		+ '\tBin\t'  + BinX  + '\t' + BinY  + '\t' + BinZ
		+ '\ta\t' + a
		+ '\tb\t' + b
		+ '\tPos2\t' + PosX2 + '\t' + PosY2 + '\t' + PosZ2
		+ '\tDir2\t' + DirX2 + '\t' + DirY2 + '\t' + DirZ2
		+ '\tNor2\t' + NorX2 + '\t' + NorY2 + '\t' + NorZ2
	);
}
*/

			} else if (Clothoid) {
				CurveType 	= 'Clothoid';

/*
Curve parameter:
k = 1/r

k(s) = s/a^2
s = a^2*k(s)

r(s) = a^2/s 				für s != 0
s = a^2/r(s)
a^2 = s*r(s)

L = s2 - s1
L = a^2/r2 - a^2/r1
L = a^2(k2-k1)

Curve characteristic:
a^2 = L/(k2-k1)
a^2 = L*r1*r2/(r1-r2)

Clothoid.anl3
																a2 = a^2 	near	far		nor.y	bin.z
Id 1: From radius k1=0m 	to radius r2=100m	length 	l=60m 	a2=6000 	near=0 	far=60	1		1
Id 2: From radius k1=0m 	to radius r2=50m 	length 	l=60m 	a2=3000 	near=0 	far=60	1		1
Id 3: From radius r1=100m 	to radius r2=50m 	length 	l=60m 	a2=6000 	near=60 far=120	1		1
Id 4: From radius r1=50m 	to radius k2=0m		length 	l=60m 	a2=3000 	near=60 far=0	-1		-1
Id 5: From radius r1=50m 	to radius k2=0m		length 	l=60m 	a2=3000 	near=0 	far=60	1		1

How to calculate [x(s), y(s)] ?
https://link.springer.com/article/10.1007/s12544-013-0119-8
*/

				const a2 		= +Clothoid.getAttribute("a2");		// not used anymore, replaced by "a"
				const a 		= (a2 ? Math.sqrt(a2) : +Clothoid.getAttribute("a") );

				//const l		= far - near;	// Laenge
				//const k1		= near / a**2;	// Krümmung am Startpunkt
				//const k2		= far / a**2;	// Krümmung am Endpunkt

				//const r1		= (k1 != 0 ? 1 / k1 : 0);	// Radius am Anfangspunkt
				//const r2		= (k2 != 0 ? 1 / k2 : 0);	// Radius am Endpunkt

				Gleis.Clothoid = {
					A: 				a,
					L1: 			near,
					L2: 			far,
					RotationCCW: 	-1,
				};

			} else if (CubicList[0]) {	// Cubic or Spline
				if (Spline) {
					CurveType 	= 'Spline';
				} else {
					CurveType 	= 'Cubic';
				}
				// How to map the Bezier vector [a b c d] to the Bezier points B1 B2 B3 B4?
				// https://developer.mozilla.org/de/docs/Web/SVG/Tutorial/Pfade#Bezier-Kurven
				// http://blogs.sitepointstatic.com/examples/tech/svg-curves/cubic-curve.html
				// https://pomax.github.io/bezierinfo/
				// https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-837-computer-graphics-fall-2012/lecture-notes/MIT6_837F12_Lec01.pdf

/*
Pattern A:
	<Frame>
		<Position 		x="0" 				y="0" 				z="0"/>
		<Vector 		dx="1" 				dy="0" 				dz="0"/>
		<Vector 		dx="0" 				dy="1" 				dz="0"/>
		<Vector 		dx="0" 				dy="0" 				dz="1"/>
	</Frame>
	<Interval near="0" far="7.290804"/>
	<Curve>
		<Cubic>
			<Position 	x="-308.2468" 		y="1647.528" 		z="234.1985"/>
			<Vector 	dx="-4.936119" 		dy="4.789839" 		dz="-0.4930255"/>
			<Vector 	dx="-0.2395048" 	dy="3.452314" 		dz="1.185636"/>
			<Vector 	dx="2.73141" 		dy="-1.794522" 		dz="-0.6260821"/>
		</Cubic>
	</Curve>
Strasse
Rotator	393	Anfang	-301	-1643	Ende	-308	-1645
Cubic	20
Arc		392	Anfang	-310	-1656	Ende	-311	-1654

Cubic 390

Pattern B:
	<Frame>
		<Position 		x="1546.876" 		y="-1850.316" 		z="12.383"/>
		<Vector 		dx="-0.9830491" 	dy="0.1833427" 		dz="1.704315E-05"/>
		<Vector 		dx="-0.1833427" 	dy="-0.9830491" 	dz="1.721977E-07"/>
		<Vector 		dx="1.678582E-05" 	dy="-2.955457E-06" 	dz="1"/>
	</Frame>
	<Interval near="0" far="84.4156"/>
	<Curve>
		<Cubic>
			<Position 	x="0" 				y="0" 				z="0"/>
			<Vector 	dx="84.86435" 		dy="0" 				dz="0"/>
			<Vector 	dx="1.134216" 		dy="-14.52291" 		dz="-3.315334E-05"/>
			<Vector 	dx="-2.8041" 		dy="1.988125" 		dz="-4.251127E-04"/>
		</Cubic>
	</Curve>

Strasse
Arc 	346	x	1691.981	y	-1825.882	z	12.382	Length	65.57804
Cubic	347	x	1630.569	y	-1848.626	z	12.382	Length	84.41406
Cubic	348	x	1546.876	y	-1850.316	z	12.383	Length	84.41560
Arc 	215	x	1467.390	y	-1822.741	z	12.384

*/

			
/* A "Spline" is a series of Cubic tracks

<Gleis ...
	<Frame>
		<Position 			x="-6.598236" 	y="52.4" 		z="0.3"/>
		<Vector 			dx="1" 			dy="0" 			dz="0"/>
		<Vector 			dx="0" 			dy="1" 			dz="0"/>
		<Vector 			dx="0" 			dy="0" 			dz="1"/>
	</Frame>
	<Interval near="0" far="66.98232"/>
	<Curve>
		<Spline>
			<Cubic>
				<Position 	x="0" 			y="0" 			z="0"/>
				<Vector 	dx="12.3316" 	dy="0" 			dz="0"/>
				<Vector 	dx="-3.862404" 	dy="5.308939" 	dz="0"/>
				<Vector 	dx="2.008226" 	dy="-2.913866" 	dz="0"/>
			</Cubic>
			<Cubic>
				<Position 	x="10.47742" 	y="2.395073" 	z="0"/>
				<Vector 	dx="10.63147" 	dy="1.876281" 	dz="0"/>
				<Vector 	dx="10.73391" 	dy="-7.958102" 	dz="-5.722046E-08"/>
				<Vector 	dx="-8.044571" 	dy="7.886748" 	dz="3.814697E-08"/>
			</Cubic>
			<Cubic>
				<Position 	x="23.79824" 	y="4.2" 		z="-1.907349E-08"/>
				<Vector 	dx="7.965585" 	dy="9.62032" 	dz="0"/>
				<Vector 	dx="-20.69972" 	dy="11.5925" 	dz="0"/>
				<Vector 	dx="12.33414" 	dy="-7.412821" 	dz="0"/>
			</Cubic>
			<Cubic>
				<Position 	x="23.39824" 	y="18" 			z="-1.907349E-08"/>
				<Vector 	dx="3.568552" 	dy="10.56686" 	dz="0"/>
				<Vector 	dx="5.751632" 	dy="-2.380146" 	dz="5.722046E-08"/>
				<Vector 	dx="-1.649505" 	dy="-0.4574642" dz="-3.814697E-08"/>
			</Cubic>
			<Cubic>
				<Position 	x="31.06892" 	y="25.72925" 	z="0"/>
				<Vector 	dx="10.1233" 	dy="4.434174" 	dz="0"/>
				<Vector 	dx="12.86992" 	dy="3.519638" 	dz="-5.722046E-08"/>
				<Vector 	dx="-6.463902" 	dy="-5.083059" 	dz="3.814697E-08"/>
			</Cubic>
		</Spline>
	</Curve>
</Gleis>

*/				
				
				Gleis.BezierPoints = [];
				
				//for (Cubic of CubicList) {
				for (let Index = 0; Index < CubicList.length; Index++) {
				const Cubic = CubicList[Index];

				// If Frame.Position = 0 and first Cubic.Position <> 0 then treat this Cubic.Position as the starting point of the curve
				const PositionA	= Cubic.getElementsByTagName("Position")[0];
				let pX			= +PositionA.getAttribute("x");
				let pY			= +PositionA.getAttribute("y");
				let pZ			= +PositionA.getAttribute("z");
				
				if (Index == 0 
					//&& PosX == 0 && PosY == 0 && PosZ == 0 // some Cubic show non-zero values
				) {
					if (pX != 0 || pY != 0 || pZ != 0) {
console.log( TrackSystemText(GleissystemID) + "-" + GleisID 
	+ "\tCubic Pos=0"
	+ "\t" + pX + "\t" + pY
)
						mMatrix = [
								mMatrix,
								matrix.translate(pX, pY, pZ),
							].reduce(matrix.multiply);
						pX = 0; pY = 0; pZ = 0;	
					}
				}

				// The Cubic element stores the canonical monomial basis values of the bezier curve
				// The values of Cubic.Vector are relative to the starting point.
				// Therefore we define a=0 and use the Cubic.Vector for b, c, d.
				const VectorB	= Cubic.getElementsByTagName("Vector")[0];
				const VectorC	= Cubic.getElementsByTagName("Vector")[1];
				const VectorD	= Cubic.getElementsByTagName("Vector")[2];

				const aX		= pX;
				const aY		= pY;
				const aZ		= pZ;
				const bX		= +VectorB.getAttribute("dx");
				const bY		= +VectorB.getAttribute("dy");
				const bZ		= +VectorB.getAttribute("dz");
				const cX		= +VectorC.getAttribute("dx");
				const cY		= +VectorC.getAttribute("dy");
				const cZ		= +VectorC.getAttribute("dz");
				const dX		= +VectorD.getAttribute("dx");
				const dY		= +VectorD.getAttribute("dy");
				const dZ		= +VectorD.getAttribute("dz");

				/* Bezier points
				Multipy the Bezier vector [a b c d] with the matrix
				1  1   1  1
				0 1/3 2/3 1
				0  0  1/3 1
				0  0   0  1
				to get the coordinates of the Bezier points B1 B2 B3 B4.
				*/
				const B1X 		= aX;
				const B1Y 		= aY;
				const B1Z 		= aZ;
				
				const B2X 		= aX + bX/3;
				const B2Y 		= aY + bY/3;
				const B2Z 		= aZ + bZ/3;
				
				const B3X 		= aX + bX*2/3 + cX/3;
				const B3Y 		= aY + bY*2/3 + cY/3;
				const B3Z 		= aZ + bZ*2/3 + cZ/3;
				
				const B4X 		= aX + bX     + cX   + dX;
				const B4Y 		= aY + bY     + cY   + dY;
				const B4Z 		= aZ + bZ     + cZ   + dZ;

				// Calculate length of bezier segment
				// Source: http://bl.ocks.org/hnakamur/e7efd0602bfc15f66fc5
				const arcLength2D = getArcLength( [B1X, B2X, B3X, B4X], [B1Y, B2Y, B3Y, B4Y] );

				Gleis.BezierPoints[Index] = [ [B1X, B1Y, B1Z], [B2X, B2Y, B2Z], [B3X, B3Y, B3Z], [B4X, B4Y, B4Z], arcLength2D ];
/*
console.log( TrackSystemText(GleissystemID) + "-" + GleisID 
	+ "\tCubic[" + Index + "]"
	+ "\t" + arcLength2D.toFixed(2)
	+ "\t" + B1X.toFixed(2) + "\t" + B1Y.toFixed(2)
	+ "\t" + B2X.toFixed(2) + "\t" + B2Y.toFixed(2)
	+ "\t" + B3X.toFixed(2) + "\t" + B3Y.toFixed(2)
	+ "\t" + B4X.toFixed(2) + "\t" + B4Y.toFixed(2)
)
*/
				}
/*
console.log(`Cubic ${TrackSystemText(GleissystemID)} ${GleisID}`
+ ' Pos ' + FramePos.getAttribute("x")  + ' ' + FramePos.getAttribute("y")  + ' ' + FramePos.getAttribute("z")
+ ' Dir ' + FrameDir.getAttribute("dx") + ' ' + FrameDir.getAttribute("dy") + ' ' + FrameDir.getAttribute("dz")
+ ' Nor ' + FrameNor.getAttribute("dx") + ' ' + FrameNor.getAttribute("dy") + ' ' + FrameNor.getAttribute("dz")
+ ' Bin ' + FrameBin.getAttribute("dx") + ' ' + FrameBin.getAttribute("dy") + ' ' + FrameBin.getAttribute("dz")
+ ' pA  ' + PositionA.getAttribute("x")	+ ' ' + PositionA.getAttribute("y")	+ ' ' + PositionA.getAttribute("z")
+ ' vB  ' + VectorB.getAttribute("dx") 	+ ' ' + VectorB.getAttribute("dy") 	+ ' ' + VectorB.getAttribute("dz")
+ ' vC  ' + VectorC.getAttribute("dx") 	+ ' ' + VectorC.getAttribute("dy") 	+ ' ' + VectorC.getAttribute("dz")
+ ' vD  ' + VectorD.getAttribute("dx") 	+ ' ' + VectorD.getAttribute("dy") 	+ ' ' + VectorD.getAttribute("dz")
);
*/

			} else if (Rotator) {
				CurveType 	= 'Rotator';
				// A Rotator looks like an Arc if we can ignore the z-axis
				Kruemmung = +Rotator.getAttribute("a");
				const KruemmungZ = +Rotator.getAttribute("b");
				if (KruemmungZ * Laenge > 1) {
					console.log(`Rotator ${TrackSystemText(GleissystemID)} ${GleisID} has large KruemmungZ`);
				}

			} else if (RotatorChain) {
				CurveType 	= 'RotatorChain';
				console.log(`RotatorChain not supported yet: ${TrackSystemText(GleissystemID)} ${GleisID}`);
				continue;

			} else if (PolygonalChain) {
				CurveType 	= 'PolygonalChain';

				//const VectorBundleList = PolygonalChain.getElementsByTagName("VectorBundle");
				const PositionList = PolygonalChain.getElementsByTagName("Position");
				const VectorList   = PolygonalChain.getElementsByTagName("Vector");

				const Position = PositionList[0];
				const pX = +Position.getAttribute("x"); 
				const pY = +Position.getAttribute("y"); 
				const pZ = +Position.getAttribute("z"); 
				
				// Calculate start point
				mMatrix = [
						mMatrix,
						matrix.translate(pX, pY, pZ),
					].reduce(matrix.multiply);
				
				Gleis.BezierPoints = [];
				for (let Index = 1; Index < PositionList.length; Index++) {
					// First point of current Bezier segment
					const aPoint    = PositionList[Index-1];
					const B1X		= +aPoint.getAttribute("x") - pX; 
					const B1Y		= +aPoint.getAttribute("y") - pY; 
					const B1Z		= +aPoint.getAttribute("z") - pZ; 
					// Last point of current Bezier segment
					const dPoint    = PositionList[Index];
					const B4X		= +dPoint.getAttribute("x") - pX; 
					const B4Y 		= +dPoint.getAttribute("y") - pY; 
					const B4Z 		= +dPoint.getAttribute("z") - pZ; 
					// Distance between first and last point
					const d 		= 1/3 * Math.sqrt( (B1X-B4X)**2 + (B1Y-B4Y)**2 + (B1Z-B4Z)**2 );
					// Control point with 1/3 distance from first point in +vector direction 
					const aVector 	= VectorList[Index-1];
					const B2X 		= B1X + d * (+aVector.getAttribute("dx"));
					const B2Y 		= B1Y + d * (+aVector.getAttribute("dy"));
					const B2Z 		= B1Z + d * (+aVector.getAttribute("dz"));
					// Control point with 1/3 distance from last point in -vector direction 
					const dVector 	= VectorList[Index];
					const B3X 		= B4X + d * (-dVector.getAttribute("dx"));
					const B3Y 		= B4Y + d * (-dVector.getAttribute("dy"));
					const B3Z 		= B4Z + d * (-dVector.getAttribute("dz"));

					// Calculate length of bezier segment
					// Source: http://bl.ocks.org/hnakamur/e7efd0602bfc15f66fc5
					const arcLength2D = getArcLength( [B1X, B2X, B3X, B4X], [B1Y, B2Y, B3Y, B4Y] );

					Gleis.BezierPoints[Index-1] = [ [B1X, B1Y, B1Z], [B2X, B2Y, B2Z], [B3X, B3Y, B3Z], [B4X, B4Y, B4Z], arcLength2D ];
				}

const point = Gleis.BezierPoints[Gleis.BezierPoints.length -1]
console.log( 
      "\t" + CurveType 
	+ "\t" + GleisID
	+ "\tPos\t" + mMatrix[12] + "\t" + mMatrix[13]+ "\t" + mMatrix[14]
	+ "\tMid\t" + 0           + "\t" + 0          + "\t" + 0
	+ "\tEnd\t" + point[3][0] + "\t" + point[3][1] + "\t" + point[3][2]

)
			} else { // curve not supported yet
				CurveType 	= 'others';
				console.log(`other curve type not supported yet:  ${TrackSystemText(GleissystemID)} ${GleisID}`);
				continue;
			}

		} else {  /* EEP 15 */
			CurveType 		= 'classic';
			const Charakteristik = Gleis.getElementsByTagName("Charakteristik")[0];
			const Dreibein	= Gleis.getElementsByTagName("Dreibein")[0];
			const FramePos	= Dreibein.getElementsByTagName("Vektor")[0];
			const FrameDir	= Dreibein.getElementsByTagName("Vektor")[1];
			const FrameNor	= Dreibein.getElementsByTagName("Vektor")[2];
			const FrameBin	= Dreibein.getElementsByTagName("Vektor")[3];

			Laenge 		= +Charakteristik.getAttribute("Laenge") / 100;
			near		= 0;		//###
			far			= Laenge;	//###
			Kruemmung	= +Charakteristik.getAttribute("Kruemmung") * 100;

			PosX		= +FramePos.getAttribute("x") / 100;
			PosY		= +FramePos.getAttribute("y") / 100;
			PosZ		= +FramePos.getAttribute("z") / 100;

			DirX		= +FrameDir.getAttribute("x");
			DirY		= +FrameDir.getAttribute("y");
			DirZ		= +FrameDir.getAttribute("z");

			NorX		= +FrameNor.getAttribute("x");
			NorY		= +FrameNor.getAttribute("y");
			NorZ		= +FrameNor.getAttribute("z");

			BinX		= +FrameBin.getAttribute("x");
			BinY		= +FrameBin.getAttribute("y");
			BinZ		= +FrameBin.getAttribute("z");

			//  	   0     1     2     3     4     5     6     7     8     9     10    11    12    13    14    15
			mMatrix = [DirX, DirY, DirZ, 0,    NorX, NorY, NorZ, 0,    BinX, BinY, BinZ, 0,    PosX, PosY, PosZ, 1 ];
		} /* EEP 15 */

/*
const Interval = Gleis.getElementsByTagName("Interval")[0];
if (0 != +Interval.getAttribute("near")) {
console.log(`near != 0 ${TrackSystemText(GleissystemID)} ${GleisID} ${CurveType}`
+ ' ' + Interval.getAttribute("near")
+ ' ' + Interval.getAttribute("far")
);
}
*/
		/*
		2D transformation matrix			3D transformation matrix
		matrix2D( a, b, c, d,  x, y ) = 	matrix3d( a, b, 0, 0,  c, d, 0, 0,  0, 0, 1, 0,  x, y, 0, 1 ).

		matrix.format
		[ a, b, 0, 0,
		  c, d, 0, 0,
		  0, 0, 1, 0,
		  x, y, 0, 1  ]

		matrix.identity
		[ 1, 0, 0, 0,
		  0, 1, 0, 0,
		  0, 0, 1, 0,
		  0, 0, 0, 1 ]

		matrix.rotateZ
		[ cos a, 	sin a,	0, 0,
		  -sin a, 	cos a, 	0, 0,
		  0, 		0, 		1, 0,
		  0, 		0, 		0, 1]

		matrix.translate
		[ 1,  0,  0,  0,
		  0,  1,  0,  0,
		  0,  0,  1,  0,
		  dx, dy, dz, 1 ]

		*/


/* //###
Modellbahn_Landbrücken
Arc near 60 > far 0 for Eisenbahn 22
Arc near 59.21461 > far 0 for Eisenbahn 129
Arc near 73.93141 > far 0 for Eisenbahn 134
Arc near 73.93142 > far 0 for Eisenbahn 135
Arc near 52.93141 > far 0 for Eisenbahn 137
Arc near 52.93141 > far 0 for Eisenbahn 139
Line near 59.99967 > far 0 for Eisenbahn 140
Line near 60 > far 0 for Eisenbahn 144
Line near 60.00001 > far 0 for Eisenbahn 145
Arc near 56.8584 > far 0 for Eisenbahn 146
Arc near 56.85841 > far 0 for Eisenbahn 147
Arc near 56.85843 > far 0 for Eisenbahn 148
Arc near 72.93145 > far 0 for Eisenbahn 149
Arc near 4.77981 > far 0 for Eisenbahn 406
Line near 7 > far 0 for Straße 25
Line near 60 > far 0 for Straße 73
Arc near 43.76994 > far 0 for Straße 97
Arc near 43.76992 > far 0 for Straße 98

Gleismauerbau2
Arc near 48.6691 > far 0 for Eisenbahn 294
Arc near 61.89311 > far 0 for Straße 122
Arc near 61.89329 > far 0 for Straße 124
Arc near 48.83204 > far 0 for Straße 144
Line near 60 > far 0 for Straße 400
Line near 60 > far 0 for Straße 403

Neue Anlage_Test_288 - repariert
Cubic near 76.67825 > far 0 for Eisenbahn 222
Cubic near 77.51543 > far 0 for Eisenbahn 223
Cubic near 78.34965 > far 0 for Eisenbahn 224
Line near 60 > far -16.17879 for Eisenbahn 728			<-----
Line near 60 > far -16.17879 for Straßenbahn 57			<-----
Arc near 7.569722 > far -21.23326 for Straßenbahn 72	<-----
Line near 4.997559 > far -32.4624 for Straße 13			<-----
Line near 80 > far 53.87793 for Straße 130				<-----	
Rotator near 74.91347 > far 0 for Straße 303
Arc near 10.00001 > far -0.1558323 for Straße 352		<-----
Line near 73.99999 > far 49.7773 for Straße 455  		<-----
Rotator near 20.36278 > far 0 for Straße 530
Line near 72.39453 > far 7.073486 for Straße 536		<-----
Line near 40 > far -14.45385 for Straße 830				<-----
Arc near 61.33142 > far 17.66124 for Straße 921			<-----
Rotator near 36.81652 > far 0 for Straße 977
Line near 39.55864 > far -12.09861 for Straße 1070		<-----
Line near 51.7168 > far 15.13037 for Wasserwege 61		<-----
...

Nouveau projet 18a
Helix near 67.46526 > far 0 for Eisenbahn 55
...

HSB_Sued

DKW-Schaltung-mit GBS-Fahrstrasse-Normgleis-V16

*/
if (near > far) { //###
	console.log(
		CurveType 
		+ " near " + near + " > far " + far
		+ " for " + TrackSystemText(GleissystemID) + " " + GleisID
);}

		let Winkel, DeltaX, DeltaY, DeltaZ, svgRotate;
		const posX = 12, posY = 13, posZ = 14; // Index in mMatrix

		// Log defect data
		if (isNaN( mMatrix[posX] )) {
			console.log("NaN Error: "
				+ TrackSystemText(GleissystemID) + '-' + GleisID + ' ' + CurveType
			);
			// Replace defect data with initial data to avoid followup errors.
			mMatrix = matrix.identity();
		}

		Gleis.CurveType = CurveType;
		Gleis.Laenge 	= Laenge;
		Gleis.mPos 		= mMatrix;

		// Group node for Gleis
		const classList = Gleisart[clsid] 
			+ " " + CurveType
			+ " " + `stil-${stil}`
			+ " " + (global.activeTracks[GleissystemID].includes(GleisID) ? "active" : "inactive")
			+ " " + (near > far ? "near-far" : "")	//### Enable highlighing 
			+ " " + `height=${mMatrix[posZ].toFixed(2)}`	// Height
			// Ein Kamerafahrweg ist immer unsichtbar
			+ " " + (stil == 100000 || (unsichtbar.includes(parseInt(stil)) && GleisData != 16) ? "unsichtbar" : "sichtbar");
		const svgGleisGroup = svgAppend(svgGleissystemGroup, {
			svg_tag	: `g`,
			id		: `G${GleissystemID}-${GleisID}`,
			"class"	: classList,
		});

		// Calculate end point and create svg curve
		if (Gleis.BezierPoints) { // CurveType: Cubic, Spline, PolygonalChain

			// Create svg curve
			let d = "";
			for (let I = 0; I < Gleis.BezierPoints.length; I++) {
				const Index = (near > far ? Gleis.BezierPoints.length - 1 - I : I);	// reverse / normal
				const BezierPoints = Gleis.BezierPoints[Index];

				// BezierPoints = [ [B1X, B1Y, B1Z], [B2X, B2Y, B2Z], [B3X, B3Y, B3Z], [B4X, B4Y, B4Z], arcLength ];
				const B1X = BezierPoints[0][0];
				const B1Y = BezierPoints[0][1];
				const B1Z = BezierPoints[0][2];
				const B2X = BezierPoints[1][0];
				const B2Y = BezierPoints[1][1];
				const B2Z = BezierPoints[1][2];
				const B3X = BezierPoints[2][0];
				const B3Y = BezierPoints[2][1];
				const B3Z = BezierPoints[2][2];
				const B4X = BezierPoints[3][0];
				const B4Y = BezierPoints[3][1];
				const B4Z = BezierPoints[3][2];
				//const arcLength = BezierPoints[4];
				
				if (d === "") {
					// The svg command "M x0 y0 C x1 y1 x2 y2 x3 y3" uses the coordinates of the bezier points of the first cubic segment.
					d += (near > far  //###
							? `M ${B4X} ${B4Y} C ${B3X} ${B3Y} ${B2X} ${B2Y} ${B1X} ${B1Y}`	// reverse
							: `M ${B1X} ${B1Y} C ${B2X} ${B2Y} ${B3X} ${B3Y} ${B4X} ${B4Y}`	// normal
						)
				} else {
					// We can chain the following segments using the short command "S x2 y2 x3 y3".
					d += (near > far  //###
							? ` S ${B2X} ${B2Y} ${B1X} ${B1Y}`								// reverse
							: ` S ${B3X} ${B3Y} ${B4X} ${B4Y}`								// normal
						)
				}
				
			}
			
			svgAppend(svgGleisGroup, {
				svg_tag				: `path`,
				//class				: `stil-${stil}`,
				d 					: d,
				transform 			: matrixToTransform(mMatrix)
			});

			// Calculate end point
			const t 	= (near > far ? 0 : 1);
			const Index = (near > far ? 0 : Gleis.BezierPoints.length - 1);
			[DeltaX, DeltaY, DeltaZ, Winkel] = calcBezierCurve(Gleis.BezierPoints[Index], t);

		} else if (CurveType === 'Clothoid') {
			let points, svgPath;
			[points, svgPath] = calcClothoidCurve(
				Gleis.Clothoid.A,
				Gleis.Clothoid.L1,
				Gleis.Clothoid.L2,
				Gleis.Clothoid.RotationCCW
			);
			DeltaX		= points.End.x;
			DeltaY 		= points.End.y;
			DeltaZ		= points.End.z;
			Winkel		= points.End.Winkel;

			svgAppend(svgGleisGroup, {
				svg_tag				: `path`,
				class				: `stil-${stil}`,
				d 					: svgPath,	 //### Bug: adjustment for near>far required
				transform 			: matrixToTransform(mMatrix)
			});

			// Adjust Gleis.mPos
			Gleis.mPos = [
					mMatrix,
					matrix.translate(points.Pos.x, points.Pos.y, points.Pos.z),
				].reduce(matrix.multiply);

		} else if (Kruemmung > -0.0001 && Kruemmung < 0.0001) { // Show line. The svg-arc is not shown if the radius is too big
			/* SVG: Gerades Gleis
			Alternativen (line erlaubt allerdings kein text-path, daher wird path verwendet)
			a) <line x1="0" y1="0" x2="Laenge" y2="0" transform="translate(PosX PosY) matrix(DirX DirY NorX NorY 0 0)"/>
			b) <line x1="0" y1="0" x2="Laenge" y2="0" transform="matrix(DirX DirY NorX NorY PosX PosY)"/>
			b) <path d="M 0 0 H Laenge" transform="matrix(DirX DirY NorX NorY PosX PosY)"/>
			*/
			DeltaX		= Laenge;
			DeltaY 		= 0;
			DeltaZ		= 0;
			Winkel		= 0;

			svgAppend(svgGleisGroup, {
				svg_tag				: `path`,
				//class				: `stil-${stil}`,
				d 					: //`M 0 0 H ${Laenge}`,
									  `M ${near} 0 L ${far} 0`,	//### This is the correct placement of the track
																//    however, all of this should be part mMatrix / mPos / mEnd 
																//	  to allow correct placement of switches, signals and contacts
									  /*
									  (near > far 				//### This works only if far == 0
										? `M ${Laenge} 0 L 0 0`	// reverse
										: `M 0 0 H ${Laenge}`	// normal
										),
									  */	
									  transform 			: matrixToTransform(mMatrix)
			});

		} else { // Show arc. Kruemmung != 0

			/* SVG: Gebogenes Gleis

			Winkel (rad) = Kruemmung * Laenge
			ArcFlag = 0 für Winkel im Bereich -180° bis +180°, ansonsten 1
			SweepFlag = 1 für Winkel >= 0, 0 für Winkel < 0
			Radius = 1 / Kruemmung
			DeltaX = sin(Winkel) * Radius
			DeltaY = (1-cos(Winkel)) * Radius

			Kreisbogen als Spezialfall eines Ausschnittes einer allgenmeinen Ellipse:
			<path d="M PosX PosY A RadiusX RadiusY RotateX ArcFlag SweepFlag PosEndX PosEndY" />
			PosX = 0			x-Koordinate des Anfangpunktes
			PosY = 0			Y-Koordinate des Anfangpunktes
			RadiusX = Radius	Radius der x-Achse der Ellipse
			RadiusY	= Radius	Radius der y-Achse der Ellipse
			RotateX = 0 		Rotation der x-Achse der Ellipse in Grad (0: keine Rotation)
			ArcFlag = 0			large-arc-flag: kurzer Weg um die Ellipse: 0, langer Weg um die Ellipse: 1
			SweepFlag = ...		Zeichnung entgegen den Uhrzeigersinn: 0, Zeichnung mit dem Uhrzeigersinn: 1
			PosEndX = DeltaX	x-Koordinate des Endpunktes
			PosEndY = DeltaY	Y-Koordinate des Endpunktes

			Dies ergibt folgende vereinfachte Form:
			<path d="M 0 0 A Radius Radius 0 ArcFlag SweepFlag DeltaX DeltaY" />
			*/
			Winkel 	= Kruemmung * Laenge;
			const Radius	= 1 / Kruemmung;

			DeltaX		= Math.sin(Winkel) * Radius;
			DeltaY 		= (1 - Math.cos(Winkel)) * Radius;
			DeltaZ		= 0;

			const ArcFlag 	= ( Winkel <= Math.PI && Winkel >= -Math.PI ? 0 : 1); 	// small respective large arc of the curve
			const SweepFlag = ( Winkel >= 0 ? 1 : 0);								// counter clock wise respective clock wise

			svgAppend(svgGleisGroup, {
				svg_tag				: `path`,
				//class				: `stil-${stil}`,
				d 					: (near > far //###
										? `M ${DeltaX} ${DeltaY} A ${Radius} ${Radius} 0 ${ArcFlag} ${1-SweepFlag} 0 0`	// reverse
										: `M 0 0 A ${Radius} ${Radius} 0 ${ArcFlag} ${SweepFlag} ${DeltaX} ${DeltaY}`	// normal
										),
				transform 			: matrixToTransform(mMatrix)
			});

		}

		if (false && Gleis.Helix) {
			Gleis.mEnd = Gleis.Helix.mEnd;
		} else {
			Gleis.mEnd = [
					mMatrix,
					matrix.translate(DeltaX, DeltaY, DeltaZ),
				].reduce(matrix.multiply);
		}
		svgRotate	= (Winkel != 0 ? ` rotate(${Winkel*180/Math.PI} ${DeltaX} ${DeltaY})` : "");

		// Swap mPos and mEnd if near > far //### I guess that's incomplete
		if (near > far) {
			const tempPos = Gleis.mEnd;
			Gleis.mEnd = Gleis.mPos;
			Gleis.mPos = tempPos;
		}

		if (Key_Id) {
			// Show text of Weiche at the end of the track
			let Code = "W";
			if (GleisData == 18 || GleisData == 19) { Code = "DWK"; }
			if (GleisData == 20 || GleisData == 21) { Code = "T-W"; }
			svgAppend(svgGleisGroup, {
				svg_tag			: `text`,
				id				: `W${Key_Id}`,
				text			: `${Code}${Key_Id}`,
				dy				: `1em`, 		// Shift text below the track
				"class"			: `WeicheText` + (near > far ? "" : ` text-anchor-end`),	//###
				//x				: DeltaX,
				//y				: -DeltaY,
				x				: (near > far ? 0 :  DeltaX),	//###
				y				: (near > far ? 0 : -DeltaY),	//###
				transform 		: matrixToTransform(mMatrix)
								  + (near > far ? "" : svgRotate)	//###
								  + ` scale(1 -1)`,
			});
		}

		// Calculate mid point
		if (Gleis.BezierPoints) { // CurveType: Cubic, Spline, PolygonalChain

			[DeltaX, DeltaY, DeltaZ, Winkel] = calcBezierPoint(Gleis.BezierPoints, Laenge / 2, near, far) 
			svgRotate	= ` rotate(${Winkel*180/Math.PI} ${DeltaX} ${-DeltaY})`;	// svg: mirrored y-coordinate

		} else if (CurveType === 'Clothoid') {
			let points, svgPath;
			[points, svgPath] = calcClothoidCurve(
				Gleis.Clothoid.A,
				0,
				Gleis.Clothoid.L1 + (Gleis.Clothoid.L2 - Gleis.Clothoid.L1)/2,
				Gleis.Clothoid.RotationCCW
			);
			DeltaX			= points.End.x;
			DeltaY 			= points.End.y;
			DeltaZ			= points.End.z;
			Winkel			= points.End.Winkel;

		} else if (Kruemmung > -0.0001 && Kruemmung < 0.0001) { // The svg-arc is not shown if the radius is too big
			DeltaX			= Laenge / 2;
			DeltaY			= 0;
			DeltaZ			= 0;
			Winkel			= 0;

		} else {  // Kruemmung != 0
			Winkel 	= Kruemmung * Laenge / 2;
			// const ArcFlag 	= ( Winkel <= Math.PI && Winkel >= -Math.PI ? 0 : 1);
			// const SweepFlag = ( Winkel >= 0 ? 1 : 0);
			const Radius	= 1 / Kruemmung;

			DeltaX 			= Math.sin(Winkel) * Radius;
			DeltaY 			= (1 - Math.cos(Winkel)) * Radius;
			DeltaZ			= 0;
		}

		if (false && Gleis.Helix) {
			Gleis.mMid = Gleis.Helix.mMid;
		} else {
			Gleis.mMid = [
					mMatrix,
					matrix.translate(DeltaX, DeltaY, DeltaZ),
				].reduce(matrix.multiply);
		}
		svgRotate	= (Winkel != 0 ? ` rotate(${Winkel*180/Math.PI} ${DeltaX} ${DeltaY})` : "");

		// show GleisID in the middle above the track (left-adjusted)
		svgAppend(svgGleisGroup, {
			svg_tag				: `text`,
			text				: `${GleisID}`,
			dx					: `-0.5em`, 	// Shift text left to move it a little bit towards the center
			dy					: `-0.1em`, 	// Shift text up
			"class"				: `GleisID`,
			x					: DeltaX,
			y					: -DeltaY,
			transform 			: matrixToTransform(mMatrix)
			//transform 			: matrixToTransform(Gleis.mMid) // Bug: does not work for Rotator yet
								  + svgRotate
								  + ` scale(1 -1)`,
		});
		// show CurveType in the middle above the track (right-adjusted)
		if (CurveType != 'classic' && CurveType != 'EEPCurve') {
		svgAppend(svgGleisGroup, {
			svg_tag				: `text`,
			text				: `${CurveType}`,
			dx					: `-0.7em`, 	// Shift text left to get away from GleisID
			dy					: `-0.1em`, 	// Shift text up
			"class"				: `CurveType`,
			x					: DeltaX,
			y					: -DeltaY,
			transform 			: matrixToTransform(mMatrix)
			//transform 			: matrixToTransform(Gleis.mMid) // Bug: does not work for Rotator yet
								  + svgRotate
								  + ` scale(1 -1)`,
		});
		}
		// show Gleisstil in the middle below the track (right-adjusted)
		svgAppend(svgGleisGroup, {
			svg_tag				: `text`,
			text				: `${stil}`,
			dx					: `-0.1em`, 	// Shift text left a little bit
			dy					: `1em`, 		// Shift text below the track
			"class"				: `Stil`,
			x					: DeltaX,
			y					: -DeltaY,
			transform 			: matrixToTransform(mMatrix)
								  + svgRotate
								  + ` scale(1 -1)`,
		});
		// show Hoehe in the middle below the track (left-adjusted)
		svgAppend(svgGleisGroup, {
			svg_tag				: `text`,
			text				: `[${mMatrix[posZ].toFixed(2)}m]`,
			dx					: `+0.1em`, 	// Shift text right a little bit
			dy					: `1em`, 		// Shift text below the track
			"class"				: `Hoehe`,
			x					: DeltaX,
			y					: -DeltaY,
			transform 			: matrixToTransform(mMatrix)
								  + svgRotate
								  + ` scale(1 -1)`,
		});

		if (global.__showCircles__) {	// debugging feature
			if (Gleis.BezierPoints) {
				for (const BezierPoints of Gleis.BezierPoints) {
					svgAppend(svgGleisGroup, {
						svg_tag				: `circle`,
						r					: 0.2,
						transform			: `${matrixToTransform(mMatrix)} translate(${BezierPoints[0][0]} ${BezierPoints[0][1]})`
					});
					svgAppend(svgGleisGroup, {
						svg_tag				: `circle`,
						r					: 0.4,
						transform			: `${matrixToTransform(mMatrix)} translate(${BezierPoints[1][0]} ${BezierPoints[1][1]})`
					});
					svgAppend(svgGleisGroup, {
						svg_tag				: `circle`,
						r					: 0.8,
						transform			: `${matrixToTransform(mMatrix)} translate(${BezierPoints[2][0]} ${BezierPoints[2][1]})`
					});
					svgAppend(svgGleisGroup, {
						svg_tag				: `circle`,
						r					: 1.2,
						transform			: `${matrixToTransform(mMatrix)} translate(${BezierPoints[3][0]} ${BezierPoints[3][1]})`
					});
				}
			}

			if (Gleis.Helix) {
				// Show circle at Point
				svgAppend(svgGleisGroup, {
					svg_tag				: `circle`,
					r					: 0.2, //Gleis.Helix.a,
					transform 			: matrixToTransform(Gleis.Helix.mPos),
				});
				svgAppend(svgGleisGroup, {
					svg_tag				: `circle`,
					r					: 0.3,
					transform 			: matrixToTransform(Gleis.Helix.mMid),
				});
				svgAppend(svgGleisGroup, {
					svg_tag				: `circle`,
					r					: 0.4,
					transform 			: matrixToTransform(Gleis.Helix.mEnd),
				});
			}
			// Show circle at Point
			svgAppend(svgGleisGroup, {
				svg_tag				: `circle`,
				r					: 1.5,
				transform 			: matrixToTransform(Gleis.mPos),
			});
			svgAppend(svgGleisGroup, {
				svg_tag				: `circle`,
				r					: 0.5,
				transform 			: matrixToTransform(Gleis.mMid),
			});
			svgAppend(svgGleisGroup, {
				svg_tag				: `circle`,
				r					: 1,
				transform 			: matrixToTransform(Gleis.mEnd),
			});
		}

		// Verwendeten Bereich der Anlage anpassen
		const border = 20;
		global.usedArea.min.x = Math.min( global.usedArea.min.x, Gleis.mPos[posX]-border, Gleis.mMid[posX]-border, Gleis.mEnd[posX]-border );
		global.usedArea.min.y = Math.min( global.usedArea.min.y, Gleis.mPos[posY]-border, Gleis.mMid[posY]-border, Gleis.mEnd[posY]-border );
		global.usedArea.min.z = Math.min( global.usedArea.min.z, Gleis.mPos[posZ],        Gleis.mMid[posZ],        Gleis.mEnd[posZ] );

		global.usedArea.max.x = Math.max( global.usedArea.max.x, Gleis.mPos[posX]+border, Gleis.mMid[posX]+border, Gleis.mEnd[posX]+border );
		global.usedArea.max.y = Math.max( global.usedArea.max.y, Gleis.mPos[posY]+border, Gleis.mMid[posY]+border, Gleis.mEnd[posY]+border );
		global.usedArea.max.z = Math.max( global.usedArea.max.z, Gleis.mPos[posZ],        Gleis.mMid[posZ],        Gleis.mEnd[posZ] );

		// Signale
		// <Meldung Position="3449.492" ParaOderAnti="1" fireOnPara="1" fireOnAnti="0" name="PI5_HP02_Form_oVSig" Key_Id="5" >
		//     <KontaktZiel>6</KontaktZiel>
		//     <Signal stellung="1" wirkungsdistanz="10856.51"/>
		// </Meldung>

		// Fahrstraßen: name = "system\Route_SignalS.3ds" bzw. "system\Route_SignalZ.3ds"
		// <Meldung Position="5190" ParaOderAnti="1" fireOnPara="1" fireOnAnti="0" name="system\Route_SignalS.3ds" Key_Id="141" Routes="7">
		// 		<KontaktZiel>0</KontaktZiel>
		// 		<Signal stellung="1" wirkungsdistanz="0" StopAt="0" Delay="0" ActDelay="0"/>
		// 		<Route Target="142" Start="5190" Stop="1890" Color="13">
		//		...
		// </Meldung>

		const trackSignalEntries = global.trackSignals[GleissystemID][GleisID];
		if (trackSignalEntries) {
		for (const trackSignalEntry of trackSignalEntries) {
			const Meldung		= trackSignalEntry.Meldung;
			const SignalID		= Meldung.getAttribute("Key_Id");
			const signalType	= trackSignalEntry.signalType;
			const Position		= (near > far	//###
									? Laenge - trackSignalEntry.Position	// reverse
									: trackSignalEntry.Position 			// normal
									);
			const Distanz		= Meldung.getElementsByTagName("Signal")[0].getAttribute("wirkungsdistanz") / 100; // Abstand zwischen Vor-und Hauptsignal
			const ParaOderAnti 	= trackSignalEntry.ParaOderAnti; //Gleisrichtung: 0 = Ende -> Anfang, 1 = Anfang -> Ende

			// Calculate point
			if (Gleis.BezierPoints) { // CurveType: Cubic, Spline, PolygonalChain
				//const t = (Laenge ? Position / Laenge : 0);
				//const BezierPoints = Gleis.BezierPoints[0]; // Incomplete: only the first segment is supported yet
				//[DeltaX, DeltaY, DeltaZ, Winkel] = calcBezierCurve(BezierPoints, t);
				[DeltaX, DeltaY, DeltaZ, Winkel] = calcBezierPoint(Gleis.BezierPoints, Position, near, far) 

			} else if (CurveType === 'Clothoid') {
				let points, svgPath;
				[points, svgPath] = calcClothoidCurve(
					Gleis.Clothoid.A,
					0,
					Gleis.Clothoid.L1 + Position * (Gleis.Clothoid.L1 < Gleis.Clothoid.L2 ? +1 : -1),
					Gleis.Clothoid.RotationCCW
				);
				DeltaX			= points.End.x;
				DeltaY 			= points.End.y;
				DeltaZ			= points.End.z;
				Winkel			= points.End.Winkel;

			} else if (Kruemmung > -0.0001 && Kruemmung < 0.0001) { // The svg-arc is not shown if the radius is too big
				DeltaX			= Position;
				DeltaY			= 0;
				DeltaZ			= 0;
				Winkel 			= 0;

			} else { // Kruemmung != 0
				Winkel 			= Kruemmung * Position;
				const Radius 	= 1 / Kruemmung;

				DeltaX 			= Math.sin(Winkel) * Radius;
				DeltaY 			= (1 - Math.cos(Winkel)) * Radius;
				DeltaZ			= 0;
			}

			Meldung.mPos = [
					mMatrix,
					matrix.translate(DeltaX, DeltaY, DeltaZ),
					matrix.rotateZ(
						  Winkel				// Rotate to tangent of track
						+ ParaOderAnti*Math.PI 	// Rotate text to the side of the symbol
					),
				].reduce(matrix.multiply);

			// Group node for Signal (Multiple groups for pre signal, stop position and main signal?)
			const svgSignalGroup = svgAppend(svgGleisGroup, {
				svg_tag	: `g`,
				id		: `S${SignalID}`,
				class	: `Signal`,
			});

			if (global.__showCircles__) {	// debugging feature
				// Show circle at Point
				svgAppend(svgSignalGroup, {
					svg_tag				: `circle`,
					r					: 1,
					transform 			: matrixToTransform(Meldung.mPos),
				});
			}

			// Show symbol for Signal / Fahrstraße
			svgAppend(svgSignalGroup, {
				svg_tag				: `use`,
				href				: (	  signalType === "FStart" 	? "#SymbolFStart"
										: signalType === "FZiel" 	? "#SymbolFZiel"
										: signalType === "pre" 		? "#SymbolPreSignal"
										: signalType === "StopAt" 	? "#SymbolStopAt"
										: 							  "#SymbolSignal"
									  ),
				transform 			: matrixToTransform(Meldung.mPos)
										+ ` translate(-10 0)` // required to move the origin of the symbol to the Signal position
										,
			});

			// Show text of Signal / Fahrstraße
			if (signalType !== "pre" && signalType !== "StopAt") { // do not show any text for pre-signals or stop points
			svgAppend(svgSignalGroup, {
				svg_tag				: `text`,
				text				: (	  signalType === "FStart"	? 'Fs' // ### Translation needed
										: signalType === "FZiel"	? 'Fz'
										: signalType === "pre" 		? 'S'
										: signalType === "StopAt" 	? 'stop '
										: 						  	  'S'
									  )
										+ SignalID
										+ (signalType === "pre" ? ` ${Distanz.toFixed(0)}m` : ``),
				"dy"				: `-2.3`, 									// Shift text above the symbol
				transform 			: matrixToTransform(Meldung.mPos)
										+ ` scale(1 -1)`,
			});
			} // do not show any text for pre-signals

		}} // Signale

		// Kontakte
		for (const Kontakt of Gleis.getElementsByTagName("Kontakt")) {
			const Position		= (near > far 	//###
									? Laenge - Kontakt.getAttribute("Position") / 100	// reverse
									: Kontakt.getAttribute("Position") / 100 			// normal
									);
			const ParaOderAnti 	= Kontakt.getAttribute("ParaOderAnti"); // Gleisrichtung 1: 0 = Ende -> Anfang, 1 = Anfang -> Ende
			const fireOnPara  	= Kontakt.getAttribute("fireOnPara"); 	// Kontakt aktiv für Gleisrichtung 1
			const fireOnAnti  	= Kontakt.getAttribute("fireOnAnti"); 	// Kontakt aktiv für Gleisrichtung 2
			const SetType 		= Number(Kontakt.getAttribute("SetType"));
			const SetValue 		= Number(Kontakt.getAttribute("SetValue"));
			const Wartender		= Number(Kontakt.getAttribute("Wartender"));
			const KontaktZiel 	= Number(Kontakt.getAttribute("KontaktZiel"));
			const LuaFn 		= Kontakt.getAttribute("LuaFn");

			if (!global.Kontakte.Anzahl) {
				global.Kontakte.Anzahl = 0;				// initialization
			}
			const KontaktID = global.Kontakte.Anzahl; 	// arbitrary identfication
			global.Kontakte[KontaktID] = Kontakt;
			global.Kontakte.Anzahl += 1;

			// Calculate point
			if (Gleis.BezierPoints) { //CurveType === 'Cubic' / 'Spline'
				[DeltaX, DeltaY, DeltaZ, Winkel] = calcBezierPoint(Gleis.BezierPoints, Position, near, far) 

			} else if (CurveType === 'Clothoid') {
				let points, svgPath;
				[points, svgPath] = calcClothoidCurve(
					Gleis.Clothoid.A,
					0,
					Gleis.Clothoid.L1 + Position * (Gleis.Clothoid.L1 < Gleis.Clothoid.L2 ? +1 : -1),
					Gleis.Clothoid.RotationCCW
				);
				DeltaX			= points.End.x;
				DeltaY 			= points.End.y;
				DeltaZ			= points.End.z;
				Winkel			= points.End.Winkel;

			} else if (Kruemmung > -0.0001 && Kruemmung < 0.0001) { // The svg-arc is not shown if the radius is too big
				Winkel 			= 0;
				DeltaX			= Position;
				DeltaY			= 0;
				DeltaZ			= 0;

			} else { // Kruemmung != 0
				Winkel 			= Kruemmung * Position;
				const Radius 	= 1 / Kruemmung;

				DeltaX 			= Math.sin(Winkel) * Radius;
				DeltaY 			= (1 - Math.cos(Winkel)) * Radius;
				DeltaZ			= 0;
			}

			Kontakt.mPos = [
					mMatrix,
					matrix.translate(DeltaX, DeltaY, DeltaZ),
					matrix.rotateZ(
						  Winkel					// Rotate to tangent of track
						//+ ParaOderAnti*Math.PI 	// Rotate text to the side of the symbol
					),
				].reduce(matrix.multiply);

			// Group node for Kontakt
			const svgKontaktGroup = svgAppend(svgGleisGroup, {
				svg_tag	: `g`,
				id		: `K${KontaktID}`,
				class	: `Kontakt`,
			});

			if (global.__showCircles__) {
				// Show circle at Point
				svgAppend(svgKontaktGroup, {
					svg_tag				: `circle`,
					r					: 2,
					transform 			: matrixToTransform(Kontakt.mPos),
				});
			}

			// Show symbol for Kontakt
			if (fireOnPara == 1) {
				svgAppend(svgKontaktGroup, {
					svg_tag				: `use`,
					"href"				: `#SymbolKontakt`,
					transform 			: matrixToTransform(Kontakt.mPos)
											+ (ParaOderAnti ? ` rotate(${ParaOderAnti*180})` : "")
											+ ` translate(-10 0)` // required to move the origin of the symbol to the Kontakt position
											,
				});
			}
			if (fireOnAnti == 1) {
				svgAppend(svgKontaktGroup, {
					svg_tag				: `use`,
					"href"				: `#SymbolKontakt`,
					transform 			: matrixToTransform(Kontakt.mPos)
											+ (1-ParaOderAnti ? ` rotate(${(1-ParaOderAnti)*180})` : "")
											+ ` translate(-10 0)` // required to move the origin of the symbol to the Kontakt position
											,
				});
			}

			// Show text of Kontakt
			let KontaktTypText = getKontaktIcon(GleissystemID, SetType, SetValue);
			if (SetType === 1280 && Wartender != 0) {	// Einfahrt Depot, Depot-ID = Wartender
				KontaktTypText = Wartender + KontaktTypText;
			}
			if (SetType === 1536) {						// Ausfahrt Depot, Depot-ID = SetValue
				KontaktTypText = KontaktTypText + SetValue;
			}
			if (LuaFn && LuaFn !== "") {				// Lua-Function 
				KontaktTypText += "Lua";
			}
			if (KontaktZiel > 0 ) {
				const Ziel = global.KontaktZiele[KontaktZiel];
				KontaktTypText += (Ziel ? `${Ziel.Typ.substr(0, 1)}${Ziel.ID}` : `?${KontaktZiel}`);
			}
			if (KontaktTypText != "") {
				svgAppend(svgKontaktGroup, {
					svg_tag				: `text`,
					text				:  KontaktTypText,
					"dy"				: `-2.3`, 													// Shift text above the symbol
					transform 			: matrixToTransform(Kontakt.mPos)
											+ ` rotate(${ParaOderAnti*180 + (1-fireOnPara)*180})`	// Rotate text to the side of the symbol
											+ ` scale(1 -1)`,
				});
			}

		} // Kontakte

	} // Gleise

	// Process virtual connections
	let svgVirtuellGroup;
	for ( const GleisID in global.trackConnections[GleissystemID]) {

		const Gleis   = global.Gleissysteme[GleissystemID][GleisID];

		const connections = global.trackConnections[GleissystemID][GleisID] || {};
		for (const Anschluss in connections) {	// Anfang, Ende, EndeAbzweig, EndeKoAbzweig

			const connection = connections[Anschluss];
			//if (connection.Flags && Anschluss === "Anfang") {	// Virtual connection in backward direction
			if (connection.Flags && connection.Direction === 1) {	// Virtual connection (in first direction)

				const connectedGleis   = global.Gleissysteme[GleissystemID][connection.GleisID];

				const vPos = ( Anschluss            === "Anfang" ? Gleis.mPos          : Gleis.mEnd          );	// Start of virtual connection	
				const vEnd = ( connection.Anschluss === "Anfang" ? connectedGleis.mPos : connectedGleis.mEnd );	// End of virtual connection	

/*
console.log( "Gleis\t"
	+ GleissystemID + " " + GleisID + "\t"
	+ Anschluss + "\t"
	+ vPos[12].toFixed(1)  + "\t" + vPos[13].toFixed(1)  + "\t" // + vPos[14].toFixed(1) + "\t"
	+ "Gleis\t"
	+ GleissystemID + " " + connection.GleisID + "\t"
	+ connection.Anschluss+ "\t"
	+ vEnd[12].toFixed(1)  + "\t" + vEnd[13].toFixed(1)  + "\t" // + vEnd[14].toFixed(1) + "\t"
)
*/

				if (!svgVirtuellGroup) {
					svgVirtuellGroup = svgAppend(svgGleissystemGroup, {
						svg_tag	: `g`,
						id		: `V${GleissystemID}`,
						"class"	: "virtual",
					});	
				}
				svgAppend(svgVirtuellGroup, {
					svg_tag	: `path`,
					id		: `V${GleissystemID}-${GleisID}-${Anschluss}`,
					d 		: `M ${vPos[12]} ${-vPos[13]} L ${vEnd[12]} ${-vEnd[13]}`,
				});

			}
		}
	}
} // end function createSVGforGleissystem

function createSVGfinalize(SVGfragment) {

	const SVGfragmentBackground 	= document.createDocumentFragment();

	createSVGforGleisobjekte(SVGfragmentBackground);
	createSVGforRahmen(SVGfragmentBackground);

	createSVGforKameras(SVGfragment);

	// Now we can append the fragments to the svg node
	// Order: 1. Gleisobjekte (Flächen), 2. Rahmen, 3. Gleise (Linien), 4. Kameras
	document.getElementById("sutrackpSVG").appendChild(SVGfragmentBackground);
	document.getElementById("sutrackpSVG").appendChild(SVGfragment);

	global.timestamp.svgCreated = Date.now();
	console.log('create svg:' + (global.timestamp.svgCreated - global.timestamp.fileParsed) / 1000 + 'sec');
}

function createSVGforGleisobjekte(SVGfragment) {
/*
	in:
		global.Gleisobjekte
		global.Gleissysteme
		TrackSystemCode

	mod:
		document.getElementById("CheckboxGleisobjekt")
		SVGfragment

*/

	// Process Gleisobjekte
	// to be discussed: should Gleisobjekt get aktiv/inaktiv status? (current: no - this could be a feature)

	let svgGleisobjekteGroup;
	for (const GleisobjektID in global.Gleisobjekte) {
		const Gleisobjekt = global.Gleisobjekte[GleisobjektID];
		const GleissystemID = Gleisobjekt.GleissystemID;				// GleissystemID of Gleisobjekt

		let minX, minY, maxX, maxY;
		const points = [];
		for (const i in Gleisobjekt.Gleise) {
			const GleissystemID = Gleisobjekt.Gleise[i].GleissystemID;	// GleissystemID of Gleis
			const GleisID 		= Gleisobjekt.Gleise[i].GleisID;

			const Gleis = global.Gleissysteme[GleissystemID][GleisID];
			if (Gleis) {

				// simplified: calculate outer rectangle
				const posX = 12, posY = 13;

				if (minX === undefined ||
					minX > Gleis.mPos[posX]) { minX = Gleis.mPos[posX]; }
				if (maxX === undefined ||
					maxX < Gleis.mPos[posX]) { maxX = Gleis.mPos[posX]; }
				if (minY === undefined ||
					minY > Gleis.mPos[posY]) { minY = Gleis.mPos[posY]; }
				if (maxY === undefined ||
					maxY < Gleis.mPos[posY]) { maxY = Gleis.mPos[posY]; }

				if (minX > Gleis.mMid[posX]) { minX = Gleis.mMid[posX]; }
				if (maxX < Gleis.mMid[posX]) { maxX = Gleis.mMid[posX]; }
				if (minY > Gleis.mMid[posY]) { minY = Gleis.mMid[posY]; }
				if (maxY < Gleis.mMid[posY]) { maxY = Gleis.mMid[posY]; }

				if (minX > Gleis.mEnd[posX]) { minX = Gleis.mEnd[posX]; }
				if (maxX < Gleis.mEnd[posX]) { maxX = Gleis.mEnd[posX]; }
				if (minY > Gleis.mEnd[posY]) { minY = Gleis.mEnd[posY]; }
				if (maxY < Gleis.mEnd[posY]) { maxY = Gleis.mEnd[posY]; }

				// Collect start- mid- and end-points of Gleise to calculate the convex hull
				//points.push({ x: Gleis.mPos[posX], y: Gleis.mPos[posY], });
				//points.push({ x: Gleis.mMid[posX], y: Gleis.mMid[posY], });
				//points.push({ x: Gleis.mEnd[posX], y: Gleis.mEnd[posY], });

				// Extend the area of the hull a litte bit
				const d = 1;
				points.push({ x: Gleis.mPos[posX]+d, y: Gleis.mPos[posY]+d, });
				points.push({ x: Gleis.mMid[posX]+d, y: Gleis.mMid[posY]+d, });
				points.push({ x: Gleis.mEnd[posX]+d, y: Gleis.mEnd[posY]+d, });

				points.push({ x: Gleis.mPos[posX]+d, y: Gleis.mPos[posY]-d, });
				points.push({ x: Gleis.mMid[posX]+d, y: Gleis.mMid[posY]-d, });
				points.push({ x: Gleis.mEnd[posX]+d, y: Gleis.mEnd[posY]-d, });

				points.push({ x: Gleis.mPos[posX]-d, y: Gleis.mPos[posY]+d, });
				points.push({ x: Gleis.mMid[posX]-d, y: Gleis.mMid[posY]+d, });
				points.push({ x: Gleis.mEnd[posX]-d, y: Gleis.mEnd[posY]+d, });

				points.push({ x: Gleis.mPos[posX]-d, y: Gleis.mPos[posY]-d, });
				points.push({ x: Gleis.mMid[posX]-d, y: Gleis.mMid[posY]-d, });
				points.push({ x: Gleis.mEnd[posX]-d, y: Gleis.mEnd[posY]-d, });
			}
		}
/*console.log('Gleisobjekt ' + GleisobjektID
	+ ' min(' + minX.toFixed(1) + ' ' + minY.toFixed(1) + ') max(' + maxX.toFixed(1) + ' ' + maxY.toFixed(1) + ')'
)*/

		// Create svg group node
		if (!svgGleisobjekteGroup) {		// First Gleisobjekt
			// Show checkbox
			document.getElementById("CheckboxGleisobjekt").classList.remove("hidden");

			// Create svg group node
			svgGleisobjekteGroup = svgAppend(SVGfragment, {
				svg_tag	: `g`,
				id		: `Gleisobjekt`, // optional
				"class"	: `Gleisobjekt`,
			});
		}
		const svgGleisobjektGroup = svgAppend(svgGleisobjekteGroup, {
			svg_tag	: `g`,
			id		: `GO` + GleisobjektID,
			"class"	: `${TrackSystemCode[global.TrackSystem[GleissystemID]]}`
						+ ` height=${Gleisobjekt.PosZ.toFixed(2)}`	// Height
		});
		// simplified: show outer rectangle
		// <rect x="50" y="20" width="150" height="150"
		/*
		svgAppend(svgGleisobjektGroup, {
			svg_tag				: `rect`,
			x					: minX,
			y					: minY,
			width				: maxX - minX,
			height				: maxY - minY,
			//transform 			: matrixToTransform(...),
		});
		*/
		// Create svg for convex hull of Gleisobjekt
		// see https://www.nayuki.io/page/convex-hull-algorithm
		const hull = convexhull.makeHull(points);
		const svgPath = hull.map(function(point, i) {
								return (i === 0 ? "M" : " L") + point.x + " " + (-point.y);	// svg: mirrored y-coordinate
							}).join("") + "Z";
		svgAppend(svgGleisobjektGroup, {
			svg_tag				: `path`,
			d					: svgPath,
		});

	}
}

function createSVGforKameras(SVGfragment) {
/*
	in:
		sutrackp.getElementsByTagName("Kammerasammlung")

	mod:
		SVGfragment

*/
	// Process Kameras
/*
		Wendelsteins_Kurvenbrueck_v12

		<Kammera name="Stellwerk West" DOF="0" Dynamic="0" FocalIdx="193" FStopIdx="13" SubDist="100" DOFSubDist="100" DOFShiftNear="9.65" DOFShiftFar="11.96" FOV="0" TakeSwitch="0">
			<Dreibein>
				<Vektor x="-25064" y="-25576" z="2098">Pos</Vektor>
				<Vektor x="0.9711025" y="-0.2179571" z="-9.723549E-02">Dir</Vektor>
				<Vektor x="0.2189948" y="0.975726" z="0">Nor</Vektor>
				<Vektor x="0.0948752" y="-2.129407E-02" z="0.9952614">Bin</Vektor>
			</Dreibein>
		</Kammera>
		Position X:					-250.64	PosX
		Position Y:					-255.76	PosY
		Position Z:					20.98	PosZ
		Neigung X:					0.00
		Neigung Y:					5.58
		Neigung Z:					-12.65
		Sichtfeld:					0.00
		Schärfentiefe:				aus 	DOF (die nachfolgenden Parameter sind dann fix)
		Brennweite:					100.00	Brennweite[FocalIdx]
		Blendenwert:				f/3.6	Blende[FStopIdx]
		Objektentfernung:			100.0	SubDist
		Hyperfokale Entfernung: 	935.48
		Vor dem Zielobjekt:			9.65	DOFShiftNear
		Hinter dem Zielobjekt:		11.96	DOFShiftFar
		Objektentfernung:			100.0	DOFSubDist

		<Kammera name="Einfahrsignal West" DOF="0" Dynamic="0" FocalIdx="193" FStopIdx="13" SubDist="100" DOFSubDist="100" DOFShiftNear="9.65" DOFShiftFar="12.965" FOV="0" TakeSwitch="0">
			<Dreibein>
				<Vektor x="-45815.86" y="-23729.89" z="1437.605">Pos</Vektor>
				<Vektor x="7403.506" y="-2208.023" z="35.84314">Dir</Vektor>
				<Vektor x="0.2858036" y="0.9582962" z="3.385832E-08">Nor</Vektor>
				<Vektor x="-4.623935E-02" y="1.379063E-02" z="0.9988322">Bin</Vektor>
			</Dreibein>
		</Kammera>
		Position X:					-458.16	PosX
		Position Y:					-237.30	PosY
		Position Z:					14.38	PosZ
		Neigung X:					0.00
		Neigung Y:					-0.27
		Neigung Z:					-16,61
		Sichtfeld:					0.00
		Schärfentiefe:				aus 	DOF (die nachfolgenden Parameter sind dann fix)
		Brennweite:					100.00	Brennweite[FocalIdx]
		Blendenwert:				f/3.6	Blende[FStopIdx]
		Objektentfernung:			100.0	SubDist
		Hyperfokale Entfernung: 	935.48
		Vor dem Zielobjekt:			9.65	DOFShiftNear
		Hinter dem Zielobjekt:		11.96	DOFShiftFar
		Objektentfernung:			100.0	DOFSubDist
*/
	let svgKamerasGroup;
	const Kamerasammlung = sutrackp.getElementsByTagName("Kammerasammlung")[0];
	const Kameras = Kamerasammlung.getElementsByTagName("Kammera");
	let KameraID = 0;
	for (const Kamera of Kameras) {
		KameraID += 1;

		const Name 	= Kamera.getAttribute("name");
		/* Ignore not-used cameras
		Should we check the default name or the default position to identify such cameras?
		Some observations:
		- The default name is language dependent, see file eep.lng entry [OTHER]CAMERA_NAME
		- Pos and Dir seem to have quite specific values
		- Dir is not a unit vector
		- Nor and Bin values might vary
		<Kammera name="Leer" DOF="0" Dynamic="0" FocalIdx="193" FStopIdx="13" SubDist="100" DOFSubDist="100" DOFShiftNear="9.65" DOFShiftFar="12.965" FOV="0" TakeSwitch="0">
			<Dreibein>
				<Vektor x="6000" y="-6000" z="400">Pos</Vektor>
				<Vektor x="-6000" y="6000" z="-400">Dir</Vektor>
				<Vektor x="-0.7071068" y="-0.7071068" z="0">Nor</Vektor>
				<Vektor x="-3.329636E-02" y="3.329636E-02" z="0.9988908">Bin</Vektor>
			</Dreibein>
		</Kammera>
		*/
		if (Name === "Leer" || Name === "blank" || Name === "Vide" ) {
			continue;
		}

		// Store Kamera
		Kamera.Name 				= Name;
		Kamera.KameraID 			= KameraID;
		global.KameraSet[KameraID] 	= Kamera;

		/*
		<Kammera name="Anlage" DOF="0" Dynamic="0" FocalIdx="193" FStopIdx="13" SubDist="100" DOFSubDist="100" DOFShiftNear="9.65" DOFShiftFar="11.96" FOV="0.6981317" TakeSwitch="0">
		*/
		Kamera.Dynamic 	= Kamera.getAttribute("Dynamic");

		let mMatrix;
		let PosX, PosY, PosZ, DirX, DirY, DirZ, NorX, NorY, NorZ, BinX, BinY, BinZ;

		const Dreibein	= Kamera.getElementsByTagName("Dreibein")[0];
		const FramePos	= Dreibein.getElementsByTagName("Vektor")[0];
		const FrameDir	= Dreibein.getElementsByTagName("Vektor")[1];
		const FrameNor	= Dreibein.getElementsByTagName("Vektor")[2];
		const FrameBin	= Dreibein.getElementsByTagName("Vektor")[3];

		PosX = +FramePos.getAttribute("x") / 100;
		PosY = +FramePos.getAttribute("y") / 100;
		PosZ = +FramePos.getAttribute("z") / 100;

		// Bei den Kameras gibt der Dir-Vektor zum Teil sowohl die Blickrichtung wie auch die Sichtweite an und muss daher normalisiert werden
		DirX = +FrameDir.getAttribute("x");
		DirY = +FrameDir.getAttribute("y");
		DirZ = +FrameDir.getAttribute("z");
		const norm = Math.sqrt(DirX*DirX + DirY*DirY + DirZ*DirZ);
		DirX /= norm;
		DirY /= norm;
		DirZ /= norm;

		NorX = +FrameNor.getAttribute("x");
		NorY = +FrameNor.getAttribute("y");
		NorZ = +FrameNor.getAttribute("z");

		BinX = +FrameBin.getAttribute("x");
		BinY = +FrameBin.getAttribute("y");
		BinZ = +FrameBin.getAttribute("z");

		mMatrix = [DirX, DirY, DirZ, 0,    NorX, NorY, NorZ, 0,    BinX, BinY, BinZ, 0,    PosX, PosY, PosZ, 1 ];
		Kamera.mPos = mMatrix;

		// Process Kamera
		if (!svgKamerasGroup) { // First Kamera
			// Show checkbox
			document.getElementById("CheckboxKamera").classList.remove("hidden");
		}
		svgKamerasGroup = createSVGforCamera(SVGfragment, svgKamerasGroup, Kamera);
	}
}

function createSVGforCamera(SVGfragment, svgKamerasGroup, Kamera) {

	const Laenge = 40; // arbitrary length

	if (!svgKamerasGroup) { // First Kamera
		// Create svg group node
		svgKamerasGroup = svgAppend(SVGfragment, {
			svg_tag	: `g`,
			id		: `Kamera`,
			"class"	: `Kamera`,
		});
	}

	const svgKameraGroup = svgAppend(svgKamerasGroup, {
		svg_tag	: `g`,
		id		: Kamera.KameraID,
	});

	// Show circle at Point
	svgAppend(svgKameraGroup, {
		svg_tag				: `circle`,
		r					: 2,
		transform 			: matrixToTransform(Kamera.mPos),
	});

	// Draw Line
	svgAppend(svgKameraGroup, {
		svg_tag				: `path`,
		d 					: `M 2 0 H ${Laenge}`,
		transform 			: matrixToTransform(Kamera.mPos)
	});

	//Show Name
	svgAppend(svgKameraGroup, {
		svg_tag			: `text`,
		text			: Kamera.Name,			// 📷 \u1F4F7
		dx				: `2`, 			// Shift text right
		dy				: `-0.3em`, 	// Shift text up
		//dy			: `1em`, 		// Shift text below the track
		transform: matrixToTransform(Kamera.mPos)
			+ ` scale(1 -1)`,																   
	});

	// show Hoehe in the middle below the track (left-adjusted)
	svgAppend(svgKameraGroup, {
		svg_tag			: `text`,
		text			: `[${Kamera.mPos[14].toFixed(0)}m]`, // PosZ
		dx				: `2`, 		// Shift text right a little bit
		dy				: `1em`, 		// Shift text below the track
		"class"			: `Hoehe`,
		transform: matrixToTransform(Kamera.mPos)
			+ ` scale(1 -1)`,
	});				   

	return svgKamerasGroup;									   
}

function createSVGforRahmen(SVGfragment) {
/*
	in:
		sutrackp.getElementsByTagName("Schandlaft")
		global.usedArea

	mod:
		document.getElementById("heightArea")
		global.usedArea
		SVGfragment

*/
	// Show min/max height
	const text = (global.usedArea.min.z).toFixed(0) + " .. " + (global.usedArea.max.z).toFixed(0);
	document.getElementById("heightArea").textContent = text;

	// Groesse der Anlage (alle Positionsangaben in m statt cm)
	const Schandlaft 	= sutrackp.getElementsByTagName("Schandlaft")[0];
	const Area = {
		min : {
			x : Schandlaft.getAttribute("posX") / 100,
			y : Schandlaft.getAttribute("posY") / 100,
		},
		width  	: Math.abs(Schandlaft.getAttribute("posX") * 2 / 100),
		height 	: Math.abs(Schandlaft.getAttribute("posY") * 2 / 100),
	};

	// Verwendeter Bereich der Anlage anpassen (nicht größer als die Anlage selber)
	global.usedArea.min.x = Math.max( global.usedArea.min.x, Area.min.x );
	global.usedArea.min.y = Math.max( global.usedArea.min.y, Area.min.y );
	global.usedArea.max.x = Math.min( global.usedArea.max.x, Area.min.x + Area.width  );
	global.usedArea.max.y = Math.min( global.usedArea.max.y, Area.min.y + Area.height );

	// Group for additional general elements
	let svg_general_group = svgAppend(SVGfragment, {
		svg_tag	: `g`,
		id		: `general`, // optional
		"class"	: `general`,
	});

	// Box zur Anzeige der Groesse der Anlage
	// <rect class="box" x="-503" y="-303" width="1006" height="606" />
	svgAppend(svg_general_group, {
		svg_tag	: `rect`,
		"class"	: `box`,
		x		:  Area.min.x,
		y		:  - Area.height - Area.min.y,	// svg: mirrored y-coordinate
		width	:  Area.width,
		height	:  Area.height,
	});
	// Box zur Anzeige des verwendeten Teils der Anlage
	// <rect class="box" x="-175" y="-140" width="382" height="305" />
	svgAppend(svg_general_group, {
		svg_tag	: `rect`,
		"class"	: `box`,
		x		:  global.usedArea.min.x,
		y		:  - global.usedArea.max.y,	// svg: mirrored y-coordinate
		width	:  global.usedArea.max.x - global.usedArea.min.x,
		height	:  global.usedArea.max.y - global.usedArea.min.y,
	});
	// Zusätzliche Markierung des Zentrums
	// <circle id="center" cx="0" cy="0" r="1" />
	svgAppend(svg_general_group, {
		svg_tag	: `circle`,
		id		: `center`,
		cx		:  `0`,
		cy		:  `0`,
		r		:  `1`,
	});
}

// Generate matrix command for svg
function matrixToTransform(m) {
	//       `matrix(${DirX} ${DirY} ${NorX} ${NorY} ${PosX} ${PosY})`
	//return `matrix(${m[0]} ${m[1]} ${m[4]} ${m[5]} ${m[12]} ${(m[13])})`;

/* https://wiki.selfhtml.org/wiki/SVG/Transformationen#matrix
transform="matrix(1,0,0,1,0,0)" ist die Identität. Diese Angabe hat also überhaupt keinen Effekt.
transform="matrix(1,0,0,1,x,y)" entspricht transform="translate(x,y)".
transform="matrix(x,0,0,y,0,0)" entspricht transform="scale(x,y)".
transform="matrix(1,0,tan(α),1,0,0)" entspricht transform="skewX(α)".
transform="matrix(1,tan(α),0,1,0,0)" entspricht transform="skewY(α)".
transform="matrix(cos(α),sin(α),-sin(α),cos(α),0,0)" entspricht transform="rotate(α)".
Eigentlich entspricht diese Drehmatrix der Drehung gegen den Uhrzeigersinn während rotate im Uhrzeigersinn dreht, sodass der Parameter der trigonometrischen Funktionen -α statt α sein müsste. Jedoch ist in SVG die y-Achse falschherum, wodurch sich dies gegenseitig aufhebt.
transform="matrix(cos(α),sin(α),-sin(α),cos(α),x,y) matrix(1,0,0,1,-x,-y)" entspricht transform="rotate(α,x,y)"
*/

	const [	DirX, DirY, DirZ, d0,
			NorX, NorY, NorZ, n0,
			BinX, BinY, BinZ, b0,
			PosX, PosY, PosZ, scale ] = m;
	return `matrix(${DirX} ${-DirY} ${NorX} ${-NorY} ${PosX} ${-PosY})`;	// svg: mirrored y-coordinate
}

function calcBezierPoint(BezierPointsArray, position, near, far) {
	// find position on bezier curve
	let lengthPrevSegments = 0.0;
	for (let I = 0; I < BezierPointsArray.length; I++) {
	
		const Index = (near > far ? BezierPointsArray.length - 1 - I : I);	// reverse / normal
		const BezierPoints = BezierPointsArray[Index];

		// BezierPoints = [ [B1X, B1Y, B1Z], [B2X, B2Y, B2Z], [B3X, B3Y, B3Z], [B4X, B4Y, B4Z], arcLength ];
		const arcLength = BezierPoints[4];

		if ( I + 1 == BezierPointsArray.length || 			// assertion to end the loop in case of rounding issues
			 lengthPrevSegments + arcLength >= position		// does this segment contains the position?
		   ) {
			// find relative position on this segment		// assertion to stay in interval [0, 1]
			const t = Math.min( Math.max( (position - lengthPrevSegments) / arcLength , 0), 1);
			// [DeltaX, DeltaY, DeltaZ, Winkel] calcBezierCurve(BezierPoints, t); 
			return calcBezierCurve(BezierPoints, t); 

		} else {
			// continue with next segment
			lengthPrevSegments += arcLength;
		}
	}
}

function calcBezierCurve(BezierPoints, t) {
	// BezierPoints = [ [B1X, B1Y, B1Z], [B2X, B2Y, B2Z], [B3X, B3Y, B3Z], [B4X, B4Y, B4Z], arcLength ];
	const B1X = BezierPoints[0][0]; // = aX;
	const B1Y = BezierPoints[0][1]; // = aY;
	const B1Z = BezierPoints[0][2]; // = aZ;
	const B2X = BezierPoints[1][0]; // = aX +bX/3;
	const B2Y = BezierPoints[1][1]; // = aX +bY/3;
	const B2Z = BezierPoints[1][2]; // = aX +bZ/3;
	const B3X = BezierPoints[2][0]; // = aX +bX*2/3 +cX/3;
	const B3Y = BezierPoints[2][1]; // = aX +bY*2/3 +cY/3;
	const B3Z = BezierPoints[2][2]; // = aX +bZ*2/3 +cZ/3;
	const B4X = BezierPoints[3][0]; // = aX +bX     +cX   +dX;
	const B4Y = BezierPoints[3][1]; // = aX +bY     +cY   +dY;
	const B4Z = BezierPoints[3][2]; // = aX +bZ     +cZ   +dZ;
	//const arcLength = BezierPoints[4];

	// Split the Bezier curve into two parts to calculate the position of the point
	// https://pomax.github.io/bezierinfo/#matrixsplit
	// P(t) = (1-t)^3*B1 + 3t(1-t)^2*B2 + 3t^2(1-t)*B3 + t^3*B4
	const DeltaX = (1-t)**3*B1X + 3*t*(1-t)**2*B2X + 3*t**2*(1-t)*B3X + t**3*B4X;
	const DeltaY = (1-t)**3*B1Y + 3*t*(1-t)**2*B2Y + 3*t**2*(1-t)*B3Y + t**3*B4Y;
	const DeltaZ = (1-t)**3*B1Z + 3*t*(1-t)**2*B2Z + 3*t**2*(1-t)*B3Z + t**3*B4Z;

	// Rotation = Winkel of Tangent
	// P(t)     = (1-t)^3*B1    + 3t(1-t)^2*B2             + 3t^2(1-t)*B3         + t^3*B4
	// dP(t)/dt = -3(1-t)^2*B1  + 3(1-t)^2*B2 - 6(1-t)t*B2 + 6t(1-t)*B3 - 3t^2*B3 + 3t^2*B4
	const dPX = -3*B1X*(1-t)**2  + B2X*3*(1-t)**2 - B2X*6*(1-t)*t  + B3X*6*(1-t)*t - B3X*3*t**2  + 3*B4X*t**2;
	const dPY = -3*B1Y*(1-t)**2  + B2Y*3*(1-t)**2 - B2Y*6*(1-t)*t  + B3Y*6*(1-t)*t - B3Y*3*t**2  + 3*B4Y*t**2;
	const dPZ = -3*B1Z*(1-t)**2  + B2Z*3*(1-t)**2 - B2Z*6*(1-t)*t  + B3Z*6*(1-t)*t - B3Z*3*t**2  + 3*B4Z*t**2;
	const Winkel = Math.atan2(dPY, dPX);

	return [DeltaX, DeltaY, DeltaZ, Winkel];
}

function calcClothoidCurve(A, L1, L2, RotationCCW) {
	// Approximate clothoid line
	/*	R = radius
		L = length
		A^2 = R*L

		x  = integral[L1,L2](cos(φ) dl)
		dx = cos(φ) dl
		y  = integral[L1,L2](sin(φ) dl)
		dy = cos(φ) dl

		φ is a function of l
		dφ/dL = 1/R = L/A^2
		φ = L^2/(2*A^2) = ( L/(A*sqrt(2)) )^2

		let
		s = L/(A*sqrt(2))

		then
		φ = s^2
		l = s*A*sqrt(2)
		dl = ds*A*sqrt(2)

		x = A*sqrt(2) * integral[s1,s2](cos(s^2) ds)
		y = A*sqrt(2) * integral[s1,s2](sin(s^2) ds)
	*/

	const STEPCOUNT = 1000;

	const sign 	= RotationCCW;

	const a 	= A*Math.sqrt(2);

	const s1 	= (L1<L2 ? L1 : L2)/a;				// curvature = 1/radius at start point
	const s2 	= (L1<L2 ? L2 : L1)/a;				// curvature = 1/radius at end point

	let   s 	= 0;				// curvature at current point (we have to start at 0 0)
	const s0 	= s*s;				// angle at start point
	let   w;
	let   ds 	= s2/STEPCOUNT;		// delta curvature per step
	const ads	= a * ds;			// factor used in loop

	let   p2 	= {x:0,y:0};		// next point
	let   p		= p2;				// current point

	let   dx, dy;					// delta between points

	let   b1, b2, b3, b4;			// Bezier points

	const pathPoints = [];

	for (let i = 1; i <= STEPCOUNT; i++) {
		p.x = p2.x;													// Set current point
		p.y = p2.y;

		w = s*s-s0;
		p2.x += dx =        ads * Math.cos(w);						// Calculate next point
		p2.y += dy = sign * ads * Math.sin(w);

		if (!b1 && ( Math.abs(s)>=Math.abs(s1) || i === STEPCOUNT ) ) {
			b1 = {x: p.x,   y: p.y,	  dx: dx,  dy: dy,  w: w, };			// first 1. Bezier point

			pathPoints.push( {x: b1.x,   y: -b1.y,  z: 0,  w: b1.w, } );	// first 1. Bezier point
		}

		const f = 4;	// limit 4: max 45°, 3: max 60°
		if ( (b1 && Math.abs(w - b1.w) > (Math.PI / f)) 			// Draw new curve if difference of the angles exceeds limit
			|| i === STEPCOUNT )  {									// or to cover the last point
			// if yes, draw the next part

			b4 = { x: p2.x,  y: p2.y,  dx: dx,  dy: dy,  w: w, };			// 4. Bezier point
																			// 3. Bezier point on intersection of tangents
			if ( ( (b1.dy / b1.dx) == (b4.dy / b4.dx) ) || ( (b4.dy / b4.dx) == (b1.dy / b1.dx) ) ) {
				b3 = {	// dummy point if the tangents are equal
						x: b4.x,
						y: b4.y,
					};
			} else {
				b3 = {
						x: b1.x + ( (b4.x - b1.x) - (b4.y - b1.y) / (b4.dy / b4.dx) ) / ( 1 - ( (b1.dy / b1.dx) / (b4.dy / b4.dx)) ),
						y: b1.y + ( (b4.y - b1.y) - (b4.x - b1.x) * (b4.dy / b4.dx) ) / ( 1 - ( (b4.dy / b4.dx) / (b1.dy / b1.dx)) ),
					};
			}
			b2 = {															// 2. Bezier point on tangent near B1
					x: b1.x + (b3.x - b1.x) / f,							// works fine with f=4, but not with f=3
					y: b1.y + (b3.y - b1.y) / f,							// (I guess we should calculate the factor dependant on s or a)
				};

			if (L1 < L2) {	// forward
				pathPoints.push( 	{x: b2.x,   y: -b2.y, } );					// 2. Bezier point
				pathPoints.push( 	{x: b3.x,   y: -b3.y, } );					// 3. Bezier point
				pathPoints.push( 	{x: b4.x,   y: -b4.y,  z: 0,  w: b4.w, } );	// 4. Bezier point
			} else {		// backward
				pathPoints.unshift( {x: b2.x,   y: -b2.y, } );					// 2. Bezier point
				pathPoints.unshift( {x: b3.x,   y: -b3.y, } );					// 3. Bezier point
				pathPoints.unshift( {x: b4.x,   y: -b4.y,  z: 0,  w: b4.w, } );	// 4. Bezier point
			}

			// Prepare next part
			b1 = { x: b4.x,  y: b4.y,  dx: dx,  dy: dy,  w: w, };	// next 1. Bezier point
		}

		// next
		s += ds;
	}

	// Create svg path command
	let i;
	let svgBezierPath  = "M "  + pathPoints[0].x   + " " + pathPoints[0].y; // Complete path e.g. "M 60 -100 C 100 100 421 154 406 249 C ..."
	for (i=1; i<pathPoints.length; i=i+3) {
		svgBezierPath += " C " + pathPoints[i].x   + " " + pathPoints[i].y
					  +  " "   + pathPoints[i+1].x + " " + pathPoints[i+1].y
					  +  " "   + pathPoints[i+2].x + " " + pathPoints[i+2].y;
	}

	// Get start and end point
	const points = {};									// Result points
	i = 0;
	points.Pos		= {								 	// Start point
		x: 		pathPoints[i].x,
		y: 		pathPoints[i].y,
		z: 		pathPoints[i].z,
		Winkel: pathPoints[i].w + (L1<L2 ? 0 : Math.PI), };
	i = pathPoints.length-1;
	points.End		= {								 	// End point
		x: 		pathPoints[i].x,
		y: 		pathPoints[i].y,
		z: 		pathPoints[i].z,
		Winkel: pathPoints[i].w + (L1<L2 ? 0 : Math.PI), };

	return [points, svgBezierPath];
}

function svgAppend(svg_node, obj) {
	const svgNS 	= "http://www.w3.org/2000/svg";
	//const xlinkNS	= "http://www.w3.org/1999/xlink";

	// The lightweight library for manipulating and animating SVG: https://github.com/svgdotjs/svg.js
	// https://svgjs.dev/docs/3.0/

	// planned: optimize sequence of transform operations based on https://github.com/svg/svgo
	/*
	https://github.com/svg/svgo/blob/master/plugins/convertTransform.js
	Convert matrices to the short aliases,
	Convert long translate, scale or rotate transform notations to the shorts ones,
	Convert transforms to the matrices and multiply them all into one,
	Remove useless transforms.
	Limit transform precision with matrix one. Calculating with larger precision doesn't add any value.
	No sense in angle precision more then number of significant digits in matrix.
	Convert fixed-point numbers: 12.754997 → 12.755
	Convert long translate transform notation to the shorts one: translate(10 0) → translate(10)
	Convert long scale transform notation to the shorts one: scale(2 2) → scale(2)
	Convert long rotate transform notation to the short one: translate(cx cy) rotate(a) translate(-cx -cy) → rotate(a cx cy)
	Decrease accuracy of floating-point numbers in transforms keeping a specified number of decimals: Smart rounds values like 2.349 to 2.35.
	*/
	
	/* SVG operates in 2D, however, using CSS styles for the SVG elements we could enable 3D:
	https://oreillymedia.github.io/Using_SVG/extras/ch11-3d.html
	https://css-tricks.com/things-watch-working-css-3d/
	
	transform-style: preserve-3d: 
	translate3d(tx, ty, tz): translate it by the given lengths along each axis
	translateZ(tz): similar to the new translateX and translateY functions, this shorthand allows you to specify a translation along the z-axis only
	scale3d(sx,sy,sz): change the scale in all dimensions by the specified factors
	scaleZ(sz): change the z-scale only (similar to the new scaleX and scaleY functions)
	rotateX(a): use the x-axis as a pivot (or hinge) to rotate the coordinate system by the specified angle; x-coordinates will not change, but y and z coordinates will
	rotateY(a): use the y-axis as a pivot to rotate the coordinate system by the specified angle; y-coordinates will not change, but x and z coordinates will
	rotateZ(a): use the z-axis as a pivot to rotate the coordinate system by the specified angle; this has the same effect on coordinates as the 2D rotate function, but it forces 3D drawing methods to be used
	rotate3d(vx,vy,vz,a): create a pivot using the vector (straight line) from the origin to the point (vx,vy,vz), and rotate the coordinate system around it by the angle a. The official definition of how to calculate the rotation involves extensive trigonometry. As an heuristic, the direction of rotation for a positive angle is determined by pointing the thumb along the pivot vector, and then curving the fingers; as always, you would use the left hand for the default coordinate system and the right hand for a reflected coordinate system.
	For all these functions, the CSS syntax rules apply: angles and lengths must include units.

	Another option would be to replace svg with x3d based on https://www.x3dom.org/
	*/

	let element = document.createElementNS(svgNS, obj.svg_tag);

	// copy all attributes except the tag and the text
	for (const [key, value] of Object.entries(obj)) {
		if (key !== "svg_tag" && key !== "text") {
			// reduce precission of numbers ( simulated floor() operation )
			const valueString = (""+value).replace(/(\.\d{0,5})\d*/g, "$1");

			element.setAttribute(key, valueString);
		}
	}

	if (obj.svg_tag === "text") {
		const textNode 	= document.createTextNode(obj.text);
		element.appendChild(textNode);
	}

	svg_node.appendChild(element);
	return element;
}

} // end function createSVG

/* Not used anymore
function svgAppendTextPath(svg_node, obj) {
	const svgNS 	= "http://www.w3.org/2000/svg";
	const xlinkNS	= "http://www.w3.org/1999/xlink";

	// Create special element using attributes href, text, text-anchor (optional)
	// Example:
	// <text><textPath startOffset="50%" href="#G1-1">1</textPath></text>

	const textNode 	= document.createTextNode(obj.text);

	const textPath 	= document.createElementNS(svgNS, "textPath");
	textPath.setAttribute("class", obj.class);
	if (obj["text-anchor"] === "middle") {
		textPath.setAttribute("startOffset", "50%");
	}
	else if (obj["text-anchor"] === "end") {
		textPath.setAttribute("startOffset", "90%"); // How to put the text exactly to the end?
	}
	textPath.setAttributeNS(xlinkNS, "xlink:href", obj.href);
	textPath.appendChild(textNode);

	const text 		= document.createElementNS(svgNS, "text");
	if (obj["text-anchor"]) { text.setAttribute("text-anchor", obj["text-anchor"]); }
	text.appendChild(textPath);
	text.setAttribute("dy", "-0.1em"); // Shift text up the track

	svg_node.appendChild(text);

	return text;
}
*/
/*
})(this); // end module
*/
</script>

</section>  <!-- Selection screen -->

<section id="loading" class="hidden"> <!-- Progress bar screen -->
<span lang="de">Lade</span><span lang="en">Load</span><span lang="fr">Charge</span>... <progress id="progress" class="hidden" max="100"></progress>
<style> /* Progress bar screen */
/* <![CDATA[ */
#loading {						/* progress bar */
	text-align: center;
	width: 100%;
}
/* ]]> */
</style>
</section> <!-- Progress bar screen -->

<main id="main" class="column hidden"> <!-- Main screen -->
<style> /* Flex main screen */
/* <![CDATA[ */
#main {
	margin: 0;
	padding: 0;
}

/* flex */

#main {
	height: 100vh;
}

#main.column {
	display: flex;				/* top level flex */
	flex-direction: column; 	/* vertically stacked */
}
#main.column #heading {
	flex: 0;					/* shrink as much as possible */
	margin-bottom: 0px;
	border-bottom: 1px dotted #3983ab;
}
#main.column #container {
	flex: 1;					/* grow as much as possible */

	display: flex;				/* second level flex for svg */
}
#main.column #controls {
	display: flex;				/* second level flex for article within heading */
	flex-direction: row; 		/* horizontally */
	flex-wrap: wrap;
	justify-content: space-between;
	margin-left: 0px;
	margin-right: 0px;
}
#main.column #controls .group {
	flex: 1;
	margin: 0px;
	border-right: 1px dotted;
	padding-top: 5px;
	padding-left: 5px;
	padding-right: 5px;
}

#main.row {
	display: flex;
	flex-direction: row; 		/* side by side */
}
#main.row #heading {
	flex: 1;					/* 1/5 = width: 20% */
	border-right: 1px dotted #3983ab;
}
#main.row #container {
	flex: 4;					/* 4/5 = width: 80% */

	display: flex;				/* second level flex for svg */
}
#main.row #controls {
	display: flex;				/* second level flex for div within heading */
	flex-direction: column; 	/* vertically */
	flex-wrap: wrap;
	justify-content: space-between;
}
#main.row #controls .group {
	flex: 1;
	margin: 5px;
}

#svg {
	flex: 1;
	height: 100%;
}
/* ]]> */
</style>

<section id="heading"> <!-- The heading shows the header and the controls -->
<style> /* heading */
/* <![CDATA[ */
#heading {
	background-color: var(--body-background-color);
	color: var(--body-text-color);
}

#controls input[type="number"]#number,
input[type="number"]#sizePNG,
input[type="number"]#exportSize,
input[type="number"]#jpgQuality {
	width:60px;
}

#controls .fieldset {
	border-width: 0;
	margin-inline-start: 0;
	margin-inline-end: 0;
	padding-block-start: 0;
	padding-inline-start: 0;
	padding-inline-end: 0;
	padding-block-end: 0;
}
#controls .item {
	white-space: nowrap;		/* keep checkbox and label together */
	display:inline;				/* but do no add extra line breaks per item */
}
/* ]]> */
</style>

<header class="group">
<h3 id="filename"></h3>
</header>

<nav id="controls"> <!-- controls -->

<article class="group no-select"> <!-- Buttons, line and font size -->
<button id="swap"><span lang="de">Tauschen</span><span lang="en">Swap</span><span lang="fr">Échanger</span></button>
<!--<input type="number" name="sizePNG" id="sizePNG" value="3000" min="1"> -->
<button id="savePNG" class="svgControl"><span lang="de">Export</span><span lang="en">Export</span><span lang="fr">Exp.</span> PNG/JPG/SVG</button>
<button id="setColors"><span lang="de">Farben</span><span lang="en">Colours</span><span lang="fr">Couleurs</span></button>
<br>
<button id="zoom-in" class="svgControl">+</button>
<button id="zoom-out" class="svgControl">-</button>
<button id="resetzoom"><span lang="de">Zoom zurücksetzen</span><span lang="en">Reset zoom</span><span lang="fr">Réinit. le zoom</span></button>
<button id="reset"><span lang="de">Alles zurücksetzen</span><span lang="en">Reset all</span><span lang="fr">Réinit. tout</span></button>
<!-- enable/disable of controls of SvgPanZoom within the graphic
	<button id="enable">enable controls</button>
	<button id="disable">disable controls</button>
-->
<br>
<div class="svgControl">					
<span lang="de">Linie</span><span lang="en">Line</span><span lang="fr">Ligne</span>&nbsp;<input type="range" min="1" max="150" value="75" name="strokeWidth" id="strokeWidth" autocomplete="off" />
<!-- <fieldset class="fieldset"> -->
<span class="item"><label id="Checkbox_autoStrokeWidth"> <!-- Firefox keeps the status of the checkbox between page loads by default. -->
<input type="checkbox" id="autoStrokeWidth" name="autoStrokeWidth" checked autocomplete="off" /><span lang="de">Auto</span><span lang="en">Auto</span><span lang="fr">Auto</span>	 <!-- Automatisch / Automatically / Automatiquement -->
</label></span>
<!-- </fieldset> -->
<br>
<span lang="de">Schrift</span><span lang="en">Font</span><span lang="fr">Écriture</span>&nbsp;<input type="range" min="1" max="100" value="75" name="fontSize" id="fontSize" autocomplete="off" />
</div>		  
</article>

<article class="group no-select"> <!-- Auswahl des im Zentrum anzuzeigendes Objektes -->
<!-- How to translate options?
This CSS rule does not work because the default option still shows just the first option:
#selectObject option[lang=de] {display: none;}
It does not work if I put span elements inside of the options.
-->
<!--
<select id="selectObject" >
	<option value="1" lang="de" checked>Eisenbahn</option>
	<option value="1" lang="en" checked>Railroad</option>
	<option value="1" lang="fr" checked>Ferroviaire</option>
	<option value="2" lang="de">Straßenbahn</option>
	<option value="2" lang="en">Tram</option>
	<option value="2" lang="fr">Tram</option>
	<option value="3" lang="de">Straße</option>
	<option value="3" lang="en">Road</option>
	<option value="3" lang="fr">Routière</option>
	<option value="4" lang="de">Wasserwege</option>
	<option value="4" lang="en">Waterways</option>
	<option value="4" lang="fr">Navigable</option>
	<option value="5" lang="de">Steuerstrecken</option>
	<option value="5" lang="en">Control routes</option>
	<option value="5" lang="fr">Control routes</option>
	<option value="6" lang="de">GBS</option>
	<option value="6" lang="en">GBS</option>
	<option value="6" lang="fr">GBS</option>
	<option value="I" lang="de">Signal/Weiche</option>
	<option value="I" lang="en">Signal/Switch</option>
	<option value="I" lang="fr">Signal/Aiguillage</option>
	<option value="K">Kontakt</option>
	<option value="K">Contact</option>
	<option value="K">Contact</option>
</select>
-->
<!-- This workround using multiple selects works well -->
<select lang="de" id="selectObjectDE" >
	<option value="1">Eisenbahn</option>
	<option value="2">Straßenbahn</option>
	<option value="3">Straße</option>
	<option value="4">Wasserwege</option>
	<option value="5">Steuerstrecken</option>
	<option value="6">GBS</option>
	<option value="I">Signal/Weiche</option>
<!--
	<option value="K">Kontakt</option>
-->
</select>
<select lang="en" id="selectObjectEN" >
	<option value="1">Railroad</option>
	<option value="2">Tram</option>
	<option value="3">Road</option>
	<option value="4">Waterways</option>
	<option value="5">Control routes</option>
	<option value="6">GBS</option>
	<option value="I">Signal/Switch</option>
<!--
	<option value="K">Contact</option>
-->
</select>
<select lang="fr" id="selectObjectFR" >
	<option value="1">Ferroviaire</option>
	<option value="2">Tram</option>
	<option value="3">Routière</option>
	<option value="4">Navigable</option>
	<option value="5">Control routes</option>
	<option value="6">GBS</option>
	<option value="I">Signal/Aiguillage</option>
<!--
	<option value="K">Contact</option>
-->
</select>
<input type="number" id="number" value="1" min="1">
<button id="centerItem"><span lang="de">Zeige Objekt</span><span lang="en">Show object</span><span lang="fr">Afficher l'objet</span></button>
<div id="message"></div>
</article>

<article class="group"> <!-- Status line -->
<span lang="de">Min/Max Höhe der Anlage</span><span lang="en">Min / Max height of the system</span><span lang="fr">Hauteur min / max du système</span>: <span id="heightArea"></span><br>

<!-- Begin: Two handled slider for min/max height -->
<link rel="stylesheet" href="css/multi_range_slider.css"> <!-- multi range slider -->
<style>
/* <![CDATA[ */
#heightRange {
	width: 200px;
}
/* ]]> */
</style>
<input id="heightRange" type="range" multiple min="0" max="100" value="0,100" data-drag-middle /><br>
<script type="text/javascript" src="js/multi_range_slider.js"></script> <!-- multi range slider -->
<!-- End: Two handled slider for min/max height -->

<div class="svgControl">
<span lang="de">Sichtbarer Bereich</span><span lang="en">Visible area</span><span lang="fr">Zone visible</span>: <span id="visibleArea"> </span><br>
<span lang="de">Zentrum des Bereichs</span><span lang="en">Center of the area</span><span lang="fr">Centre de la zone</span>: <span id="centerPosition"> </span><br>
<span lang="de">Cursor</span><span lang="en">Cursor</span><span lang="fr">Curseur</span>: <span id="cursorPosition"> </span>
</div>
</article>

<article class="group no-select"> <!-- Auswahl der anzuzeigenden Objekte. class=hidden wird für diese Objekte enfernt wenn eine Checkbox aktiv ist -->
<fieldset class="fieldset">
	<!-- Firefox keeps the status of the checkbox between page loads by default. -->
	<div class="item Eisenbahn hidden"><label>					<!-- only visible if there are elements of that type -->
	<input type="checkbox" name="Eisenbahn" 	checked autocomplete="off" onchange="toggleElements('.Eisenbahn', this.checked)"><span lang="de">Eisenbahn</span><span lang="en">Railroad</span><span lang="fr">Ferroviaire</span></label></div>
	<div class="item Strassenbahn hidden"><label>				<!-- only visible if there are elements of that type -->
	<input type="checkbox" name="Strassenbahn" 	checked autocomplete="off" onchange="toggleElements('.Strassenbahn', this.checked)"><span lang="de">Straßenbahn</span><span lang="en">Tram</span><span lang="fr">Tram</span></label></div>
	<div class="item Strasse hidden"><label>					<!-- only visible if there are elements of that type -->
	<input type="checkbox" name="Strasse" 		checked autocomplete="off" onchange="toggleElements('.Strasse', this.checked)"><span lang="de">Straße</span><span lang="en">Road</span><span lang="fr">Routière</span></label></div>
	<div class="item Wasserwege hidden"><label>					<!-- only visible if there are elements of that type -->
	<input type="checkbox" name="Wasserwege" 	checked autocomplete="off" onchange="toggleElements('.Wasserwege', this.checked)"><span lang="de">Wasserwege</span><span lang="en">Waterways</span><span lang="fr">Navigable</span></label></div>
	<div class="item Steuerstrecken hidden"><label>				<!-- only visible if there are elements of that type -->
	<input type="checkbox" name="Steuerstrecken" checked autocomplete="off" onchange="toggleElements('.Steuerstrecken', this.checked)"><span lang="de">Steuerstrecken</span><span lang="en">Control routes</span><span lang="fr">Itinéraires de contrôle</span></label></div>
	<div class="item GBS hidden"><label>						<!-- only visible if there are elements of that type -->
	<input type="checkbox" name="GBS" 			checked autocomplete="off" onchange="toggleElements('.GBS', this.checked)"><span lang="de">GBS</span><span lang="en">GBS</span><span lang="fr">GBS</span></label></div>
	<div class="item"><label>	<!-- GleisID -->
	<input type="checkbox" name="GleisID" 		checked autocomplete="off" onchange="toggleElements('.GleisID', this.checked)"><span lang="de">Gleis ID</span><span lang="en">Track ID</span><span lang="fr">ID de voie</span></label></div>
	<div class="item hidden" id="CheckboxCurveType"><label>		<!-- only visible if there are elements of that type = EEP 16 -->
	<input type="checkbox" name="CurveType" 	checked autocomplete="off" onchange="toggleElements('.CurveType', this.checked)"><span lang="de">Kurventyp</span><span lang="en">Curve type</span><span lang="fr">Type de courbe</span></label></div>
	<div class="item"><label>	<!-- Stil -->
	<input type="checkbox" name="Stil" 			checked autocomplete="off" onchange="toggleElements('.Stil', this.checked)"><span lang="de">Stil</span><span lang="en">Style</span><span lang="fr">Style</span></label></div>
	<div class="item"><label>	<!-- Hoehe -->
	<input type="checkbox" name="Hoehe" 		checked autocomplete="off" onchange="toggleElements('.Hoehe', this.checked)"><span lang="de">Höhe</span><span lang="en">Height</span><span lang="fr">Hauteur</span></label></div>
	<div class="item"><label>	<!-- WeicheText -->
	<input type="checkbox" name="WeicheText" 	checked autocomplete="off" onchange="toggleElements('.WeicheText', this.checked)"><span lang="de">Weichen</span><span lang="en">Switches</span><span lang="fr">Aguillages</span></label></div>
	<div class="item"><label>	<!-- Signal -->
	<input type="checkbox" name="Signal" 		checked autocomplete="off" onchange="toggleElements('.Signal', this.checked)"><span lang="de">Signale</span><span lang="en">Signals</span><span lang="fr">Signaux</span></label></div>
	<div class="item"><label>	<!-- Kontakt -->
	<input type="checkbox" name="Kontakt" 		checked autocomplete="off" onchange="toggleElements('.Kontakt', this.checked)"><span lang="de">Kontakte</span><span lang="en">Contacts</span><span lang="fr">Contacts</span></label></div>
	<div class="item"><label>	<!-- active -->
	<input type="checkbox" name="active" 		checked autocomplete="off" onchange="toggleElements('.active', this.checked)"><span lang="de">aktiv</span><span lang="en">active</span><span lang="fr">actif</span></label></div>
	<div class="item"><label>	<!-- inactive -->
	<input type="checkbox" name="inactive" 		checked autocomplete="off" onchange="toggleElements('.inactive', this.checked)"><span lang="de">inaktiv</span><span lang="en">inactive</span><span lang="fr">inactif</span></label></div>
	<div class="item"><label>	<!-- sichtbar -->
	<input type="checkbox" name="sichtbar" 		checked autocomplete="off" onchange="toggleElements('.sichtbar', this.checked)"><span lang="de">sichtbar</span><span lang="en">visible</span><span lang="fr">visible</span></label></div>
	<div class="item"><label>	<!-- unsichtbar -->
	<input type="checkbox" name="unsichtbar" 	checked autocomplete="off" onchange="toggleElements('.unsichtbar', this.checked)"><span lang="de">unsichtbar</span><span lang="en">invisible</span><span lang="fr">invisible</span></label></div>
	<div class="item"><label>	<!-- virtual -->
	<input type="checkbox" name="virtual" 	    checked autocomplete="off" onchange="toggleElements('.virtual', this.checked)"><span lang="de">virtuell</span><span lang="en">virtual</span><span lang="fr">virtuel</span></label></div>
	<div class="item"><label>	<!-- Marker -->
	<input type="checkbox" name="Marker" 		checked autocomplete="off" onchange="toggleMarker(this.checked)"><span lang="de">Marker</span><span lang="en">Marker</span><span lang="fr">Marqueurs</span></label></div>
	<div class="item hidden" id="CheckboxGleisobjekt"><label>	<!-- only visible if there are elements of that type -->
	<input type="checkbox" name="Gleisobjekt" 	checked autocomplete="off" onchange="toggleElements('.Gleisobjekt', this.checked)"><span lang="de">Gleisobjekte</span><span lang="en">Track objects</span><span lang="fr">Objets de voie</span></label></div>
	<div class="item hidden" id="CheckboxKamera"><label>		<!-- only visible if there are elements of that type -->
	<input type="checkbox" name="Kamera" 	    checked autocomplete="off" onchange="toggleElements('#Kamera', this.checked)"><span lang="de">Kameras</span><span lang="en">Cameras</span><span lang="fr">Caméras</span></label></div>
	<div class="item"><label>
	<input type="checkbox" name="general" 	    checked autocomplete="off" onchange="toggleElements('.general', this.checked)"><span lang="de">Rahmen</span><span lang="en">Frame</span><span lang="fr">Cadre</span></label></div>
</fieldset>
</article>

</nav> <!-- controls -->
</section>  <!-- heading -->

<section id="container"> <!-- The container takes the remaining part of the screen to show the graphic -->
<!--
svg editor: https://github.com/SVG-Edit/svgedit
https://svgedit.netlify.app/editor/index.html
-->

<svg id="svg" xmlns="http://www.w3.org/2000/svg" version="1.1">

<title id="svgTitle">EEP Gleisplan</title>
<desc id="svgDesc">EEP Gleisplan</desc>
<defs id="style"> <!-- style -->
	<style type="text/css" id="css-track-colors"> /* dynamic update via Javascript to adjust color per track type */
	/* <![CDATA[ */
svg {
	--Eisenbahn-color: red;
	--Strassenbahn-color: darkgray;
	--Strasse-color: grey;
	--Wasserwege-color: blue;
	--Steuerstrecken-color: purple;
	--GBS-color: brown;
	--Kamera-color: green;
	--Hintergrund-color: white;
}
	/* ]]> */
	</style>

	<style type="text/css" id="css-marker-colors"> /* dynamic update via Javascript to hide/show markers */
	/* <![CDATA[ */
svg {
	--Eisenbahn-marker-color: var(--Eisenbahn-color);
	--Strassenbahn-marker-color: var(--Strassenbahn-color);
	--Strasse-marker-color: var(--Strasse-color);
	--Wasserwege-marker-color: var(--Wasserwege-color);
	--Steuerstrecken-marker-color: var(--Steuerstrecken-color);
	--GBS-marker-color: var(--GBS-color);
	--Kamera-marker-color: var(--Kamera-color);
}
	/* ]]> */
	</style>

	<style type="text/css" id="css-strokeWidth-variables"> /* dynamic update via Javascript to adjust line size */
	/* <![CDATA[ */
svg {
	--normal-stroke-width: 0.5px;
	--narrow-stroke-width: 0.25px;
}
	/* ]]> */
	</style>

	<style type="text/css" id="css-fontSize-variables"> /* dynamic update via Javascript to adjust font size */
	/* <![CDATA[ */
svg {
	--normal-font-size: 3px;
}
	/* ]]> */
	</style>

	<style type="text/css">
	/* <![CDATA[ */
svg {
	background: var(--Hintergrund-color);
	border: 0; /* 1px dotted #3983ab; */
	padding: 0;
	box-sizing: border-box;
	/* transform: scale(1,-1);     		not useful as it would mirror the text, too */
}

/* Texte für Signale, Weichen etc. */
text {
	font-size: var(--normal-font-size);
	font-family: Arial;
	stroke-width: 0;
}

/* not used */
textPath {
}

text.GleisID {
	text-anchor	: start;
}

text.CurveType {
	text-anchor	: end;
}

text.Stil {
	text-anchor	: end;
	font-style: italic;
}

text.Hoehe {
	text-anchor	: start;
	font-style: italic;
}

text.WeicheText {
}

text.text-anchor-end {
	text-anchor	: end;
}

.Signal text, .Kontakt text {
	text-anchor	: middle;
}

#Kamera text {
	text-anchor	: start;
}

/* Box zur Anzeige der verwendeten Groesse der Anlage */
.box {
	stroke-width: 0.1;
	stroke: black;
	fill:   none;
	stroke-dasharray: 1;
}

/* Zusätzliche Markierung des Zentrums */
#center {
	stroke-width: 0;
	stroke: grey;
	fill:   grey;
}

/* Individuelle Formatierung je Gleissystem */

.Eisenbahn {
	stroke-width: var(--normal-stroke-width);
	stroke: var(--Eisenbahn-color);
	fill:   none;
	marker-start: url(#EisenbahnMarkerCircle);
	marker-end:   url(#EisenbahnMarkerArrow);
	/* stroke-dasharray: 0.2 0.4; */ /* Schwellenabstand von 60cm */
}
#EisenbahnMarkerCircle, #EisenbahnMarkerArrow {
	fill: var(--Eisenbahn-marker-color);
}
.Eisenbahn text {
	fill: var(--Eisenbahn-color);
}

.Strassenbahn {
	stroke-width: var(--normal-stroke-width);
	stroke: var(--Strassenbahn-color);
	fill:   none;
	marker-start: url(#StrassenbahnMarkerCircle);
	marker-end:   url(#StrassenbahnMarkerArrow);
}
#StrassenbahnMarkerCircle, #StrassenbahnMarkerArrow {
	fill: var(--Strassenbahn-marker-color) ;
}
.Strassenbahn text {
	fill: var(--Strassenbahn-color) ;
}

.Strasse {
	stroke-width: var(--normal-stroke-width);
	stroke: var(--Strasse-color);
	fill:   none;
	marker-start: url(#StrasseMarkerCircle);
	marker-end:   url(#StrasseMarkerArrow);
}
#StrasseMarkerCircle, #StrasseMarkerArrow {
	fill: var(--Strasse-marker-color);
}
.Strasse text {
	fill: var(--Strasse-color);
}

.Wasserwege {
	stroke-width: var(--narrow-stroke-width);
	stroke: var(--Wasserwege-color);
	fill:   none;
	marker-start: url(#WasserwegeMarkerCircle);
	marker-end:   url(#WasserwegeMarkerArrow);
}
#WasserwegeMarkerCircle, #WasserwegeMarkerArrow {
	fill: var(--Wasserwege-marker-color);
}
.Wasserwege text {
	fill: var(--Wasserwege-color);
}

.Steuerstrecken {
	stroke-width: var(--narrow-stroke-width);
	stroke: var(--Steuerstrecken-color);
	fill:   none;
	marker-start: url(#SteuerstreckenMarkerCircle);
	marker-end:   url(#SteuerstreckenMarkerArrow);
}
#SteuerstreckenMarkerCircle, #SteuerstreckenMarkerArrow {
	fill: var(--Steuerstrecken-marker-color);
}
.Steuerstrecken text {
	fill: var(--Steuerstrecken-color);
}

.GBS {
	stroke-width: var(--narrow-stroke-width);
	stroke: var(--GBS-color);
	fill:   none;
	marker-start: url(#GBSMarkerCircle);
	marker-end:   url(#GBSMarkerArrow);
}
#GBSMarkerCircle, #GBSMarkerArrow {
	fill: var(--GBS-marker-color);
}
.GBS text {
	fill: var(--GBS-color);
}

#Kamera {
	stroke-width: calc(var(--normal-stroke-width) * 1.5);
	stroke: var(--Kamera-color);
	fill:   none;
	/* marker-start: url(#KameraMarkerCircle); */
	marker-end:   url(#KameraMarkerArrow);
}
#KameraMarkerCircle, #KameraMarkerArrow {
	fill: var(--Kamera-marker-color);
}
#Kamera text {
	fill: var(--Kamera-color);
}

/* Gleisobjekte werden als transparente Flächen in der Farbe der jeweiligen Gleissysteme dargestellt */

.Gleisobjekt * {
	stroke: none;
	marker-start: none;
	marker-end: none;
}

.Gleisobjekt rect {
	fill-opacity: 0;		/* hide it */
	filter: url(#blur);   	/* #blur #dilate #dilate+blur */
}
.Gleisobjekt path {
	fill-opacity: 0.2;
	filter: url(#blur);  	/* #blur #dilate #dilate+blur */
}

.Gleisobjekt .Eisenbahn {
	fill: var(--Eisenbahn-color);
}

.Gleisobjekt .Strassenbahn {
	fill: var(--Strassenbahn-color);
}

.Gleisobjekt .Strasse {
	fill: var(--Strasse-color);
}

.Gleisobjekt .Wasserwege {
	fill: var(--Wasserwege-color);
}

.Gleisobjekt .Steuerstrecken {
	fill: var(--Steuerstrecken-color);
}

.Gleisobjekt .GBS {
	fill: var(--GBS-color);
}

/* Besondere Objekte */

.Prellbock {
	marker-end:   url(#Prellbock);
}

/* Symbole */

#SymbolSignal, #SymbolPreSignal, #SymbolStopAt, #SymbolFStart, #SymbolFZiel, #SymbolKontakt {
	marker-start: none;
	marker-end:   none;
	stroke-width: var(--narrow-stroke-width);
	fill:   none;
}

/* Individuelle Formatierung je Gleisstil */

.stil-1353 { 	/* Gleis mit Betonschwellen */
}

.stil-5146 { 	/* Farm track */
	stroke: brown;
}

.unsichtbar {	/* unsichtbare Gleisstile */
	stroke-dasharray: 0.6 0.2;
}

.virtual {	/* virtuelle Gleisstile */
	stroke-dasharray: 0.3 0.2;
	stroke-opacity: 0.5;
}

.inactive {		/* inaktive Gleisstile */
	stroke-opacity: 0.5;
}

/* versteckte Elemente */

.hidden, .hiddenZ {
	display: none !important;
}
	/* ]]> */
	</style>
</defs>

<defs id="symbols"> <!-- Filters, Symbols and Markers -->
	<!-- Dilate and blur Gleisobjekte -->
	<filter id="dilate">
		<feMorphology operator="dilate" radius="3" />
	</filter>
	<filter id="blur">
		<feGaussianBlur stdDeviation="0.2" />
	</filter>
	<filter id="dilate+blur">
		<feMorphology operator="dilate" radius="2" />
		<feGaussianBlur stdDeviation="1" />
	</filter>

	<!-- Use of symbols requires translate(-10 0) to move the origin M 0 0 to the correct position -->
	<!-- <path d="M 0 0 L 4 3 A 12 12  0 0 1  -4 3 z" /> --> <!-- Kreissegment -->
	<!-- <path d="M 0 0 L 0 1.2 L 4.8 1.2 L 4.8 5.8 L -4.8 5.8 L -4.8 1.2 L 0 1.2" /> --> <!-- Box -->
	<!-- <path d="M 0 0 L 0 0.9" /><circle cx="0" cy="1.5" r="0.6" /> --> <!-- Linie mit Kreis -->
	<symbol id="SymbolSignal" width="20" height="10" viewBox="-10 0 20 10">
		<path d="M 0 0 L 0 0.9  M 0.25 0.9 L 0.6 1.25 L 0.6 1.75 L 0.25 2.1  L -0.25 2.1 L -0.6 1.75 L -0.6 1.25 L -0.25 0.9 Z" /> <!-- Linie mit Achteck -->
	</symbol>
	<symbol id="SymbolPreSignal" width="20" height="10" viewBox="-10 0 20 10">
		<path d="M 0 0 L 0 0.9" /><circle cx="0" cy="1.3" r="0.4" /> <!-- Linie mit kleinem Kreis -->
	</symbol>
	<symbol id="SymbolStopAt" width="20" height="10" viewBox="-10 0 20 10">
		<path d="M 0 0 L 0 0.9" /> <!-- Linie -->
	</symbol>
	<symbol id="SymbolKontakt" width="20" height="10" viewBox="-10 0 20 10">
		<path d="M 0 0 L 0 0.9  M 0 0.9 L 0.7 2.1 L -0.7 2.1 Z" /> <!-- Linie mit Dreieck -->
	</symbol>
	<symbol id="SymbolFStart" width="20" height="10" viewBox="-10 0 20 10">
		<path d="M 0 0 L 0 1.1  M 0 1.1 L 0.41 0.83 L 0.29 1.3 L 0.67 1.6 L 0.17 1.65 L 0 2.1  L -0.17 1.65 L -0.67 1.6 L -0.29 1.3 L -0.41 0.83 Z" /> <!-- Linie mit 5er Stern -->
	</symbol>
	<symbol id="SymbolFZiel" width="20" height="10" viewBox="-10 0 20 10">
		<path d="M 0 0 L 0 0.9  M 0 0.9 L -1.2 0.9 L -1.2 2.1 L 0 2.1 Z  M -0.6 0.9 L -0.6 2.1  M 0 1.5 L -1.2 1.5" /> <!-- Linie mit Flagge -->
	</symbol>

	<!-- Prellbock: Querbalken -->
	<marker id="Prellbock" 	markerWidth="2" markerHeight="4" refX="2" refY="2" orient="auto">
		<rect x="0" y="0" width="2" height="4"/>
	</marker>

	<!-- We need individual markers to be able to apply CSS -->
	<marker id="EisenbahnMarkerCircle" 		markerWidth="5" markerHeight="5" refX="2" refY="3">
		<circle cx="3" cy="3" r="1" />
	</marker>
	<marker id="StrassenbahnMarkerCircle"	markerWidth="5" markerHeight="5" refX="2" refY="3">
		<circle cx="3" cy="3" r="1" />
	</marker>
	<marker id="StrasseMarkerCircle" 		markerWidth="5" markerHeight="5" refX="2" refY="3">
		<circle cx="3" cy="3" r="1" />
	</marker>
	<marker id="WasserwegeMarkerCircle" 	markerWidth="5" markerHeight="5" refX="2" refY="3">
		<circle cx="3" cy="3" r="1" />
	</marker>
	<marker id="SteuerstreckenMarkerCircle" markerWidth="5" markerHeight="5" refX="2" refY="3">
		<circle cx="3" cy="3" r="1" />
	</marker>
	<marker id="GBSMarkerCircle" 			markerWidth="5" markerHeight="5" refX="2" refY="3">
		<circle cx="3" cy="3" r="1" />
	</marker>
	<marker id="KameraMarkerCircle" 		markerWidth="5" markerHeight="5" refX="2" refY="3">
		<circle cx="3" cy="3" r="1" />
	</marker>

	<marker id="EisenbahnMarkerArrow" 		markerWidth="5" markerHeight="5" refX="2" refY="3" orient="auto">
		<path d="M0,1 L0,5 L3,3 L0,1" />
	</marker>
	<marker id="StrassenbahnMarkerArrow" 	markerWidth="5" markerHeight="5" refX="2" refY="3" orient="auto">
		<path d="M0,1 L0,5 L3,3 L0,1" />
	</marker>
	<marker id="StrasseMarkerArrow" 		markerWidth="5" markerHeight="5" refX="2" refY="3" orient="auto">
		<path d="M0,1 L0,5 L3,3 L0,1" />
	</marker>
	<marker id="WasserwegeMarkerArrow" 		markerWidth="5" markerHeight="5" refX="2" refY="3" orient="auto">
		<path d="M0,1 L0,5 L3,3 L0,1" />
	</marker>
	<marker id="SteuerstreckenMarkerArrow" 	markerWidth="5" markerHeight="5" refX="2" refY="3" orient="auto">
		<path d="M0,1 L0,5 L3,3 L0,1" />
	</marker>
	<marker id="GBSMarkerArrow" 			markerWidth="5" markerHeight="5" refX="2" refY="3" orient="auto">
		<path d="M0,1 L0,5 L3,3 L0,1" />
	</marker>
	<marker id="KameraMarkerArrow" 			markerWidth="5" markerHeight="5" refX="2" refY="3" orient="auto">
		<path d="M0,1 L0,5 L3,3 L0,1" />
	</marker>

</defs>

<g id="sutrackpSVG" class="svg-pan-zoom_viewport">
<!-- hier werden dynamisch die weiteren svg-Elemente der EEP Anlage eingefügt -->
</g>

</svg>

</section> <!-- container -->

<!-- local library -->
<!-- <script type="text/javascript" src="svg-pan-zoom/dist/svg-pan-zoom.js"></script> -->
<!-- remote library on GitHub pages -->
<script type="text/javascript" src="node_modules/svg-pan-zoom/dist/svg-pan-zoom.min.js"></script>
<!-- Not possible: "Cross-Origin Read Blocking (CORB) blocked cross-origin response with MIME type text/plain."
See https://www.chromestatus.com/feature/5629709824032768 for more details. -->
<!-- <script type="text/javascript" src="https://raw.githubusercontent.com/bumbu/svg-pan-zoom/master/dist/svg-pan-zoom.js"></script>		-->
<!-- <script type="text/javascript" src="https://raw.githubusercontent.com/bumbu/svg-pan-zoom/master/dist/svg-pan-zoom.min.js"></script>	-->
<!-- not tested yet: Load specific version of the library -->
<!-- <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/svg-pan-zoom@3.6.0/dist/svg-pan-zoom.min.js"></script>	-->

<script type="text/javascript"> // svg-pan-zoom
"use strict";
/* Interface
required standard objects:
	BroadcastChannel
	console
	document
	localStorage
	window
required global data:
	EEP_Texts
	global
required functions:
	TrackSystemText
	changeStrokeWidth
	changefontSize
	showColorPickerWindow
	showExportWindow
	showGleisInfo
	showKameraInfo
	showKontaktInfo
	showSignalInfo
	showVirtualConnectionInfo
	showWeicheInfo
public api:
	SvgPanZoom
	centerItem
	centerPosition
*/
(function(api) {
// public api
api.SvgPanZoom = SvgPanZoom;
api.centerItem = centerItem;
api.centerPosition = centerPosition;

function SvgPanZoom() { // <!-- github.com/bumbu/svg-pan-zoom -->

	const beforePan = function(oldPan, newPan) {
		msg();
		return; // Zoom-in near the border does not work well if we limt pan with fixed gutter

		// Limit pan to keep SVG content visible by not allowing panning over SVG borders.
		const gutterWidth = 100,
			  gutterHeight = 100;

		const sizes = this.getSizes();
		const leftLimit = -((sizes.viewBox.x + sizes.viewBox.width) * sizes.realZoom) + gutterWidth;
		const rightLimit = sizes.width - gutterWidth - (sizes.viewBox.x * sizes.realZoom);
		const topLimit = -((sizes.viewBox.y + sizes.viewBox.height) * sizes.realZoom) + gutterHeight;
		const bottomLimit = sizes.height - gutterHeight - (sizes.viewBox.y * sizes.realZoom);

		const customPan = {};
		customPan.x = Math.max(leftLimit, Math.min(rightLimit,  newPan.x));
		customPan.y = Math.max(topLimit,  Math.min(bottomLimit, newPan.y));

		return customPan;
	};

	const onZoom = function(newZoom) {
		msg();
		changeStrokeWidth(panZoom);
		showArea(this);
	};

	const onPan = function(newPan) {
		msg();
		showArea(this);
	};

	const panZoom = svgPanZoom("#svg", {
		viewportSelector: ".svg-pan-zoom_viewport" // Viewport selector. Can be querySelector string or SVGElement
		//, panEnabled: true // enable or disable panning (default enabled)
		, controlIconsEnabled: false // insert icons to give user an option in addition to mouse events to control pan/zoom (default disabled)
		// , zoomEnabled: true // enable or disable zooming (default enabled)
		// , dblClickZoomEnabled: true // enable or disable zooming by double clicking (default enabled)
		// , mouseWheelZoomEnabled: true // enable or disable zooming by mouse wheel (default enabled)
		// , preventMouseEventsDefault: true // enable or disable preventDefault for mouse events
		, zoomScaleSensitivity: 0.1 // Zoom sensitivity
		, minZoom: 0.1 // Minimum Zoom level
		, maxZoom: 5000 // Maximum Zoom level
		// , fit: true // enable or disable viewport fit in SVG (default true)
		// , contain: false // enable or disable viewport contain the svg (default false)
		// , center: true // enable or disable viewport centering in SVG (default true)
		// , refreshRate: "auto" // Maximum number of frames per second (altering SVG viewport)
		// , beforeZoom: function(oldZoom, newZoom){ return true; }
		// , onZoom: function(ZoomScale){}
		, onZoom: onZoom
		// , beforePan: function(oldPan, newPan){ return customPan; } // oldPan.x, oldPan.y, newPan.x, newPan.y
		, beforePan: beforePan
		// , onPan: function(newPan){}
		, onPan: onPan
		// , customEventsHandler: { init : function(options){}, destroy : function(options){} }
		, customEventsHandler: {
			init : function(options) {
				this.listeners = {
					mouseenter: function(ev) {
						showPosition(options.instance, ev);
						showArea(options.instance, ev);
					},
					click: function(ev) {
						showArea(options.instance, ev);
						showElement(options.instance, ev);
					},
					mousemove: function(ev) {
						showPosition(options.instance, ev);
					},
					mouseleave: function(ev) {
						document.getElementById("cursorPosition").textContent = "";
					},
				};
				for (const eventName in this.listeners) {
					options.svgElement.addEventListener(eventName, this.listeners[eventName]);
				}
			},
			destroy: function(options) {
				for (const eventName in this.listeners) {
					options.svgElement.removeEventListener(eventName, this.listeners[eventName]);
				}
			}
		}
		// , eventsListenerElement: SVGElement
		// , onUpdatedCTM: function(){}
		, onUpdatedCTM: null // callback function which is triggered at the very end of pan or zoom effects
	});

	// Pan and zoom to used area
	showUsedArea(panZoom, true);

	global.timestamp.SvgPanZoom = Date.now();
	console.log('show svg:' + (global.timestamp.SvgPanZoom - global.timestamp.svgCreated) / 1000 + 'sec');

	// resize SvgPanZoom after resizing the window
	window.addEventListener("resize", function(ev) {
		msg();
		ev.preventDefault();
		// Resize content
		panZoom.resize();
		//panZoom.fit();
		//panZoom.center();
		showArea(panZoom);
	});

	// arrow keys trigger page scrolling, + - trigger zooming
	// another solution to deal with multiple keys at same time:
	// https://stackoverflow.com/questions/5203407/how-to-detect-if-multiple-keys-are-pressed-at-once-using-javascript
	window.addEventListener("keydown", function(ev) {
		//msg("", 'Target: ' + ev.target.nodeName, 'Key: ' + ev.key);
		if (ev.target.nodeName !== "BODY" && ev.target.nodeName !== "BUTTON") { return; }

		// Check active keys
		if ( !( ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "+", "-"].includes(ev.key) )) {
			return;
		}

		// Zoom
		if 		  (ev.key === "+") {
			panZoom.zoomIn();
			ev.preventDefault();
			return false;
		} else if (ev.key === "-") {
			panZoom.zoomOut();
			ev.preventDefault();
			return false;
		}

		// Pan
		const sizes = panZoom.getSizes();	// width height of svg area
											// viewBox (x y width height)
											// realZoom = min(width/viewBox.width, height/viewBox.height)
		//const zoom 	= panZoom.getZoom();		// zoom factor
		if 		  (ev.key === "ArrowUp") {
			panZoom.panBy({
				x: 0,
				y: (global.shiftDown ? +sizes.height / 2 : +5),
			});
		} else if (ev.key === "ArrowDown") {
			panZoom.panBy({
				x: 0,
				y: (global.shiftDown ? -sizes.height / 2 : -5),
			});
		} else if (ev.key === "ArrowLeft") {
			panZoom.panBy({
				x: (global.shiftDown ? +sizes.width  / 2 : +5),
				y: 0,
			});
		} else if (ev.key === "ArrowRight") {
			panZoom.panBy({
				x: (global.shiftDown ? -sizes.width  / 2 : -5),
				y: 0,
			});
		} else {
			msg("", 'nothing to do');
			return;
		}
		showArea(panZoom);
		ev.preventDefault();
		return false;
	});

	// Button swap
	document.getElementById("swap").addEventListener("click", function(ev) {
		msg();
		ev.preventDefault();
		// Toogle between flex-direction: column and flex-direction: row
		document.getElementById("main").classList.toggle("column");
		document.getElementById("main").classList.toggle("row");

		// If the svg element is hidden, then we would get zero height and width after panZoom.resize();
		if (!document.getElementById("svg").classList.contains("hidden")) {
			// Swapping changes the size of the svg element
			const oldSizes = panZoom.getSizes();
			panZoom.resize();
			const newSizes = panZoom.getSizes();
			// The top left point keeps its position. We need to pan to keep the center being centered.
			panZoom.panBy({
				x: (newSizes.width - oldSizes.width) 	/ 2 ,
				y: (newSizes.height - oldSizes.height)	/ 2 ,
			});
			showArea(panZoom);
		}
	});

	// Button Zoom-In
	document.getElementById("zoom-in").addEventListener("click", function(ev) {
		msg();
		ev.preventDefault();
		panZoom.zoomIn();
	});
	// Button Zoom-Out
	document.getElementById("zoom-out").addEventListener("click", function(ev) {
		msg();
		ev.preventDefault();
		panZoom.zoomOut();
	});

	// Button Reset
	document.getElementById("reset").addEventListener("click", function(ev) {
		msg();
		ev.preventDefault();
		panZoom.fit();
		panZoom.center();
		panZoom.resetZoom();
		// Pan and zoom to used area
		showUsedArea(panZoom, true);
	});
	// Button ResetZoom
	document.getElementById("resetzoom").addEventListener("click", function(ev) {
		msg();
		ev.preventDefault();
		panZoom.resetZoom();
		// Zoom to used area
		showUsedArea(panZoom);
	});
	// Slider strokeWidth (in case of very large files, it might be better to use "change" event instead of "input" event to switch off live updates)
	document.getElementById("strokeWidth").addEventListener("input", function(ev) {
		msg();
		ev.preventDefault();
		localStorage.setItem("strokeWidth", ev.target.value);
		changeStrokeWidth(panZoom);
	});
	// Checkbox auto stroke width
	document.getElementById("autoStrokeWidth").addEventListener("input", function(ev) {
		msg();
		ev.preventDefault();
		if (ev.target.checked) {
			msg("automatic stroke width");
		} else {
			msg("manual stroke width");
		}		
		localStorage.setItem("checkbox_autoStrokeWidth", ev.target.checked);
		changeStrokeWidth(panZoom);
	});
	// Slider fontSize (in case of very large files, it might be better to use "change" event instead of "input" event to switch off live updates)
	document.getElementById("fontSize").addEventListener("input", function(ev) {
		msg();
		ev.preventDefault();
		changefontSize(ev.target.value);
		localStorage.setItem("fontSize", ev.target.value);
	});
	// Button "enable controls"
/*
	document.getElementById("enable").addEventListener("click", function() {
		msg();
		ev.preventDefault();
		panZoom.enableControlIcons();
	})
*/
	// Button "disable controls"
/*
	document.getElementById("disable").addEventListener("click", function() {
		msg();
		ev.preventDefault();
		panZoom.disableControlIcons();
	})
*/

	// Button savePNG
	document.getElementById("savePNG").addEventListener("click", function(ev) {
		msg();
		ev.preventDefault();
		showExportWindow();
	});
	// Button setColors
	document.getElementById("setColors").addEventListener("click", function(ev) {
		msg();
		ev.preventDefault();
		showColorPickerWindow();
	});

	// Button centerItem
	document.getElementById("centerItem").addEventListener("click", function(ev) {
		msg();
		ev.preventDefault();
		centerItem();
	});

	// Listen for checkbox change events - store checkbox settings in local storage
	document.querySelector(".fieldset").addEventListener("change", function(ev) {
		const target = ev.target;
		localStorage.setItem(`checkbox_${target.name}`, target.checked);
	});

// Broadcast Channel to receive messages from EEP_Inventar.html
// https://developer.mozilla.org/en-US/docs/Web/API/Broadcast_Channel_API

// // Initialization: Connection to a broadcast channel
const EEPchannel = new BroadcastChannel("EEP");

// Event handler
EEPchannel.onmessage = function(ev) {
	const command = ev.data.command;

	// Commands for navigation
	const GleissystemID = "" + ev.data.GleissystemID;	// Gleis
	const GleisID		= "" + ev.data.GleisID;

	const ID			= ev.data.ID;				// Signal oder Weiche
	const KontaktID		= ev.data.KontaktID;		// Kontakt
	const KameraID		= ev.data.KameraID;			// Kamera
	const GBSID			= ev.data.GBSID;			// GBS
	global.shiftDown 	= ev.data.shiftDown;		// Status of keys
	global.strgDown 	= ev.data.strgDown;
	global.altDown 		= ev.data.altDown;

	if (command === "showID" && ID) {	// Signal oder Weiche

		const Meldung = global.Meldungen[Number(ID)];
		if (Meldung) {
			// Signal gefunden (Vorsignal oder Hauptsignal)
			centerPosition(Meldung.mPos);
			//msg(`Das Signal ${ID} befindet sich auf ${TrackSystemText(Meldung.GleissystemID)} ${Meldung.GleisID}`);
			msg('SignalLocation', ID, TrackSystemText(Meldung.GleissystemID), Meldung.GleisID);

//			showSignalInfo(ID, GleissystemID, GleisID);
			showSignalInfo(ID, Meldung.GleissystemID, Meldung.GleisID);
			return true;
		}

		const Gleis = global.Weichen[Number(ID)];
		if (Gleis) {
			// Weiche gefunden
			//const GleissystemID = Gleissystem.getAttribute("GleissystemID");
			const GleisID = Gleis.getAttribute("GleisID");
			centerPosition(Gleis.mEnd);
			//msg(`Die Weiche ${ID} befindet sich auf ${TrackSystemText(Gleis.GleissystemID)} ${GleisID}`);
			msg('SwitchLocation', ID, TrackSystemText(Gleis.GleissystemID), GleisID);

//			showWeicheInfo(ID, GleissystemID, GleisID);
			showWeicheInfo(ID, Gleis.GleissystemID, GleisID);
			return true;
		}

	} else if (command === "showContact" && KontaktID) {	// Kontakt

		const Kontakt = global.Kontakte[KontaktID];
		centerPosition(Kontakt.mPos);

		showKontaktInfo(KontaktID, GleissystemID, GleisID);
		return true;

	} else if (command === "showCamera" && KameraID) {	// Kamera

		const Kamera = global.KameraSet[KameraID];
		if (!Kamera) {
			//msg(`Kamera ${KameraID} existiert nicht`);
			msg('CameraNotExists', KameraID);
			return false;
		}

		centerPosition(Kamera.mPos);

		showKameraInfo(KameraID);
		return true;

	} else if (command === "showGBS" && GBSID) {	// GBS

		//...

	} else if (command === "showTrack" && GleissystemID && GleisID) {	// Gleis

		const Gleissystem = global.Gleissysteme[GleissystemID];
		if (!Gleissystem) {
			//msg(`Gleissystem ${GleissystemID} ${TrackSystemText(GleissystemID)} existiert nicht`);
			msg('TrackSystemNotExists', GleissystemID, TrackSystemText(GleissystemID));
			return false;
		}
		const Gleis = Gleissystem[GleisID];
		if (!Gleis) {
			//msg(`${TrackSystemText(GleissystemID)} ${GleisID} existiert nicht`);
			msg('TrackNotExists', TrackSystemText(GleissystemID), GleisID);
			return false;
		}

		centerPosition(Gleis.mMid); // Mitte des Gleises
		//msg(`Positionierung auf ${TrackSystemText(GleissystemID)} ${GleisID}`);
		msg('Positioning', TrackSystemText(GleissystemID), GleisID);

		showGleisInfo(GleissystemID, GleisID);
		return true;

	} else {
		msg('wrongCommand', command);
		console.log(ev);
	}
};

// Disconnect the channel
//EEPchannel.close();

// End: Broadcast Channel

	return { // public interface
		centerItem: centerItem,
		centerPosition: centerPosition,
	};

function centerItem() {
	// Get input values
	//const text 	= o.options[o.selectedIndex].text;		// e.g. Eisenbahn
	const o 	= document.getElementById("selectObject" + EEP_Texts.getLanguage());
	const sel 	= o.options[o.selectedIndex].value;			// e.g. 1-6, I (statt W, S), K
	const val 	= Number(document.getElementById("number").value);

	if (sel >= "1" && sel <= "6") {	// TracksystemNumber

		const TracksystemNumber = Number(sel);
		
		let GleissystemID; // Find GleissystemID for TracksystemNumber 
		for (const key in global.TrackSystem) { 
			if (global.TrackSystem[key] == TracksystemNumber) {
				GleissystemID = key;
			}
		}
		
		const GleisID 		= val;

		const Gleissystem = global.Gleissysteme[GleissystemID];
		if (!Gleissystem) {
			//msg(`Gleissystem ${GleissystemID} ${TrackSystemText(GleissystemID)} existiert nicht`);
			msg('TrackSystemNotExists', GleissystemID, TrackSystemText(GleissystemID));
			return false;
		}
		const Gleis = Gleissystem[GleisID];
		if (!Gleis) {
			//msg(`${TrackSystemText(GleissystemID)} ${GleisID} existiert nicht`);
			msg('TrackNotExists', TrackSystemText(GleissystemID), GleisID);
			return false;
		}

		centerPosition(Gleis.mMid); // Mitte des Gleises
		//msg(`Positionierung auf ${TrackSystemText(GleissystemID)} ${GleisID}`);
		msg('Positioning', TrackSystemText(GleissystemID), GleisID);
		return true;

	} else if (sel === "I" || sel === 'S' || sel === 'W') {		// I = Signal/Weiche (Nummern übergreifend über alle Gleissysteme)
		// Gleis.getAttribute("Key_Id") bzw. Gleis.getAttribute("Meldung").getAttribute("Key_Id")
		const ID 		= val;

		const Meldung = global.Meldungen[Number(ID)];
		if (Meldung) {
			// Signal gefunden (Vorsignal oder Hauptsignal)
			centerPosition(Meldung.mPos);
			//msg(`Das Signal ${ID} befindet sich auf ${TrackSystemText(Meldung.GleissystemID)} ${Meldung.GleisID}`);
			msg('SignalLocation', ID, TrackSystemText(Meldung.GleissystemID), Meldung.GleisID);
			return true;
		}

		const Gleis = global.Weichen[Number(ID)];
		if (Gleis) {
			// Weiche gefunden
			//const GleissystemID = Gleissystem.getAttribute("GleissystemID");
			const GleisID = Gleis.getAttribute("GleisID");
			centerPosition(Gleis.mEnd);
			//msg(`Die Weiche ${ID} befindet sich auf ${TrackSystemText(Gleis.GleissystemID)} ${GleisID}`);
			msg('SwitchLocation', ID, TrackSystemText(Gleis.GleissystemID), GleisID);
			return true;
		}

		//msg(`Signal/Weiche ${ID} existiert nicht`);
		msg('SignalSwitchNotExists', ID);
		return false; // Signal/Weiche nicht gefunden

	} else if (sel === "K") {		// Kontakt
		//...
	}
	return false;
}

function centerPosition(Position) {
	const width 	= panZoom.getSizes().width;
	const height	= panZoom.getSizes().height;
	const realZoom	= panZoom.getSizes().realZoom;

	const posX = 12, posY = 13, posZ = 14;
	const panX 		= width/2	- Position[posX] * realZoom;
	const panY 		= height/2	- (-Position[posY]) * realZoom;	// svg: mirrored y-coordinate

	panZoom.pan({x: panX, y: panY});
}

// Show cursor position
function showPosition(panZoom, event) {
	const pan 	= panZoom.getPan();	// (x y)
	const sizes = panZoom.getSizes();	// width height of svg area
								// viewBox (x y width height)
								// realZoom = min(width/viewBox.width, height/viewBox.height)
	//const zoom 	= panZoom.getZoom();	// zoom factor

	const posX	= ( event.offsetX - pan.x) / sizes.realZoom;
	const posY	= ( event.offsetY - pan.y) / sizes.realZoom;

	/* Show cursor position */
	const text = "(" + (posX).toFixed(0) + " " + (-posY).toFixed(0) + ")";
	document.getElementById("cursorPosition").textContent = text;
}

// Show coordinates of visible area
function showArea(panZoom, event) {
	const pan 		= panZoom.getPan();	// (x y)
	const sizes 	= panZoom.getSizes();	// width height of svg area
								// viewBox (x y width height)
								// realZoom = min(width/viewBox.width, height/viewBox.height)
	//const zoom 		= panZoom.getZoom();	// zoom factor

	const minX		= (-pan.x) / sizes.realZoom;
	const minY		= (-pan.y) / sizes.realZoom;
	const centerX	= (-pan.x + sizes.width/2)  / sizes.realZoom;
	const centerY	= (-pan.y + sizes.height/2)	/ sizes.realZoom;
	const maxX		= (-pan.x + sizes.width)  	/ sizes.realZoom;
	const maxY		= (-pan.y + sizes.height) 	/ sizes.realZoom;

	/* Show coordinates of visible area */
	let text = "("  + (minX).toFixed(0) + " " + (-minY).toFixed(0) + ") .. ("
					+ (maxX).toFixed(0) + " " + (-maxY).toFixed(0) + ")";
	document.getElementById("visibleArea").textContent = text;
	/* Show center position */
	text = "(" + (centerX).toFixed(0) + " " + (-centerY).toFixed(0) + ")";
	document.getElementById("centerPosition").textContent = text;
}

// Show element
function showElement(panZoom, event) {
	if (!event || event.target.id === "svg") { return; }
/*
console.log("");

console.log(
"target|" +
event.target.tagName + ":" +
event.target.id + ":" +
event.target.classList[0]
)
if (event.target.parentElement) {
console.log(
"target.parentElement|" +
event.target.parentElement.tagName + ":" +
event.target.parentElement.id  + ":" +
event.target.parentElement.classList[0]
)
if (event.target.parentElement.parentElement) {
	console.log(
	"target.parentElement.parentElement|" +
	event.target.parentElement.parentElement.tagName + ":" +
	event.target.parentElement.parentElement.id  + ":" +
	event.target.parentElement.parentElement.classList[0]
	)
}
}
if (event.rangeParent) {
console.log(
"rangeParent|" +
event.rangeParent.tagName + ":" +
event.rangeParent.id  + ":" +
event.rangeParent.classList[0]
)
if (event.rangeParent.parentElement) {
	console.log(
	"rangeParent.parentElement|" +
	event.rangeParent.parentElement.tagName + ":" +
	event.rangeParent.parentElement.id  + ":" +
	event.rangeParent.parentElement.classList[0]
	)
}
}
*/
/*
Track
target						|path::stil-1353
target.parentElement		|g:G1-3:Weiche
rangeParent					|g:G1-3:Weiche
rangeParent.parentElement	|g:Eisenbahn:undefined

Track text
target						|text::undefined
target.parentElement		|g:G1-51:Normal
rangeParent					|text::undefined
rangeParent.parentElement	|g:G1-51:Normal

Track stil
target|text::Stil
target.parentElement		|g:G1-51:Normal
rangeParent					|text::Stil
rangeParent.parentElement	|g:G1-51:Normal

Track Hoehe
target|text::Hoehe
target.parentElement		|g:G1-51:Normal
rangeParent					|text::Hoehe
rangeParent.parentElement	|g:G1-51:Normal

Weiche text
target						|text:W2:WeicheText
target.parentElement		|g:G1-17:Weiche
rangeParent					|text:W2:WeicheText
rangeParent.parentElement	|g:G1-17:Weiche

Signal text
target						|text::Signal
target.parentElement		|g:S39:Signal
target.parentElement.parentElement|g:G1-47:Normal
rangeParent					|text::Signal
rangeParent.parentElement	|g:S39:Signal

Signal symbol
target						|use::undefined
target.parentElement		|g:S39:Signal
target.parentElement.parentElement|g:G1-47:Normal
rangeParent					|symbol:SymbolSignal:undefined

Signal circle
target						|circle::undefined
target.parentElement		|g:S39:Signal
rangeParent					|g:S39:Signal
rangeParent.parentElement	|g:G1-47:Normal

Kontakt symbol
target						|use::undefined
target.parentElement		|g:K1:Kontakt
target.parentElement.parentElement|g:G1-47:Normal

Kontakt circle
target						|circle::undefined
target.parentElement		|g:G1-47:Normal
rangeParent					|g:G1-47:Normal
rangeParent.parentElement	|g:Eisenbahn:undefined

Virtual connection
event.target.parentElement.parentElement.id					""
event.target.parentElement.parentElement.id					""
event.target.parentElement.classList[0]						virtual
event.target.parentElement.classList.contains("virtual")	true
event.target.classList[0]									undefined	
event.target.parentElement.id								V4
event.target.id												V4-1
*/

	if (event.target.parentElement.classList.contains("Signal")) {			// Signal (Vorsignal oder Hauptsignal)
		const SignalCode 		= event.target.parentElement.id;
		const SignalID 			= Number(SignalCode.substring(1));

		const GleisCode 		= event.target.parentElement.parentElement.id;
		const GleisTextArray 	= GleisCode.substring(1).split("-");
		const GleissystemID 	= GleisTextArray[0];
		const GleisID 			= GleisTextArray[1];

		showSignalInfo(SignalID, GleissystemID, GleisID);

	} else if (event.target.parentElement.classList.contains("Kontakt")) {	// Kontakt
		const KontaktCode		= event.target.parentElement.id;
		const KontaktID 		= KontaktCode.substring(1);

		const GleisCode 		= event.target.parentElement.parentElement.id;
		const GleisTextArray 	= GleisCode.substring(1).split("-");
		const GleissystemID 	= GleisTextArray[0];
		const GleisID 			= GleisTextArray[1];

		showKontaktInfo(KontaktID, GleissystemID, GleisID);

	} else if (event.target.parentElement.classList.contains("virtual")) {	// virtual connection

		const virtualConnectionCode 		= event.target.id;
		const virtualConnectionTextArray 	= virtualConnectionCode.substring(1).split("-");

		const GleissystemID 	= virtualConnectionTextArray[0];
		const GleisID 			= virtualConnectionTextArray[1];
		const Anschluss 		= virtualConnectionTextArray[2];
		
		showVirtualConnectionInfo(GleissystemID, GleisID, Anschluss);

	} else if (event.target.classList.contains("WeicheText")) { 			// Weiche
		const WeicheCode 		= event.target.id;
		const WeicheID 			= WeicheCode.substring(1);

		const GleisCode 		= event.target.parentElement.id;
		const GleisTextArray 	= GleisCode.substring(1).split("-");
		const GleissystemID 	= GleisTextArray[0];
		const GleisID 			= GleisTextArray[1];

		showWeicheInfo(WeicheID, GleissystemID, GleisID);

	} else if (event.target.parentElement.parentElement.id === "Kamera") {	// Kamera
		const KameraID 				= event.target.parentElement.id;

		// Issue: Name is not an unique key
		showKameraInfo(KameraID);

	} else if (!event.target.parentElement.classList.contains("general")) { // Gleis (hopefully)
		const GleisCode 		= event.target.parentElement.id;
		const GleisTextArray 	= GleisCode.substring(1).split("-");
		const GleissystemID 	= GleisTextArray[0];
		const GleisID 			= GleisTextArray[1];

		showGleisInfo(GleissystemID, GleisID);
	}
}

function showUsedArea(panZoom, pan) {
	// Pan and zoom to used area
	// zoomAtPoint(scale, {x:0,y:0});   or   pan({x:0,y:0}); zoom(scale);
	const width 		= panZoom.getSizes().width;
	const height		= panZoom.getSizes().height;
	const usedwidth 	= global.usedArea.max.x - global.usedArea.min.x;
	const usedheight	= global.usedArea.max.y - global.usedArea.min.y;
	const realZoom		= panZoom.getSizes().realZoom;

	const panX 			= width/2  - ( global.usedArea.min.x + usedwidth/2  ) * realZoom;
	const panY 			= height/2 + ( global.usedArea.max.y - usedheight/2 ) * realZoom;	// svg: mirrored y-coordinate
	const scale 		= Math.min( width  / usedwidth,
									height / usedheight ) / realZoom;

	if (pan) {
		panZoom.pan({x: panX, y: panY});
	}
	panZoom.zoom(scale);
}

} // end function SvgPanZoom

// Handle special keys
global.shiftDown 	= false;
global.strgDown 	= false;
global.altDown 		= false;
// Clear key status when window gets focus (mainly to omit Alt key)
window.addEventListener("focus", function(event) {
	global.shiftDown 	= false;
	global.strgDown 	= false;
	global.altDown 		= false;
});
//window.addEventListener("blur", function(event) {});
// Activate key
document.addEventListener("keydown", function(event){
    if			(event.keyCode === 16 || event.charCode === 16){
        global.shiftDown = true;
    } else if	(event.keyCode === 17 || event.charCode === 17){
        global.strgDown = true;
    } else if	(event.keyCode === 18 || event.charCode === 18){
        global.altDown = true;
    }
});
// Deactivate key
document.addEventListener("keyup", function(event){
    if			(event.keyCode === 16 || event.charCode === 16){
        global.shiftDown = false;
    } else if	(event.keyCode === 17 || event.charCode === 17){
        global.strgDown = false;
    } else if	(event.keyCode === 18 || event.charCode === 18){
        global.altDown = false;
    }
});

})(this); // end module
</script>

<script type="text/javascript"> // Main screen
"use strict";
/* Interface
required standard objects:
	console
	document
required global data:
	EEP_Texts
	global
public api:
	changeHeightRange
	changeStrokeWidth
	changefontSize
	msg
	toggleElements
	toggleMarker
*/
(function(api) {
// public api
api.changeHeightRange = changeHeightRange;
api.changeStrokeWidth = changeStrokeWidth;
api.changefontSize = changefontSize;
api.msg = msg;
api.toggleElements = toggleElements;
api.toggleMarker = toggleMarker;

// Toggle visibility of elements
function toggleElements(selector, visible) {
	msg();

	// Instead of modifying all elements we could modify CSS rules as well, but it seems that this does not improve performance very much
	for (const ele of document.getElementById("svg").querySelectorAll(selector)) {
		if (visible) {
			ele.classList.remove("hidden");
		} else {
			ele.classList.add("hidden");
		}
	}
}

// Toggle visibility of marker
function toggleMarker(visible) {
	msg();
	// Modify svg css (nice, but only works in the browser, not during PNG export)
	/*
	const cssVariables = document.getElementById("css-marker-colors").sheet.rules[0].style;
	["Eisenbahn", "Strassenbahn", "Strasse", "Wasserwege", "Steuerstrecken", "GBS"].forEach(function(name) {
		if (visible) {
			cssVariables.setProperty(`--${name}-marker-color`, `var(--${name}-color)`);
		} else {
			cssVariables.setProperty(`--${name}-marker-color`, `none`);
		}
	});
	*/

	// Modify svg css to use same setting during PNG export
	if (visible) {
		document.getElementById("css-marker-colors").textContent =
			`svg {
				--Eisenbahn-marker-color: var(--Eisenbahn-color);
				--Strassenbahn-marker-color: var(--Strassenbahn-color);
				--Strasse-marker-color: var(--Strasse-color);
				--Wasserwege-marker-color: var(--Wasserwege-color);
				--Steuerstrecken-marker-color: var(--Steuerstrecken-color);
				--GBS-marker-color: var(--GBS-color);
				--Kamera-marker-color: var(--Kamera-color);
			}`;
	} else {
		document.getElementById("css-marker-colors").textContent =
			`svg {
				--Eisenbahn-marker-color: none;
				--Strassenbahn-marker-color: none;
				--Strasse-marker-color: none;
				--Wasserwege-marker-color: none;
				--Steuerstrecken-marker-color: none;
				--GBS-marker-color: none;
				--Kamera-marker-color: none;
			}`;
	}
}

function msg(key, ...args) {
	if (key) {
		// Get translated text for topic 'msg'
		// Show text only therefore we do not need to use innerHTML
		document.getElementById("message").textContent = EEP_Texts.getText("msg", key, ...args);
	} else if (key === "") {	// show literal text
		document.getElementById("message").textContent = args.reduce((a, b) => { return a + ", " + b;});
	} else {
		document.getElementById("message").textContent = "";
	}
}

function changeStrokeWidth(panZoom) {

	const sliderValue 		= document.getElementById("strokeWidth").value;
	const autoStrokeWidth 	= document.getElementById("autoStrokeWidth").checked;
	
	let strokeWidth;

	if (autoStrokeWidth) {
		// automatic stroke width
		const sizes 	= panZoom.getSizes();	// width height of svg area
												// viewBox (x y width height)
												// realZoom = min(width/viewBox.width, height/viewBox.height)
		const zoom 		= panZoom.getZoom();	// zoom factor

		if (!sizes.realZoom) {
			sizes.realZoom = 1;
		}
		// It seems that a power function for realZoom works quite well
		strokeWidth = 1.5 * sizes.realZoom ** -0.7;
		// Adjust automatic value slightly depending on slider with factor range [0.25 .. 3.25]
		strokeWidth *= ( 0.25 + sliderValue / 50 );

/*
console.log( "changeStrokeWidth"
	+ "\tautoStrokeWidth\t" 	+ autoStrokeWidth
	+ "\tsliderValue\t" 		+ sliderValue 
	+ "\tstrokeWidth\t" 		+ strokeWidth
	+ "\tzoom\t" 				+ zoom
	+ "\trealZoom\t" 			+ sizes.realZoom
	+ "\twidth\t" 				+ sizes.width
	+ "\theight\t" 				+ sizes.height
	+ "\tviewBox.width\t" 		+ sizes.viewBox.width
	+ "\tviewBox.height\t" 		+ sizes.viewBox.height
);
*/

	} else {
		// manual stroke width
		// Use exponential function to convert the slider value into range [0.11 .. 2.12] with f(75) = 1
		// f = 0.1054 * exp(0.03 * v)
		strokeWidth = 0.1054 * Math.exp(0.03 * sliderValue);
		
		// smalles lines look better
		strokeWidth *= 0.5;

console.log( "changeStrokeWidth"
	+ "\tautoStrokeWidth\t" 	+ autoStrokeWidth
	+ "\tsliderValue\t" 		+ sliderValue 
	+ "\tstrokeWidth\t" 		+ strokeWidth
);

	}

	// Modify svg css (nice, but only works in the browser, not during PNG export)
	/*
	const cssVariables = document.getElementById("css-strokeWidth-variables").sheet.rules[0].style;
	cssVariables.setProperty("--normal-stroke-width", `${ strokeWidth }px`);
	cssVariables.setProperty("--narrow-stroke-width", `${ strokeWidth / 2 }px`);
	*/

	// Modify svg css to use same setting during PNG export
	document.getElementById("css-strokeWidth-variables").textContent =
		`svg {
			--normal-stroke-width: ${ strokeWidth }px;
			--narrow-stroke-width: ${ strokeWidth / 2 }px;
		}`;
}

function changefontSize(value) {
	// Use exponential function to convert the slider value into range [0.11 .. 2.12] with f(75) = 1
	// f = 0.1054 * exp(0.03 * v)
	const factor = 0.1054 * Math.exp(0.03 * value);

	// Modify svg css (nice, but only works in the browser, not during PNG export)
	// (we maybe could use calc(3 * var(--font-size-factor, 1) * 1px) as well to avoid the constants here)
	/*
	const cssVariables = document.getElementById("css-fontSize-variables").sheet.rules[0].style;
	cssVariables.setProperty("--normal-font-size", `${3 * factor}px`);
	*/

	// Modify svg css to use same setting during PNG export
	document.getElementById("css-fontSize-variables").textContent =
		`svg {
			--normal-font-size: ${4 * factor}px;
		}`;
}

function changeHeightRange(valueLow, valueHigh) {
	// skip call during initialization
	if (!global.usedArea) {
		return;
	}

	// localStorage.setItem("heightRange", valueLow + ","+ valueHigh);

	// Show min/max height
	const delta = ( global.usedArea.max.z - global.usedArea.min.z) / 100; // valueLow, valueHigh run from 0 to 100
	const minZ = global.usedArea.min.z + delta * valueLow;
	const maxZ = global.usedArea.min.z + delta * valueHigh;
	document.getElementById("heightArea").textContent = minZ.toFixed(1) + " .. " + maxZ.toFixed(1);

	// Adjust svg group elements
	const svgElem = document.getElementById("svg");
	for (const groupElem of svgElem.getElementsByTagName("g")) {
		for (const className of groupElem.classList){
			if (className.substring(0,7) === "height=") {  // Example: "height=123"
				const height = +className.substring(7);
				if (height < minZ || height > maxZ) {
					groupElem.classList.add("hiddenZ");
				} else {
					groupElem.classList.remove("hiddenZ");
				}
			}
		}
	}
}
})(this); // end module
</script>

<!-- replace deprecated CSS2 system colors -->
<!-- <link rel="stylesheet" href="node_modules/toolwindow/dist/toolwindow.css"/> -->
<link rel="stylesheet" href="css/toolwindow.css"/>
<!-- Not possible, see same issue above -->
<!-- <link rel="stylesheet" href="https://raw.githubusercontent.com/fluffynuts/toolwindow/master/dist/toolwindow.css"/> -->
<script type="text/javascript" src="node_modules/toolwindow/dist/toolwindow.js"></script>
<!-- Not possible, see same issue above -->
<!-- <script type="text/javascript" src="https://raw.githubusercontent.com/fluffynuts/toolwindow/master/dist/toolwindow.js"></script> -->
<!-- <script type="text/javascript" src="https://raw.githubusercontent.com/fluffynuts/toolwindow/master/dist/toolwindow.min.js"></script> -->

<aside id="infoPopup"> <!-- Info Window -->
<script type="text/javascript" src="js/EEP_Signale_Daten.js"></script> <!-- Lade Zusatzdaten zu Signalen: Name, Signalstellungen -->
<script type="text/javascript"> // Show information in Info Box
"use strict";
/* Interface
required standard objects:
	console
required global data:
	EEP_Texts
	GebaeudesammlungText
	GleisDataText
	Gleisart
	Signalstellung
	WeichenstellungText
	global
required functions:
	_
	TrackSystemText
	msg
	showInfoWindow
public api:
	getKontaktIcon
	getKontaktText
	objectToHTML
	showGleisInfo
	showKameraInfo
	showKontaktInfo
	showSignalInfo
	showVirtualConnectionInfo
	showWeicheInfo
*/
(function(api) {
// public api
api.getKontaktIcon = getKontaktIcon;
api.getKontaktText = getKontaktText;
api.objectToHTML = objectToHTML;
api.showGleisInfo = showGleisInfo;
api.showKameraInfo = showKameraInfo;
api.showKontaktInfo = showKontaktInfo;
api.showSignalInfo = showSignalInfo;
api.showVirtualConnectionInfo = showVirtualConnectionInfo;
api.showWeicheInfo = showWeicheInfo;

function objectToHTML(object) {
	let s = "";

	if (global.altDown) {							// only if alt-key is pressed
		s = object.outerHTML;						// get HTML representation of object
		s = s.replace(/</g,"&lt;");					// escaping of < is required
		s = s.replace(/>(?![a-zA-Z0-9])/g,"&gt;<br>");	// escaping of > is optional but allows adding line breaks (unless followed by Pos, Dir, Nor or Bin)
		s = s.replace(/\t/g," ");					// replace tabs
		s = s.replace(/\s{2,}/g, " ");				// replace duplicate spaces
		s = s.replace(/(\r\n|\n|\r)/g,"");			// remove line breaks
		s = "<br><br><code>" + s + "</code>";		// <br> at the end allows easy copy & paste
	}

	return s;
}

function showVirtualConnectionInfo(GleissystemID, GleisID, Anschluss) {
	const posX = 12, posY = 13, posZ = 14;

	const Gleissystem = global.Gleissysteme[GleissystemID];
	if (!Gleissystem){ return; }

	const Gleis 	= Gleissystem[GleisID];
	if (!Gleis){ return; }

	const connections = global.trackConnections[GleissystemID][GleisID];
	if (!connections){ return; }

	const connection = connections[Anschluss];
	if (!connection){ return; }

	const connectedGleis = global.Gleissysteme[GleissystemID][connection.GleisID];

	const vPos = ( Anschluss            === "Anfang" ? Gleis.mPos          : Gleis.mEnd          );	// Start of virtual connection	
	const vEnd = ( connection.Anschluss === "Anfang" ? connectedGleis.mPos : connectedGleis.mEnd );	// End of virtual connection	

	// Kurzform in msg-Element
	msg("", TrackSystemText(GleissystemID) + " " + GleisID + " " 
			+ Anschluss + " (" + vPos[posX].toFixed(0) + "m, " + vPos[posY].toFixed(0) + "m) "
			+ "⇔" + " "
			+ TrackSystemText(GleissystemID) + " " + connection.GleisID + " "
			+ connection.Anschluss + " (" + vEnd[posX].toFixed(0) + "m, " + vEnd[posY].toFixed(0) + ") "
			+ _('virtuell')
	);

	// Ausführlich im Info Popup
	const _i = "</i>", _a = "</a>";
	showInfoWindow({
		code: "V" + GleissystemID + "-" + GleisID + "-" + Anschluss,
		title: `${TrackSystemText(GleissystemID)} ${GleisID} ⇔ ${connection.GleisID} ${_('virtuell')}`,	// ☍ 260D ↝ 219D ↝ 2192 ↣ 21A3 ↦ 21A6 ⇄ 21C4 ⇔ 21D4 ⇿ 21FF
		content:
		    `${_('virtualConnection')}`
			+ `<br>${TrackSystemText(GleissystemID)} ${GleisID} ${Anschluss} (<a href="javascript:void(0);" onclick="javascript:global.SvgPanZoom.centerPosition([${vPos}])">${vPos[posX].toFixed(0)}m, ${vPos[posY].toFixed(0)}m<\/a>)`
			+ `<br>${_('und')}`
			+ `<br>${TrackSystemText(GleissystemID)} ${connection.GleisID} ${connection.Anschluss} (<a href="javascript:void(0);" onclick="javascript:global.SvgPanZoom.centerPosition([${vEnd}])">${vEnd[posX].toFixed(0)}m, ${vEnd[posY].toFixed(0)}m<\/a>)`
			+ `<br>${_('Länge')}: ${Math.sqrt((vPos[posX]-vEnd[posX])**2 + (vPos[posY]-vEnd[posY])**2).toFixed(0)}m`
			//+ objectToHTML( xxx )
	});
}

function showGleisInfo(GleissystemID, GleisID) {
	const Gleissystem = global.Gleissysteme[GleissystemID];
	if (!Gleissystem){ return; }

	const Gleis 	= Gleissystem[GleisID];
	if (!Gleis){ return; }

	const clsid 	= Gleis.getAttribute("clsid");		// Gleisart
	const stil 		= Gleis.getAttribute("stil");		// Gleisstil
	const gsbname 	= Gleis.getAttribute("gsbname");	// Dateiname

	const Key_Id	= Gleis.getAttribute("Key_Id"); 	// Id einer Weiche
	const GleisData	= Gleis.getAttribute("data"); 		// Bitfeld einer Weiche
														// 1: Oberleitung
														// 18: DKW (Weichen und zentrale Gleise)
														// 16: Zentrale Strecken einer Straßen-T-Kreuzung
														// 20: Weichen einer Straßen-T-Kreuzung

	let GleisobjektText = "";
	let KollektorID;
	if (global.KollektorTracks[GleissystemID]) {
		if (global.KollektorTracks[GleissystemID][GleisID]) {
			KollektorID = global.KollektorTracks[GleissystemID][GleisID].KollektorID;
		}
	}
	if (KollektorID) {
		const Gleisobjekt = global.Gleisobjekte[KollektorID];

		GleisobjektText = "<br>" + _('Gleisobjekt') + ": " + Gleisobjekt.gsbname
			+ "<br>" + _('Immobilie') + ": " + GebaeudesammlungText[Gleisobjekt.GebaudesammlungID] + " " + Gleisobjekt.ImmoIdx;
	}

	// Kurzform in msg-Element
	msg("", TrackSystemText(GleissystemID) + " " + GleisID,
			Gleisart[clsid],
			_('Stil') + " " + stil,
			gsbname
	);

	// Ausführlich im Info Popup
	const posX = 12, posY = 13, posZ = 14;

	// Show connected tracks
	let connectionText = "";
	const connections = global.trackConnections[GleissystemID][GleisID] || {};
	for (const connection in connections) {
		const connectedGleisID = connections[connection].GleisID;
		const connectedGleis = Gleissystem[connectedGleisID];
		connectionText += "<br>" + _(connection)
			+": "
			+ `<a href="javascript:void(0);" onclick="javascript:global.SvgPanZoom.centerPosition([${connectedGleis.mMid}])">${connectedGleisID}<\/a>`
			+ " " + ( connections[connection].Flags ? _('virtuell') : "" );
	}

	const _i = "</i>", _a = "</a>";
	showInfoWindow({
		code: "Gleis " + GleissystemID + "-" + GleisID,
		title: `${TrackSystemText(GleissystemID)} ${GleisID}`,
		content:
			`${_('Position')} ${_('Anfang')}: (<a href="javascript:void(0);" onclick="javascript:global.SvgPanZoom.centerPosition([${Gleis.mPos}])">${Gleis.mPos[posX].toFixed(0)}m, ${Gleis.mPos[posY].toFixed(0)}m<\/a>)`
			+ `<br>${_('Mitte')}: (<a href="javascript:void(0);" onclick="javascript:global.SvgPanZoom.centerPosition([${Gleis.mMid}])">${Gleis.mMid[posX].toFixed(0)}m, ${Gleis.mMid[posY].toFixed(0)}m<\/a>)`
			+ `<br>${_('Ende')}: (<a href="javascript:void(0);" onclick="javascript:global.SvgPanZoom.centerPosition([${Gleis.mEnd}])">${Gleis.mEnd[posX].toFixed(0)}m, ${Gleis.mEnd[posY].toFixed(0)}m<\/a>)`
			+ `<br>${_('Gleisart')}: ${Gleisart[clsid]}` + (Key_Id != null ? " " + Key_Id : "" )
			+ (GleisData != 0 ? `<br>${GleisDataText[GleisData]}` : "")
			+ `<br>${_('Stil')}: ${stil}`
			+ (gsbname != null ? `<br>${_('Datei')}: ${gsbname}` : "")
			+ GleisobjektText
			+ `<br>${_('Länge')}: ${Gleis.Laenge.toFixed(0)}m`
			+ `<br>${_('Höhe')}: ${Gleis.mPos[posZ].toFixed(2)}m`
			+ (Gleis.CurveType === 'classic' || Gleis.CurveType === 'EEPCurve' ? "" : `<br>${_('Kurventyp')}: ${Gleis.CurveType}`)
			+ connectionText
			+ objectToHTML(Gleis)
	});
}

function showWeicheInfo(WeicheID, GleissystemID, GleisID) {
	const Gleissystem = global.Gleissysteme[GleissystemID];
	if (!Gleissystem){ return; }

	const Gleis 	= Gleissystem[GleisID];
	if (!Gleis){ return; }

	const clsid 	= Gleis.getAttribute("clsid");		// Gleisart
	const stil 		= Gleis.getAttribute("stil");		// Gleisstil
	const gsbname 	= Gleis.getAttribute("gsbname");	// Dateiname

	const KontaktZiel 	= Gleis.getElementsByTagName("KontaktZiel")[0].textContent;
	const weichenstellung = Gleis.getAttribute("weichenstellung");
	const GleisData	= Gleis.getAttribute("data"); 		// Bitfeld einer Weiche
														// 1: Oberleitung
														// 18: DKW (Weichen und zentrale Gleise)
														// 16: Zentrale Strecken einer Straßen-T-Kreuzung
														// 20: Weichen einer Straßen-T-Kreuzung

	// Kurzform in msg-Element
	//msg(`Weiche ${WeicheID} auf ${TrackSystemText(GleissystemID)} ${GleisID}`);
	msg('SwitchLocation', WeicheID, TrackSystemText(GleissystemID), GleisID);

	// Show connected tracks
	let connectionText = "";
	const connections = global.trackConnections[GleissystemID][GleisID] || {};
	for (const connection in connections) {
		if (connection != "Anfang") {
			const connectedGleisID = connections[connection].GleisID;
			const connectedGleis = Gleissystem[connectedGleisID];
			connectionText += "<br>" + _(connection)
				+": "
				+ `<a href="javascript:void(0);" onclick="javascript:global.SvgPanZoom.centerPosition([${connectedGleis.mMid}])">${connectedGleisID}<\/a>`
				+ " " + ( connections[connection].Flags ? _('virtuell') : "" );
		}
	}

	// Ausführlich im Info Popup
	showInfoWindow({
		code: "Weiche " + WeicheID,
		title: _('Weiche') + " " + WeicheID,
		content:
			`<i>${_('Position')}: `
				+ `<a href="javascript:void(0);" onclick="javascript:global.SvgPanZoom.centerPosition([${Gleis.mEnd}]);">${TrackSystemText(GleissystemID)} ${GleisID}<\/a>`
				+ `<\/i>`
			+ `<br>${_('Gleisart')}: ${Gleisart[clsid]}`
			+ (GleisData   != 0 ? `<br>` + GleisDataText[GleisData] : "")
			+ `<br>${_('Weichenstellung')}: ${WeichenstellungText[weichenstellung]}`
			+ `<br>${_('Stil')}: ${stil}`
			+ (gsbname != null ? `<br>${_('Datei')}: ${gsbname}` : "")
			+ (KontaktZiel != null && KontaktZiel != 0 ? `<br>${_('Kontaktziel')}: ${KontaktZiel}` : "")
			+ connectionText
			+ objectToHTML(Gleis)
		});
}

function showSignalInfo(SignalID, GleissystemID, GleisID) {
	const Meldung 		= global.Meldungen[SignalID];
	if (!Meldung) { return; }

	const File 			= Meldung.getAttribute("name");		// Dateiname
	const Position		= Meldung.getAttribute("Position") / 100;
	const ParaOderAnti 	= Meldung.getAttribute("ParaOderAnti");
	const TipTxt	 	= Meldung.getAttribute('TipTxt');

	const KontaktZiel 	= Meldung.getElementsByTagName("KontaktZiel")[0].textContent;

	const Stellung		= Meldung.getElementsByTagName("Signal")[0].getAttribute("stellung");
	const SignalData	= Meldung.getElementsByTagName("Signal")[0].getAttribute("SignalData");
 	const Distanz		= Meldung.getElementsByTagName("Signal")[0].getAttribute("wirkungsdistanz") / 100; // Abstand zwischen Vor- und Hauptsignal
 	const StopAt		= Meldung.getElementsByTagName("Signal")[0].getAttribute("StopAt") / 100; // Halteabstand

	// Vor- / Hauptsignal
	let signalType      = "";
	const trackSignalEntries = global.trackSignals[GleissystemID][GleisID];
	if (trackSignalEntries) {
		for (const trackSignalEntry of trackSignalEntries) {
			const Meldung		= trackSignalEntry.Meldung;
			if (SignalID == Meldung.getAttribute("Key_Id")) {
				signalType	= trackSignalEntry.signalType;
			}
		}
	}

	// Fahrstraßen
	const Routes		= Meldung.getAttribute("Routes");
	const RouteList	 	= Meldung.getElementsByTagName("Route");

		function getSignalName(File) {
			let Name = '';
			if (!Signalstellung[File]) {
				// no name
			} else if (typeof(Signalstellung[File].Name) === "string") {
				Name = Signalstellung[File].Name;
			} else if (typeof(Signalstellung[File].Name) === "object") {
				Name = Signalstellung[File].Name[EEP_Texts.getLanguage()]
					|| Signalstellung[File].Name.DE
					|| Signalstellung[File].Name.EN
					;
			} else {
				// no name
			}
			return Name;
		}
		function getSignalPositionText(File, Position) {
			let Text = '';
			if (!Signalstellung[File]) {
				// no text
			} else if (typeof(Signalstellung[File].Pos[Position]) === "string") {
				Text = Signalstellung[File].Pos[Position];
			} else if (typeof(Signalstellung[File].Pos[Position]) === "object") {
				Text = Signalstellung[File].Pos[Position][EEP_Texts.getLanguage()]
					|| Signalstellung[File].Pos[Position].DE	// primary language
					|| Signalstellung[File].Pos[Position].EN	// secondary language
					;
			} else {
				// no text
			}

			// Default translations
			if (Text === "Fahrt") 	{ Text = _("Fahrt"); }
			if (Text === "Halt") 	{ Text = _("Halt"); }

			return Text;
		}
	let SignalTypeText;
	let SignalstellungText = "";	// Die Bedeutung der Signalstellung für Fahrstraßen ist noch unklar
	if (File === "system\\Route_SignalS.3ds") {
		SignalTypeText = _('Fahrstraße') + " " + _('Startsignal');
	} else if (File === "system\\Route_SignalZ.3ds") {
		SignalTypeText = _('Fahrstraße') + " " + _('Endesignal');
	} else {
		if (signalType == "pre") {
			SignalTypeText = _('Vorsignal');
		} else {
			SignalTypeText = _('Signal');
		}
		if (Signalstellung[File]) {
			// 1st try: Get texts (case sensitive file name)
			SignalstellungText = getSignalPositionText(File, Stellung);
		} else {
			// 2nd try: Get texts (case insensitive file name)
			for (const SignalFile in Signalstellung) {
console.log('SignalFile.toLowerCase() == File.toLowerCase()' + ' : ' + typeof(SignalFile.toLowerCase()) + ' == ' + typeof(File.toLowerCase()));
				if (SignalFile.toLowerCase() === File.toLowerCase()) {
					SignalstellungText = getSignalPositionText(SignalFile, Stellung);
				}
			}
		}
	}

	// Kurzform in msg-Element
	msg("", `${SignalTypeText} ${SignalID} ${File} ${_('auf')} ${TrackSystemText(GleissystemID)} ${GleisID}`
		+ `, ${_('Signalstellung')} ${Stellung} ${SignalstellungText}`
		+ (KontaktZiel != null && KontaktZiel != 0 ? `, ${_('Kontaktziel')}=${KontaktZiel}` : ""));

	// Ausführlich im Info Popup

	// Fahrstraßen
	const ColorText = { // <color> modulo 8
		0: { name: _('grau'),		color: "rgb(180,180,180)", 	},
		1: { name: _('rot'),		color: "rgb(220,0,0)", 		},
		2: { name: _('grün'),		color: "rgb(0,220,0)", 		},
		3: { name: _('blau'),		color: "rgb(0,0,220)", 		},
		4: { name: _('gelb'),		color: "rgb(220,220,0)", 	},
		5: { name: _('pink'),		color: "rgb(220,0,220)", 	},
		6: { name: _('hellblau'), 	color: "rgb(0,180,220)", 	},
		7: { name: _('orange'),		color: "rgb(220,110,0)",	},
	};
	let RoutesText = "";
	// Details für Start-Signale
	for (const Route of RouteList) {
		const Target 	= Route.getAttribute("Target");
		const Color 	= Route.getAttribute("Color");

		RoutesText 	+= `<br>${_('Zielsignal')}: `
					+ `<a href="javascript:void(0);" onclick="javascript:global.SvgPanZoom.centerPosition([${global.Meldungen[Target].mPos}]);">`
					+ Target
					+ `<\/a>, `
					+ `<span style="color:${ColorText[Color%8].color};">${_('Farbe')}: ${Color} ${ColorText[Color%8].name}<\/span>`;
	}
	// Details für Ende-Signale
	const EndRouteSignal = global.EndRouteSignals[SignalID];
	if (EndRouteSignal) {
		RoutesText 	+= `<br>`
		for (const Route of EndRouteSignal) {
			RoutesText +=
					_('Startsignal') + ': ' 
					+ `<a href="javascript:void(0);" onclick="javascript:global.SvgPanZoom.centerPosition([${global.Meldungen[Route.StartSignal].mPos}]);">`
					+ Route.StartSignal
					+ `<\/a>, `
					+ ', ' + '<span style="color:' + ColorText[Route.Color%8].color + ';">' + _('Farbe') + ': ' + Route.Color + ' ' + ColorText[Route.Color%8].name + '</span><br>'
					;
		}
	}
	showInfoWindow({
		code: "Signal " + SignalID + signalType,
		title: `${SignalTypeText} ${SignalID}`,
		content:
			`<i>${_('Position')}: `
				+ `<a href="javascript:void(0);" onclick="javascript:global.SvgPanZoom.centerPosition([${Meldung.mPos}]);">${TrackSystemText(GleissystemID)} ${GleisID}`
				+ ` +${Position.toFixed(1)}m<\/a><\/i>`
			//+ `<br>${(signalType ? signalType : "")}`
			+ `<br>${_('Name')}: ${File}`
			+ (Signalstellung[File] && File !== getSignalName(File) ? `<br>${getSignalName(File)}` : "")
			+ `<br>${_('Signalstellung')} ${Stellung}: ${SignalstellungText}`
			+ (Distanz !=0 ? `<br>${(signalType == "pre" ? _('Distanz zum Hauptsignal') :  _('Distanz zum Vorsignal'))}: ${Distanz.toFixed(0)}m` : "")
			+ (StopAt != 0 ? `<br>${_('Halteabstand')}: ${StopAt.toFixed(0)}m`: "")
			+ `<br>${_('Gleisrichtung')}: ${ParaOderAnti} ` + (ParaOderAnti == 1 ? _('in Gleisrichtung') : _('gegen Gleisrichtung'))
			+ (SignalData != null ? `<br>${_('SignalData')}: ${SignalData}` : "")
			+ (KontaktZiel != null && KontaktZiel != 0 ? `<br>${_('Kontaktziel')}: ${KontaktZiel}` : "")
			+ (Routes ? `<br>${_('Fahrstraßen')}: ${Routes}` : "")
			+ (RoutesText !== "" ? RoutesText : "")
			+ (TipTxt && TipTxt !== "" ? `<br>${_('TipTxt')}: ${TipTxt}` : "")
			+ objectToHTML(Meldung)
		});
}

function getKontaktIcon(GleissystemID, SetType, SetValue) {
	// https://www.compart.com/de/unicode/category/So
	const KontaktIcon = { 	// Sometimes the symbol works fine but sometime the unicode-code is necessary in Notepad++
		0 		: '⭢', 		// Weiche/Signal			⭢ \u2B62 → \u8594 &rarr;

		8 		: '🛑', 		// Halt nach x m			🛑 \u1f6d1
		
		128 	: '🧍', 		// Omegas					🧍 \u1F9CD
		256 	: '\u266C', // Sound					🔊 \u1F50A ♫ \u266B ♬ \u266C
		512 	: '📷', 	// Kamera 					📷 \u1F4F7
		768 	: '🏠', 	// Immobilie				🏠 \u1F3E0
		1024 	: '\u2387', // DKW/EKW					💢 ⎇ \u2387
		1280 	: '\u21E4', // Einfahrt Depot			⇤ \u21E4 ⇥ \u21E5 ⍖ \u2356 ⭢
		1536 	: '\u21A4', // Ausfahrt Depot			↤ \u21A4 ↦ \u21A6 ⍏ \u234F ⭢
		2048 	: '\u2398', // Animationen				⮔ 2B94 ⎘ \u2398 ↬ \u21AC ↝ \u219D
		32768	: '\u2042',	// Gruppe					⁂ \u2042 ⭢
							// 							⌂ \u2302 ⌥ \u2325   → = &rarr; = \u8594;   ⭢ = \u2B62
	};

	let Icon;

	// spezielle Kontakte
	if (SetType >= 1 && SetType <= 39 && SetType != 8) {				// Fahrzeug je nach Gleissystem	
		// Eisenbahn:	🚂🚃🚄🚅🚆🚇🚈🚉🚊🚝🚞
		// Straßenbahn:	🚎🚟🚠🚡
		// Straße:		🚌🚍🚐🚑🚒🚓🚔🚕🚖🚗🚘🚙🚚🚛🚜🚲🚴🚵⛟
		// Wasserwege:	⛴🚢🚣🚤⛵🚀🚁✈
		// Immobilien:	🏠🏡🏢🏣🏤🏥🏦🏧🏨🏩🏪🏫🏬🏭🏮🏯🏰
		Icon = { 1: '🚂', 2: '🚎', 3: '🚗', 4: '⛴', 5: '🚕', 6: ""}[GleissystemID];	// 	🚆 \u1F686 🚗 \u1f697 ⛴ \u26f4 ⛟ \u26DF

	} else if (SetType == 256 && SetValue && global.Sounds[SetValue]) { // Sound vorhanden
		Icon = '🔊';

	} else {
		Icon = (KontaktIcon[SetType] ? KontaktIcon[SetType] : ""); 		// see above
	}

	return Icon;
}

function getKontaktText(GleissystemID, SetType, SetValue, Wartender, VolDist, ConnectF) {
	// Achtung: die Variable $1 wird ersetzt
	const KontaktText = {	// SetValue
		0 		: _('Weiche/Signal'),

		8 		: _('Halt $1 m'), // Haltekontakt für befahrbares Rollmaterial
		
		1 		: _('Fahrzeug')+(+SetValue > 0 ? " "+_('Geschwindigkeit')+" "+_('nicht langsamer als $1 km/h') : ""),
		2 		: _('Fahrzeug')+" "+_('Geschwindigkeit')+" "+_('nicht schneller als $1 km/h'),
		3 		: _('Fahrzeug')+" "+_('Geschwindigkeit')+" "+_('festlegen auf $1 km/h'),

		5 		: _('Fahrzeug')+" "+_('Fahrtrichtungsumkehr')+(+SetValue > 0 ? ", "+_('Geschwindigkeit')+" "+_('nicht langsamer als $1 km/h') : ""),
		6 		: _('Fahrzeug')+" "+_('Fahrtrichtungsumkehr')+", "+_('Geschwindigkeit')+" "+_('nicht schneller als $1 km/h'),
		7 		: _('Fahrzeug')+" "+_('Fahrtrichtungsumkehr')+", "+_('Geschwindigkeit')+" "+_('festlegen auf $1 km/h'),
		
		17 		: _('Fahrzeug')+" "+_('Geschwindigkeit')+" "+_('wiederherstellen')+(+SetValue > 0 ? ", "+_('nicht langsamer als $1 km/h') : ""),
		18 		: _('Fahrzeug')+" "+_('Geschwindigkeit')+" "+_('wiederherstellen')+", "+_('nicht schneller als $1 km/h'),
		19 		: _('Fahrzeug')+" "+_('Geschwindigkeit')+" "+_('wiederherstellen')+", "+_('festlegen auf $1 km/h'),

		21 		: _('Fahrzeug')+" "+_('Fahrtrichtungsumkehr')+", "+_('Geschwindigkeit')+" "+_('wiederherstellen')+(+SetValue > 0 ? ", "+_('nicht langsamer als $1 km/h') : ""),
		22 		: _('Fahrzeug')+" "+_('Fahrtrichtungsumkehr')+", "+_('Geschwindigkeit')+" "+_('wiederherstellen')+", "+_('nicht schneller als $1 km/h'),
		23 		: _('Fahrzeug')+" "+_('Fahrtrichtungsumkehr')+", "+_('Geschwindigkeit')+" "+_('wiederherstellen')+", "+_('festlegen auf $1 km/h'),
		
		33 		: _('Fahrzeug')+" "+_('Geschwindigkeit')+" "+_('vormerken')+(+SetValue > 0 ? ", "+_('nicht langsamer als $1 km/h') : ""),
		34 		: _('Fahrzeug')+" "+_('Geschwindigkeit')+" "+_('vormerken')+", "+_('nicht schneller als $1 km/h'),
		35 		: _('Fahrzeug')+" "+_('Geschwindigkeit')+" "+_('vormerken')+", "+_('festlegen auf $1 km/h'),

		37 		: _('Fahrzeug')+" "+_('Fahrtrichtungsumkehr')+", "+_('Geschwindigkeit')+" "+_('vormerken')+(+SetValue > 0 ? ", "+_('nicht langsamer als $1 km/h') : ""),
		38 		: _('Fahrzeug')+" "+_('Fahrtrichtungsumkehr')+", "+_('Geschwindigkeit')+" "+_('vormerken')+", "+_('nicht schneller als $1 km/h'),
		39 		: _('Fahrzeug')+" "+_('Fahrtrichtungsumkehr')+", "+_('Geschwindigkeit')+" "+_('vormerken')+", "+_('festlegen auf $1 km/h'),
		
		128 	: _('Omegas'),
		256 	: _('Sound'),
		512 	: _('Kamera'),
		768 	: _('Immobilie'),
		1024 	: _('DKW/EKW'),
		1280 	: _('Einfahrt Depot')+" "+Wartender, 	// Depot-ID = Wartender (0=default)
		1536 	: _('Ausfahrt Depot')+" "+SetValue,		// Depot-ID = SetValue
		2048 	: _('Animationen'),
		32768 	: _('Gruppen-Kontaktpunkt'),
	};

	let Text 	= (KontaktText[SetType] ? KontaktText[SetType] : _('unbekannt'));

	// Spezielle Kontakt-Typen
	if 		  (SetType == 0) {	// Weiche/Signal
		//if      (Weichen.find(function(Weiche) { return Weiche.ID == KontaktZiel}) ) 	{ KontaktTypText = _('Weiche'); }
		//else if (Signale.find(function(Signal) { return Signal.ID == KontaktZiel}) ) 	{ KontaktTypText = _('Signal'); }
		//else 																			{ KontaktTypText = 'Kontaktziel nicht gefunden'; }

	} else if (SetType >= 1 && SetType <= 39) {		// Fahrzeug
		Text = Text.replace("$1", SetValue);		// Geschwindigkeit eintragen

	} else if (SetType == 256 && SetValue && global.Sounds[SetValue]) {	// Sound vorhanden
			Text 	= global.Sounds[SetValue];

	} else if (SetType == 512) {	// Kamera
		/* ConnectF: 4 Byte Ganzzahl
			Byte 1 (LSB):	KameraID Start
			Byte 2:			Perspektive Start
			Byte 3:			KameraID Ende
			Byte 4:			Perspektive Ende
		*/
		const Perspektive = {
			0 : _('keine Perspektive festgelegt'),
			1 : _('Fahrzeug von links'),
			2 : _('Fahrzeug von rechts'),
			3 : _('Fahrzeug von links oben'),
			4 : _('Fahrzeug von rechts oben'),
			5 : _('Sicht in Fahrtrichtung'),
			6 : _('Rückwärtige Sicht'),
			7 : _('Folgemodus'),
			8 : _('Sicht in Kabine'),
		};

		// convert 32bit int to array of 4 bytes
		function convertIntToBytes( x ) {
			const bytes = [0, 0, 0, 0,];
			let i = 4;
			do {
				bytes[--i] = x & (255);
				x = x>>8;
			} while ( i && x > 0 );
			return bytes;
		}

		if (ConnectF) {
			const [EndePerspektive, EndeKameraID, StartPerspektive, StartKameraID] = convertIntToBytes( ConnectF );
			const StartKamera = global.KameraSet[StartKameraID];
			const EndeKamera = global.KameraSet[EndeKameraID];

console.log('Kamera'
	+ ' StartKameraID=' + StartKameraID
	+ ' StartPerspektive=' + StartPerspektive
	+ ' EndeKameraID=' + EndeKameraID
	+ ' EndePerspektive=' + EndePerspektive
);

			Text = ""		// <Kamera Icon> <Start Kamera> [<Perspektive>] / <Ende Kamera> nach <t> Sek. [<Perspektive>]
				+ (StartKamera
					? `<a href="javascript:void(0);" onclick="javascript:global.SvgPanZoom.centerPosition([${StartKamera.mPos}])">${StartKamera.Name}<\/a>`
					: "" )
				+ (StartPerspektive > 0
					? ` [${Perspektive[StartPerspektive]}]`
					: "" )
				+ (EndeKamera
					? ` / <a href="javascript:void(0);" onclick="javascript:global.SvgPanZoom.centerPosition([${EndeKamera.mPos}])">${EndeKamera.Name}<\/a> ${_('nach')} ${SetValue} ${_('Sekunden')}`
					: "" )
				+ (EndePerspektive > 0
					? ` [${Perspektive[EndePerspektive]}]`
					: "" );
		} else {
			Text = _('Kamera');
		}

	} else if (SetType == 1024) {	// DKW/EKW Weichenstellung
		const VolDistText = {
			0 : _('Umschalter'),
			1 : _('links-links'),
			2 : _('links-rechts'),
			3 : _('rechts-rechts'),
			4 : _('rechts-links'),
		};

		Text += " " + VolDistText[VolDist];

	}

	return Text;
}

function showKontaktInfo(KontaktID, GleissystemID, GleisID) {
//<Kontakt Position="2186.82" ParaOderAnti="0" fireOnPara="1" fireOnAnti="0" Teiler="1" ActTeiler="0" TrainSide="0" Route="0" Route2="0" SetType="0" SetValue="0" Delay="0" ActDelay="0" TrainID="0" TrainID2="0" Light="2" LastTrainID="6" LastOfs="2213.881" ConnectF="2" ConnectR="2" VolDist="28" zuStellung="1" Wartender="0" AxisPos="0" AxisFilter="" NameFilter="" TrainNewName="" KontaktDist="0" TrainDist="0" LuaFn="" Group="0" SignalData="0" KontaktZiel="1" Wechseln="0" clsid="5E9A3049-D465-4602-A285-6A9774DCF1BF"/>
	const Kontakt		= global.Kontakte[KontaktID];
	const SetType 		= +Kontakt.getAttribute("SetType");
	const SetValue 		= +Kontakt.getAttribute("SetValue");
	const KontaktZiel 	= +Kontakt.getAttribute("KontaktZiel");
	const Position		= Kontakt.getAttribute("Position") / 100;
	const ParaOderAnti 	= Kontakt.getAttribute("ParaOderAnti"); // Gleisrichtung 0: Ende -> Anfang, 1: Anfang -> Ende
	const fireOnPara 	= Kontakt.getAttribute("fireOnPara");
	const fireOnAnti 	= Kontakt.getAttribute("fireOnAnti");
	const Teiler 		= Kontakt.getAttribute("Teiler");
	const ActTeiler 	= Kontakt.getAttribute("ActTeiler");
	const Delay 		= Kontakt.getAttribute("Delay");
	const ActDelay 		= Kontakt.getAttribute("ActDelay");
	const TrainSide 	= Kontakt.getAttribute("TrainSide");
	const RouteID 		= Kontakt.getAttribute("Route");
	const RouteID2 		= Kontakt.getAttribute('Route2');
	const TrainID 		= Kontakt.getAttribute("TrainID");
	const TrainID2 		= Kontakt.getAttribute('TrainID2');
	const Light 		= Kontakt.getAttribute('Light');
	const LastTrainID	= Kontakt.getAttribute('LastTrainID');
	const LastOfs		= Kontakt.getAttribute('LastOfs');
	const NameFilter 	= Kontakt.getAttribute("NameFilter");
	const TrainNewName 	= Kontakt.getAttribute("TrainNewName");
	const KontaktDist 	= Kontakt.getAttribute('KontaktDist');
	const TrainDist 	= Kontakt.getAttribute('TrainDist');
	const zuStellung 	= Kontakt.getAttribute("zuStellung");
	const Wartender 	= Kontakt.getAttribute("Wartender");
	const Wechseln 		= Kontakt.getAttribute("Wechseln");
	const ConnectF 		= Kontakt.getAttribute("ConnectF");
	const ConnectR 		= Kontakt.getAttribute("ConnectR");
	const VolDist 		= Kontakt.getAttribute("VolDist");
	const SignalData 	= Kontakt.getAttribute("SignalData");
	const AxisPos 		= Kontakt.getAttribute('AxisPos'); 
	const AxisFilter 	= Kontakt.getAttribute('AxisFilter');
	const LuaFn 		= Kontakt.getAttribute("LuaFn");
	const Group		 	= Kontakt.getAttribute('Group');
	const TipTxt	 	= Kontakt.getAttribute('TipTxt');

	const TrainSidetext = {
		0 : _('Spitze'),
		1 : _('Schluss'),
		[-1] : _('Gruppen-Kontaktpunkt'),
	};

	// SignalData
	/*
	Byte 1 - 2 (LSB)
		Key-ID des abgefragten Signals oder Weiche
	Byte 3 - 4 (MSB)
		Signal- oder Weichenstellung, die gegeben sein muss, damit der Kontakt schaltet
		Signal:
			1=Fahrt
			2=Halt
		Weiche:
			1=Durchfahrt
			2=Abzweig
			3=Koabzweig
		EKW:
			1=von links nach rechts
			2=von rechts nach rechts
			3=von rechts nach links
		DKW:
			1=von links nach links
			2=von links nach rechts
			3=von rechts nach rechts
			4=von rechts nach links
	*/
	const SignalDataStellung = Math.floor(SignalData / 65536);
	const SignalDataID   	 = SignalData - SignalDataStellung * 65536;

	let Meldung, Gleis;
	const Ziel = global.KontaktZiele[KontaktZiel];
	if (Ziel) {
		Meldung = global.Meldungen[Number(Ziel.ID)];
		Gleis = global.Weichen[Number(Ziel.ID)];
	}

	// Zugverband`
	//const Zugverband = Zugverbaende.get(Number(TrainID)); // Zugverbaende.find(function(Zugverband) { return Zugverband.ID == TrainID});

	// Kurzform in msg-Element
	//msg(`Kontakt auf ${TrackSystemText(GleissystemID)} ${GleisID}`);
	msg('ContactLocation', TrackSystemText(GleissystemID), GleisID);

	// Ausführlich im Info Popup
	showInfoWindow({
		code: "Kontakt " + KontaktID,
		title: _('Kontakt'),
		content:
			`<i>${_('Position')}: `
				+ `<a href="javascript:void(0);" onclick="javascript:global.SvgPanZoom.centerPosition([${Kontakt.mPos}]);">`
				+ `${TrackSystemText(GleissystemID)} ${GleisID} +${Position.toFixed(1)}m<\/a><\/i>`
			+ `<br>${_('Kontakttyp')} ` + SetType + ": "
			// KontaktTyp[SetType] mit Modifikation
			+ getKontaktIcon(GleissystemID, SetType, SetValue) + " "
			+ getKontaktText(GleissystemID, SetType, SetValue, Wartender, VolDist, ConnectF)
			+ (SetType == 768 ||  SetType == 1024 ? `<br>${_('ImmoIdx')}: ` + SetValue : "")	// Verweis auf ImmoIdx
			//+ (SetType == 512 && ConnectF != 0 ? `<br>ConnectF: ` + ConnectF : "")
			+ (KontaktZiel != null && KontaktZiel != 0
				? `<br>${_('Kontaktziel')} ${KontaktZiel}: `
					+ ( Ziel ?
							`<a href="javascript:void(0);" onclick="javascript:global.SvgPanZoom.centerPosition([${(Meldung ? Meldung.mPos : (Gleis ? Gleis.mEnd : undefined))}]);">`
							+ `${Ziel.Typ} ${Ziel.ID} ${_('auf')} ${TrackSystemText(Ziel.GleissystemID)} ${Ziel.GleisID}`
							+ `<\/a>`
						  : _('unbekannt')
					  )
				: "")
			+ `<br>${_('Auslösung')}: `		+ (			fireOnPara == 1 && fireOnAnti == 0 ? (ParaOderAnti == 1 ? _('in Gleisrichtung') : _('gegen Gleisrichtung'))
											: ( 	fireOnPara == 0 && fireOnAnti == 1 ? (ParaOderAnti == 0 ? _('in Gleisrichtung') : _('gegen Gleisrichtung'))
												: ( fireOnPara == 1 && fireOnAnti == 1 ? _('beide Richtungen') : "" )
											  )
										  )
			+ (Teiler != 0 			? `<br>${_('Zug-Zähler')}: ` + Teiler : "")
			+ (ActTeiler != 0 		? `<br>${_('Zählerstand')}: `		+ ActTeiler : "")
			+ (Delay != 0 			? `<br>${_('Zeitverzögerung')}: `	+ Delay : "")
			+ (ActDelay != 0 		? `<br>${_('Zeit abgelaufen')}: `	+ ActDelay : "")
			+ `<br>${_('Zugposition')}: ` + (TrainSidetext[TrainSide] ? TrainSidetext[TrainSide] : TrainSide)
			+ (RouteID != 0 		? `<br>${_('für Route')}: ` + global.Routen[RouteID] : "")
			+ (TrainID != 0 		? `<br>${_('für Zug')}: ` + TrainID /*+ " " + (Zugverband ? Zugverband.Name : 'nicht vorhanden') */ : "")
			+ (NameFilter !== ""	? `<br>${_('Zug-Filter')}: `		 + NameFilter : "")
			+ (TrainNewName !== ""	? `<br>${_('Neuer Zugname')}: `	 + TrainNewName : "")
			+ (zuStellung > 0 && Wechseln == 0 ? `<br>${_('zu Stellung')}: ` + zuStellung : (Wechseln == 1 ? _('Umschalter') : ""))
			+ (SignalData != 0 		? `<br>${_('SignalData')}: ID=${SignalDataID} ${_('Signalstellung')}=${SignalDataStellung}` : "")
			+ (AxisPos && AxisPos != 0 ? `<br>` + (SetType == 1 // Fahrzeug 
													? _("Achsengruppe") + ": " + (-AxisPos)
													: _("AxisPos")      + ": " + AxisPos 
												  ) 
										: '')
			+ (LuaFn && LuaFn !== "" ? `<br>${_('LuaFn')}: <kbd>${LuaFn}<\/kbd>` : "")
			+ (TipTxt && TipTxt !== "" ? `<br>${_('TipTxt')}: ${TipTxt}` : "")
			+ objectToHTML(Kontakt)
	});
}

function showKameraInfo(KameraID) {
//<Kammera name="..." DOF="0" Dynamic="0" FocalIdx="193" FStopIdx="13" SubDist="100" DOFSubDist="100" DOFShiftNear="9.65" DOFShiftFar="12.965" FOV="0" TakeSwitch="0">
	function angle(rad) {
		return (rad*180/Math.PI).toFixed(1) + "°";
	}

	const Kamera 		= global.KameraSet[KameraID];
	if (!Kamera) { return; }

	const [DirX, DirY, DirZ, d0, NorX, NorY, NorZ, n0, BinX, BinY, BinZ, b0, PosX, PosY, PosZ, scale ] = Kamera.mPos;

	// https://www.matheplanet.com/default3.html?call=viewtopic.php?topic=140833&ref=https%3A%2F%2Fwww.google.com%2F

	// https://www.java-forum.org/thema/rotationswinkel-aus-einer-tansformationsmatrix-berechnen.158869/
	// oder  https://de.wikipedia.org/wiki/Roll-Nick-Gier-Winkel#Berechnung_aus_Rotationsmatrix
	// beta	= atan2( -r[2][0], sqrt(pow(r[0][0], 2) + pow(r[1][0], 2)) )
	// if beta <> Math.PI/2
	// 	 alpha = atan2( r[1][0]/cos(beta), r[0][0]/cos(beta) )
	// 	 gamma = atan2( r[2][1]/cos(beta), r[2][2]/cos(beta) )
	// else
	// 	 alpha = 0
	// 	 gamma = sign(beta) * atan2( r[0][1], r[1][1] );

/*
Deep Ocean						X°					Y° 					Z°
													Neigung					Richtung
								atan2(NorZ, BinZ)	-asin(DirZ)			-acos( DirX/cos(angleY) )
Anleger ELSA Kurhotel 			X: 0.0° 			Y: -2.4° 			Z: -72.0°
Bhf Einstädt					X: 0.0° 			Y: 9.6° 			Z: -162.0°
DANGER! Frachter 				X: 0.0° 			Y: 16.8° 			Z: -150.0°
Des Käptn´s Häuschen 			X: 0.0° 			Y: 2.4° 			Z: -72.0°
Industrieruine  				X: 0.0° 			Y: 12.0° 			Z: 36.0°
Kamerarundblick 				X: 0.0° 			Y: 2.4° 			Z: -90.0°
Kuhl bleiben 					X: 0.0° 			Y: -4.8° 			Z: -107.9°
Leuchtturmidylle 				X: 0.0° 			Y: 31.2° 			Z: 126°
Lokverladung in die VOGELFLUG 	X: 0.0° 			Y: 9.6° 			Z: -113.7°
Motorbootanleger 				X: 0.0° 			Y: -2.4° 			Z: -138.0°
Roofer 							X: 0.0° 			Y: 40.8° 			Z: -18.0°
Schuettgutverladung 			X: 0.0° 			Y: 7.2° 			Z: -42.2°
*/

	const angleY 	= -Math.asin( DirZ );
				//	= Math.acos( BinZ );
				//	= -Math.atan2( DirZ, BinZ );

	const angleX 	= ( Math.cos(angleY) === 0 ? 0 :
						 Math.asin( Math.min(1, Math.max(-1, NorZ/Math.cos(angleY)) )) 	// protect against rounding errors
						 );
				//	= Math.atan2( NorZ, BinZ );

	const angleZ 	= ( Math.cos(angleY) === 0 ? 'error' :
						-Math.acos( Math.min(1, Math.max(-1, DirX/Math.cos(angleY)) )) 	// protect against rounding errors
						* (DirY<0 ? -1 : 1) );											// adjust sign

/*console.log(Kamera.Name
//	+ '\nasin( DirX )=\t' + angle( -Math.asin( DirX ) )
//	+ '\nacos( DirX )=\t' + angle( Math.acos( DirX ) )
	+ '\nY: asin( DirZ )=\t' + angle( -Math.asin( DirZ ) )
//	+ '\nacos( DirZ )=\t' + angle( Math.acos( DirZ ) )
//	+ '\nasin( BinX )=\t' + angle( -Math.asin( BinX ) )
//	+ '\nacos( BinX )=\t' + angle( Math.acos( BinX ) )
//	+ '\nasin( BinZ )=\t' + angle( -Math.asin( BinZ ) )
	+ '\nY: acos( BinZ )=\t' + angle( Math.acos( BinZ ) )

//	+ '\natan2( DirX, NorX )=\t' + angle( Math.atan2( DirX, NorX ) )
//	+ '\natan2( NorX, BinX )=\t' + angle( Math.atan2( NorX, BinX ) )
//	+ '\natan2( BinX, DirX )=\t' + angle( Math.atan2( BinX, DirX ) )

//	+ '\natan2( DirZ, NorZ )=\t' + angle( Math.atan2( DirZ, NorZ ) )
	+ '\nX: atan2( NorZ, BinZ )=\t' + angle( Math.atan2( NorZ, BinZ ) )
//	+ '\natan2( BinZ, DirZ )=\t' + angle( Math.atan2( BinZ, DirZ ) )

//	+ '\natan2( DirX, BinX )=\t' + angle( Math.atan2( DirX, BinX ) )
//	+ '\natan2( NorX, DirX )=\t' + angle( Math.atan2( NorX, DirX ) )
//	+ '\natan2( BinX, NorX )=\t' + angle( Math.atan2( BinX, NorX ) )

	+ '\nY: atan2( DirZ, BinZ )=\t' + angle( -Math.atan2( DirZ, BinZ ) )
//	+ '\natan2( NorZ, DirZ )=\t' + angle( Math.atan2( NorZ, DirZ ) )
//	+ '\natan2( BinZ, NorZ )=\t' + angle( Math.atan2( BinZ, NorZ ) )

//	+ '\nasin( DirX/cos(y) )=\t' + angle( Math.asin( DirX/Math.cos(angleY) ) )
//	+ '\nasin( NorX/cos(y) )=\t' + angle( Math.asin( NorX/Math.cos(angleY) ) )
//	+ '\nasin( BinX/cos(y) )=\t' + angle( Math.asin( BinX/Math.cos(angleY) ) )

//	+ '\nasin( DirY/cos(y) )=\t' + angle( Math.asin( DirY/Math.cos(angleY) ) )
//	+ '\nasin( NorY/cos(y) )=\t' + angle( Math.asin( NorY/Math.cos(angleY) ) )
//	+ '\nasin( BinY/cos(y) )=\t' + angle( Math.asin( BinY/Math.cos(angleY) ) )

//	+ '\nasin( DirZ/cos(y) )=\t' + angle( Math.asin( DirZ/Math.cos(angleY) ) )
	+ '\nX: nasin( NorZ/cos(y) )=\t' + angle( Math.asin( NorZ/Math.cos(angleY) ) )
//	+ '\nasin( BinZ/cos(y) )=\t' + angle( Math.asin( BinZ/Math.cos(angleY) ) )

	+ '\nZ: acos( DirX/cos(y) )=\t' + angle( -Math.acos( DirX/Math.cos(angleY) ) * (DirY<0 ? -1 : 1) )
//	+ '\nacos( NorX/cos(y) )=\t' + angle( Math.acos( NorX/Math.cos(angleY) ) )
//	+ '\nacos( BinX/cos(y) )=\t' + angle( Math.acos( BinX/Math.cos(angleY) ) )

//	+ '\nacos( DirY/cos(y) )=\t' + angle( Math.acos( DirY/Math.cos(angleY) ) )
//	+ '\nacos( NorY/cos(y) )=\t' + angle( Math.acos( NorY/Math.cos(angleY) ) )
//	+ '\nacos( BinY/cos(y) )=\t' + angle( Math.acos( BinY/Math.cos(angleY) ) )

//	+ '\nacos( DirZ/cos(y) )=\t' + angle( Math.acos( DirZ/Math.cos(angleY) ) )
//	+ '\nacos( NorZ/cos(y) )=\t' + angle( Math.acos( NorZ/Math.cos(angleY) ) )
//	+ '\nacos( BinZ/cos(y) )=\t' + angle( Math.acos( BinZ/Math.cos(angleY) ) )

)*/

	// Kurzform in msg-Element
	//msg(`Kamera ${Kamera.Name}`);
	msg('Camera', Kamera.Name);

	// Ausführlich im Info Popup
	showInfoWindow({
		code: "Kamera " + KameraID + " " + Kamera.Name,
		title: '📷 ' + Kamera.Name, // 📷 \u1F4F7
		content: //`<b>${Kamera.Name}<\/b><br>` +
			  `${_('Position')}: (<a href="javascript:void(0);" onclick="javascript:global.SvgPanZoom.centerPosition([${Kamera.mPos}])">${PosX.toFixed(0)}m, ${PosY.toFixed(0)}m<\/a>)`
			+ `<br>${_('Höhe')}: ${PosZ.toFixed(0)}m`
			+ `<br>${_('Blickrichtung')}: ` 		 + angle( -angleZ )			// svg: mirrored y-coordinate
			+ " " + ['W', 'WNW', 'NW', 'NNW', 'N', 'NNO', 'NO', 'ONO', 'O', 'OSO', 'SO', 'SSO', 'S', 'SSW', 'SW', 'WSW', 'W',][Math.floor(8+0.5+angleZ/Math.PI*8)] 
			+ `<br>${_('Neigung')}: ` 				 + angle( angleY )			// Neigung Y
			+ (angleX < -0.01 || angleX > 0.01 ? `<br>${_('Kippung')}: ` + angle( angleX ) : "")	// Neigung X
			+ `<br>` + (Kamera.Dynamic == 1 ? _('dynamisch') : _('statisch') )	// Bug: the camera type is not defined by an attribute in EEP 6
			+ objectToHTML(Kamera)
	});
}
})(this); // end module
</script>
<script type="text/javascript"> // toolwindow: Info Window
"use strict";
/* Interface
required global data:
	global
required functions:
	ToolWindow
public api:
	showInfoWindow
*/
(function(api) {
// public api
api.showInfoWindow = showInfoWindow;

let infoWindow = { count: 0, };
function showInfoWindow(options) {
	let code = "default";
	if (global.shiftDown) {
		code = options.code;
	}
	if (!infoWindow[code]) {
		infoWindow.count = (infoWindow.count+1)%10;
		infoWindow[code] = new ToolWindow({
			title: options.title, // goes in the title bar,
			//closeButtonText: "x", // ✖ = &#x2716;
			top: 120+infoWindow.count*32,
			left: 120+infoWindow.count*32, // optional: when no top or left are given, this window attempts to center itself
			width: 225, // starting width
			height: 200, // starting height
			minWidth: 100, // don't go thinner than this
			minHeight: 100, // don't go shorter than this
			//placement: "inside,auto",
			//relativeToElement: "#container",
			animated: true,
			content: {
				type: "html",
				value: options.content,
			},
			buttons: [/*{	//  to omit all buttons
				text: 'Dismiss',
				clicked: function() {
					// button click handlers are invoked with the infoWindow as the `this` parameter
					this.hide();
				}
				}, {
				text: 'Refresh',
				clicked: function() {
					// note that we can completely replace the content
					// here and that content.value can be any one of:
					// - string
					// - function producing a string
					// - async function producing a string (ie, promise)
					this.content = {
						type: "html",
						value: '<hr/>This is html<hr/>'
					};
					this.refresh();
				}
			}*/]
		});
	} else {
		infoWindow[code].title = options.title;
		infoWindow[code].content.value = options.content;
		infoWindow[code].fitContent();
	}
	infoWindow[code].show();
}
})(this);
</script>
</aside>

<aside id="exportPopup"> <!-- Export Window -->

<script type="text/javascript"> // toolwindow: Export Window
"use strict";
/* Interface
required standard objects:
	Blob
	Image
	URL
	XMLSerializer
	console
	document
required functions:
	_
	ToolWindow
	msg
public api:
	showExportWindow
*/
(function(api) {
// public api
api.showExportWindow = showExportWindow;

let exportWindow;
function showExportWindow() {
	if (!exportWindow) {
		const content = _('exportWindow',
			`<input type="number" name="exportSize" id="exportSize" value="3000" min="1" autocomplete="off" \/>`,
			`<input type="number" name="jpgQuality" id="jpgQuality" value="92" min="1" max="100" step="1" autocomplete="off" \/>`,
			`href="https:\/\/www.eepforum.de\/gallery\/" target="_blank"`
		);
/*
`<p>Wähle die Größe <input type="number" name="exportSize" id="exportSize" value="3000" min="1" autocomplete="off" \/> und das gewünschte Datenformat:<\/p>
<dl>
<dt>PNG<\/dt>
<dd>Verlustfreie Pixel-Graphik in bestimmter Größe; ideal für Computergraphik<\/dd>
<dt>JPG<\/dt>
<dd>Verlustbehaftetes Pixel-Bild in bestimmter Größe und Qualität; ideal für Fotos.<br>
Qualität (%): <input type="number" name="jpgQuality" id="jpgQuality" value="92" min="1" max="100" step="1" autocomplete="off" \/><br><br>
Nur Bilder in diesem Format können direkt in das <a href="https:\/\/www.eepforum.de\/gallery\/" target="_blank">EEP-Forum<\/a> hochgeladen werden: <i>Die Bilder dürfen die Dateiendungen jpg, jpeg besitzen und sie dürfen maximal 2 MB groß sein. Die minimale Bildgröße beträgt 800×500 Pixel und die maximale Größe beträgt 1920×1080 Pixel.<\/i> Daher wird die Größe der exportieren Graphik nach Möglichkeit auf diese Werte begrenzt.<\/dd>
<dt>SVG<\/dt>
<dd>Beliebig zoombare, verlustfreie Vektor-Graphik; ideal zur Weiterverarbeitung in anderen Programmen<br>
Es wird nur der gewählte Ausschnitt exportiert.<\/dd>
<\/dl>`;
*/

		exportWindow = new ToolWindow({
			title: _('Gleisplan exportieren'),
			//closeButtonText: "x", // ✖ = &#x2716;
			//top: 120+exportWindow,
			//left: 120+exportWindow, // optional: when no top or left are given, this window attempts to center itself
			width: 225, // starting width
			height: 200, // starting height
			minWidth: 100, // don't go thinner than this
			minHeight: 100, // don't go shorter than this
			//placement: "inside,auto",
			//relativeToElement: "#container",
			animated: true,
			content: {
				type: "html",
				value: content,
			},
			buttons: [
				{
					text: "PNG",
					clicked: function() {
						exportGraphic("png");
					}
				}, {
					text: "JPG",
					clicked: function() {
						exportGraphic("jpg");
					}
				}, {
					text: "SVG",
					clicked: function() {
						exportGraphic("svg");
					}
				},
			],
		});
	}
	exportWindow.show();
}

function exportGraphic(fileType) {
	// Get target size of the raster graphic (png/jpg)
	let   exportSize = Number(document.getElementById("exportSize").value);
	const jpgQuality = Number(document.getElementById("jpgQuality").value) / 100;

	// Read svg
	const svg		= document.getElementById("svg");
	const svgSize	= svg.getBoundingClientRect();

	// serialize svg
	let svgString;
	if (fileType === "svg") {
		// Remove hidden elements and not visible parts 

		// Step 1: identify groups outside of current view
		// This has to be done for the original svg, it's not possible for the clone.
/*		
console.log("\tid\tinBox\tx\ty\twidth\theigth\ttop\tbottom\tleft\tright");
console.log("svgSize\t\t\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s", 
	svgSize.x.toFixed(2),   svgSize.y.toFixed(2),      svgSize.width.toFixed(2), svgSize.height.toFixed(2), 
	svgSize.top.toFixed(2), svgSize.bottom.toFixed(2), svgSize.left.toFixed(2),  svgSize.right.toFixed(2)
);
*/
		for (const element of svg.querySelectorAll("g")) {
			const boundingRect = element.getBoundingClientRect();
			const inBox = 
					boundingRect.top	<= svgSize.bottom
				&&	boundingRect.bottom	>= svgSize.top
				&& 	boundingRect.left	<= svgSize.right
				&&	boundingRect.right	>= svgSize.left
				;
			if (inBox) {
				element.classList.remove("hiddenSVG");
			} else {
				element.classList.add("hiddenSVG");
			}
/*			
console.log("group\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s", 
	element.id,
	inBox,
	boundingRect.x.toFixed(2),   boundingRect.y.toFixed(2),      boundingRect.width.toFixed(2), boundingRect.height.toFixed(2), 
	boundingRect.top.toFixed(2), boundingRect.bottom.toFixed(2), boundingRect.left.toFixed(2),  boundingRect.right.toFixed(2)
);
*/
		}
		
		// Step 2: clone svg element
		const svgClone = svg.cloneNode(true);
		
		// Firefox requires explicit sizes for XMLSerializer
		svgClone.setAttribute("width", svgSize.width);
		svgClone.setAttribute("height", svgSize.height);

		// EEPweb likes to get a viewBox as well
		svgClone.setAttribute("viewBox", '0' + ' ' + '0' + ' ' + svgSize.width + ' ' + svgSize.height);

		// Step 3: remove hidden elements according to class "hidden"
		//for (const element of svgClone.getElementsByClassName("hidden")) {	// this finds exact matches only
		for (const element of svgClone.querySelectorAll(".hidden, .hiddenZ, .hiddenSVG")) {	// this finds all matches
			element.remove();
		}
		
		// Step 4: serialize svg
		svgString	= new XMLSerializer().serializeToString(svgClone);

		// Step 5: reduce precission (only partly required because mostly done in svgAppend)
		svgString = svgString.replace(/(\.\d{0,5})\d*/g, "$1");
		
	} else {
		// serialize svg
		svg.setAttribute("width", svgSize.width);		// Firefox requires explicit sizes for XMLSerializer ..
		svg.setAttribute("height", svgSize.height);
		svgString	= new XMLSerializer().serializeToString(svg);
		svg.removeAttribute("width");					// .. but SvgPanZoom manages the size by itself, therefore we have to remove the size again
		svg.removeAttribute("height");
	} 	

	// Create object url
	const svgType = "image/svg+xml;charset=utf-8";
	const svgBlob = new Blob([svgString], {type: svgType});
	const url = URL.createObjectURL(svgBlob);

	if (fileType === "svg") {
		// Export svg
		exportData(url, fileType);
		return;
	}

	// Convert svg to png/jpg and export it

	// Create canvas
	const canvas = document.createElement("canvas");

	// Set size of canvas
	const ratio = svgSize.width / svgSize.height;

	if (ratio > 1) {
		if (fileType === "jpg") {
			// Das EEP Forum erfordert Bilder mit Breite zwischen 800 und 1920 
			exportSize 	= Math.max(800, Math.min(1920, exportSize));
			// Das EEP Forum erfordert Bilder mit Höhe zwischen 500 und 1080 
			if (exportSize / ratio < 500) {
				exportSize = 500 * ratio;
			}
			if (exportSize / ratio > 1080) {
				exportSize = 1080 * ratio;
			}
		}
		canvas.width 	= exportSize;
		canvas.height 	= exportSize / ratio;
	} else { // ratio < 1
		if (fileType === "jpg") {
			// Das EEP Forum erfordert Bilder mit Höhe zwischen 500 und 1080 
			exportSize 	= Math.max(500, Math.min(1080, exportSize));
			// Das EEP Forum erfordert Bilder mit Breite zwischen 800 und 1920 
			if (exportSize * ratio < 800) {
				exportSize = 800 / ratio
			}
			if (exportSize * ratio > 1920) {
				exportSize = 1920 / ratio
			}
		}
		canvas.width 	= exportSize * ratio;
		canvas.height 	= exportSize;
	}

	const ctx = canvas.getContext("2d");

	// Create image from object url
	const img = new Image();
	img.onload = function() {
		// Paint image into canvas
		ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

		// Remove temporary data
		URL.revokeObjectURL(url);

		// Convert canvas to png/jpg
		// Firefox might raise exception NS_ERROR_FAILURE
		let mimeType;
		if 		(fileType === "png") { mimeType = "image/png"; }
		else if (fileType === "jpg") { mimeType = "image/jpeg"; }
		else {
			msg('Dateityp nicht unterstützt', fileType);
			return false;
		}

		let DataURL;
		try{
			const encoderOptions = jpgQuality; // jpg quality (default 0.92)
			DataURL = canvas.toDataURL(mimeType, encoderOptions);
		} catch(err){
			console.log(err);
			msg('Zu groß, Export nicht möglich', " (toDataURL()): " + mimeType);
			return false;
		}
		// We might get a very short result which is another type of error
		if ( DataURL.length <= 6 ) {
			msg('Zu groß, Export nicht möglich', " (DataURL.length): " + mimeType)
			return false;
		}

		const rc = exportData(DataURL, fileType);
		msg('Graphik-Export', fileType, `${canvas.width}x${canvas.height}`);
		return rc;
	};
	// Load img
	img.src = url;
}

function exportData(dataURL, fileType) {
	// Get file name without extension
	const filename = document.getElementById("filename").textContent;

	// Create download link and click it
	const link = document.createElement("a");
	link.setAttribute("href", dataURL);
	link.setAttribute("download", filename + "." + fileType);
	//link.setAttribute("target", "_blank"); // not required
	link.style.display = "none";
	document.body.appendChild(link); // Required for Firefox(?)
	// Download
	try{
		link.click(); // We might get a network error in case of very huge results (but it's not possible to catch the error)
	} catch(err){
		console.log(err);
		msg('Zu groß, Export nicht möglich', " (link.click)");
		document.body.removeChild(link);
		URL.revokeObjectURL(dataURL);
		return false;
	}
	// Remove temporary data
	document.body.removeChild(link);
	URL.revokeObjectURL(dataURL);
	return true;
}
})(this); // end module
</script>
</aside>

<aside id="colorPopup"> <!-- Color Picker Window -->
<script type="text/javascript"> // colorPicker
"use strict";
/* Interface
required standard objects:
	document
	localStorage
required functions:
	_
	ToolWindow
public api:
	loadColors
	showColorPickerWindow
*/
(function(api) {
// public api
api.loadColors = loadColors;
api.showColorPickerWindow = showColorPickerWindow;

const GleissystemFarbDefinition = [{
	name: "Eisenbahn",
	color: "#FF0000"	/* red; */
}, {
	name: "Strassenbahn",
	color: "#A9A9A9"	/* darkgray; */
}, {
	name: "Strasse",
	color: "#808080"	/* grey; */
}, {
	name: "Wasserwege",
	color: "#0000FF"	/* blue; */
}, {
	name: "Steuerstrecken",
	color: "#800080"	/* purple; */
}, {
	name: "GBS",
	color: "#A52A2A"	/* brown; */
}, {
	name: "Kamera",
	color: "#00FF00"	/* green; */
}, {
	name: "Hintergrund",
	color: "#FFFFFF"	/* white; */
}];
let GleissystemFarbe;

function loadColors() {
	GleissystemFarbe = JSON.parse(localStorage.getItem("GleissystemFarbe"));

	if (GleissystemFarbe) {
		setColors();
	} else {
		resetColors();
	}
}

function resetColors() {
	// reset color values
	GleissystemFarbe = {};
	GleissystemFarbDefinition.forEach(function(farbe) {
		GleissystemFarbe[farbe.name] = farbe.color;
	});

	// set SVG CSS variables
	setColors();

	// purge local storage
	localStorage.removeItem("GleissystemFarbe");
}

function setColors() {
	// set SVG CSS variables
	const colorVariables = GleissystemFarbDefinition.map(function(farbe) {
		return `--${farbe.name}-color: ${GleissystemFarbe[farbe.name] || farbe.color};`;
	}).join("");
	document.getElementById("css-track-colors").textContent = `svg { ${colorVariables} }`;

	// Update color in storage
	localStorage.setItem("GleissystemFarbe", JSON.stringify(GleissystemFarbe));
}

let colorPickerWindow;

function showColorPickerWindow() {
	if (!colorPickerWindow) {
		const content = GleissystemFarbDefinition.map(function(farbe) {
			return `<div><label><input type="color" class="colorPicker" id="colorPicker-${farbe.name}" name="${farbe.name}">&nbsp;${_(farbe.name)}<\/label><\/div><br>`;
		}).join("");

		colorPickerWindow = new ToolWindow({
			title: _('Farben wählen'),
			//closeButtonText: "x", // ✖ = &#x2716;
			//top: 120,
			//left: 120, // optional: when no top or left are given, this window attempts to center itself
			width: 225, // starting width
			height: 200, // starting height
			minWidth: 100, // don't go thinner than this
			minHeight: 100, // don't go shorter than this
			//placement: "inside,auto",
			//relativeToElement: "#container",
			animated: true,
			content: {
				type: "html",
				value: content,
			},
			buttons: [
				{
					text: _('Reset'),
					clicked: function() {
						resetColors();
						this.hide();
					},
				},
			],
		});
	}
	colorPickerWindow.show();

	GleissystemFarbDefinition.forEach(function(farbe) {
		const colorPicker = document.getElementById("colorPicker-" +  farbe.name);
		colorPicker.value = GleissystemFarbe[farbe.name] || farbe.color;
		// Add event handlers again (because the popup)
		colorPicker.addEventListener("input", setColor);
	});
} // end function showColorPickerWindow

function setColor(event) {
	const name 	= event.target.name;
	const color = event.target.value;

	GleissystemFarbe[name] = color;
	setColors();
}
})(this); // end module
</script>
</aside>

<script type="text/javascript" src="js/blockControl.js"></script> <!-- Create data for Lua module "blockControl" -->

<style id="modCSS"> /* mod default CSS */
/* Instead of inserting CSS modifications here, you can use the bookmark trick described at http://mcdlr.com/css-inject/

Example with 3 modification rules:
1. remove marker of .Prellbock
2. show .inactive track like other tracks
3. highlight specific track type .Helix after reducing the visibility of all track types .EEPCurve, .Line, .Arc, .Rotator, .Cubic, .Clothoid, .Helix
Title: EEP Helix
Code (6 lines):
javascript:(function(){document.getElementById(%27modCSS%27).textContent=%27
.Prellbock { marker-end: none}
.inactive { stroke-opacity: 1.0}
.EEPCurve, .Line, .Arc, .Rotator, .Cubic, .Clothoid, .Helix { stroke-width: calc(var(--normal-stroke-width)/2); stroke-opacity: 0.2; }
.Helix { stroke-width: calc(var(--normal-stroke-width)*2); stroke-opacity: 1.0; }
%27;})();

Example to reset modifications:
Title: 	EEP Reset
Code:	javascript:(function(){document.getElementById(%27modCSS%27).textContent=%27%27;})();

Example to filter out some track styles:
Title: 	EEP Hide by style
javascript:(function(){document.getElementById(%27modCSS%27).textContent=%27
.stil-1520, .stil-5161, .stil-5076, .stil-731
{display: none;}
%27;})();

*/
</style>

</main> <!-- Main screen -->

</body>
</html>