<!DOCTYPE html>
<html lang="de">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Interaktive Anzeige des Gleisplans zu einer EEP-Anlage-Datei (.anl)</title>
<meta name="description" content="Dieses Programm nutzt die Javascript-Funktion DOMParser um eine .anl-Datei von EEP, die aus XML aufgebaut ist, zu interpretieren und in das Document Object Model (DOM) umzuwandeln. Anschließend wird dynamisch mit Javascript die Graphik des Gleisplanes mit SVG-Befehlen aufgebaut. Die Formatierung der graphischen Elemente erfolgt getrennt von der Definition der Graphik mit der SVG-Variante von CSS. Der Browser kann solche SVG-Graphiken direkt anzeigen. Zusätzlich wird die Bibliothek svg-pan-zoom verwendet, um interaktive Funktionen zum Verschieben und Zoomen anzubieten.">
<meta name="author" content="Frank Buchholz">
<meta name="keywords" content="EEP,.anl3,Gleisplan" />
<meta name="language" content="de" />

<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
<script> // Load and process file

const global = {}; // Collection of all global valriables

function loadFile(file) {
	var fr;
	if (typeof window.FileReader !== 'function') {
		bodyAppend("p", "The file API isn't supported on this browser yet.");
		return;
	}

	if (!file) {
		bodyAppend("p", "Please select a file before clicking 'Load'");
	}
	else {
		fr = new FileReader();
		fr.onload = processFile;
		fr.readAsText(file);
// console.log(fr.result);
	}

	// process file (local function to get access to local variable fr)
	function processFile() {
		updateUi(function() {
			// Hide file selector
			document.getElementById('fileselector').classList.add('hidden');

			// Show loading
			document.getElementById('loading').classList.remove('hidden');
		}).then(function() {
			// Create parser
			var parser = new DOMParser();
			// Parse xml into DOM
			var xmlDoc = parser.parseFromString(fr.result, "text/xml");
			fr.result = null; // we do not need this data anymore

			return xmlDoc;
		}).then(function(xmlDoc) {
			let progress = document.getElementById('progress');

			// Process root node (documentElement always represents the root node)
			const sutrackp = xmlDoc.documentElement;
			global.sutrackp = sutrackp;
			return svgCreate(sutrackp, initProgress, incrementProgress);

			function initProgress(progressMax) {
				return updateUi(function() {
					progress.max = progressMax;
					progress.value = 0;
					progress.classList.remove('hidden');
				});
			}
			function incrementProgress() {
				return updateUi(function() {
					progress.value++;
				});
			}
		}).then(function(usedArea) {
			// Hide loading
			document.getElementById('loading').classList.add('hidden');

			// Show main area
			document.getElementById('controls').classList.remove('hidden');
			document.getElementById('container').classList.remove('hidden');
			// Show file name
			document.getElementById('filename').textContent = file.name.substring(0, file.name.length -1 -1 -3);

			// Activate Pan and Zoom
			SvgPanZoom(usedArea);
		});
	}

}

// helper method which waits some time to let the browser update the ui
function updateUi(fn) {
	return new Promise(function(resolve) {
		requestAnimationFrame(function() {
			const result = fn();
			requestAnimationFrame(function() {
				resolve(result);
			});
		})
	});
}
</script>

<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
<script> // DOM2SVG

// Process root node (sutrackp)
// EEP: Static texts
const GleissystemText = { 			// GleissystemID
	1 : 'Eisenbahn',
	2 : 'Strassenbahn',
	3 : 'Strasse',
	4 : 'Wasserwege',
	5 : 'Steuerstrecken',			// nicht in EEP 9
	6 : 'GBS',						// nicht in EEP 9
};

function svgCreate(sutrackp, initProgress, incrementProgress) {

	const Gleisart = { 					// clsid
		'2E25C8E2-ADCD-469A-942E-7484556FF932' : 'Normal',
		'C889EADB-63B5-44A2-AAB9-457424CFF15F' : 'Weiche',
		'B0818DD8-5DFD-409F-8022-993FD3C90759' : '3-Weg-Weiche',
		'06D80C90-4E4B-469B-BFE0-509A573EBC99' : 'Prellbock',
	};

	/* Gleisstile:
	http://up.picr.de/33875489iu.pdf
	http://bahn.hersacher.de/splinekatalog/spkat_intro.htm
	*/
	const unsichtbar = [			// unsichtbare Gleisstile
		17, 						// Wasser, Steuerstrecke
		28, 34, 562, 1346, 5100,	// Gleis
		35, 						// Strassenbahn
		36, 						// Strasse
		5145, 5146, 5147,			// Farm track
		5602,						// Fence
		100000,						// Kamerafahrweg
	]

	const Version 		= sutrackp.getElementsByTagName('Version')[0];
	const EEPversion 	= Version.getAttribute('EEP');	
	if (EEPversion >= 16) {
		bodyAppend('p',
			`Die Anlagedatei aus EEP Version ${EEPversion} wird von den Programmen EEP_Gleisplan und EEP_Inventar noch nicht unterstützt.
			`
		);	
		return;
	}
	
	const Schandlaft 	= sutrackp.getElementsByTagName('Schandlaft')[0];

	// Groesse der Anlage (alle Positionsangaben in m statt cm)
	const Area = {
		min : {
			x : Schandlaft.getAttribute('posX') / 100,
			y : Schandlaft.getAttribute('posY') / 100,
		},
		width  	: Math.abs(Schandlaft.getAttribute('posX') * 2 / 100),
		height 	: Math.abs(Schandlaft.getAttribute('posY') * 2 / 100),
	};

	// Verwendeter Bereich der Anlage
	let usedArea = {
		min : {x : 0, y : 0, z : 0},
		max : {x : 0, y : 0, z : 0},
	};

	// Maps for direct access (Preparation to separate analysis of the file from creating the output.)
	// Verwendung z.B.: Gleis = GleissystemMap.get(GleissystemID).get(GleisID))
	global.GleissystemMap = new Map();

	// Append new svg elements to this root node which we apend to the svg node later
	let fragment = document.createDocumentFragment();

	// Preparation: Collect "active" tracks 
	const activeTracks = [];		// Gleise, auf denen Züge stehen oder die Kontakte bzw. Signale enthalten
									// oder die mit solchen Gleisen verbunden sind
	const trackConnections = [];	// Gleisverbindungen

	const Gleissysteme 	= sutrackp.getElementsByTagName('Gleissystem');
	for (const Gleissystem of Gleissysteme) {

		// Use attribute TrackSystemNumber instead of GleissystemID if available
		let GleissystemID 	= Gleissystem.getAttribute('TrackSystemNumber');
		if (!GleissystemID) {
			GleissystemID 	= Gleissystem.getAttribute('GleissystemID');
		}
		global.GleissystemMap.set(GleissystemID, new Map());
		activeTracks[GleissystemID] = [];

		const Gleise 			= Gleissystem.getElementsByTagName('Gleis');
		for (const Gleis of Gleise) {
			const GleisID 	= Gleis.getAttribute('GleisID');
			global.GleissystemMap.get(GleissystemID).set(GleisID, Gleis);
			
			// Signale
			for (const Meldung of Gleis.getElementsByTagName('Meldung')) {
				// A track having a Signal is an "active" track
				if (!activeTracks[GleissystemID].includes(GleisID)) {
					 activeTracks[GleissystemID].push(GleisID);
				}
			}

			// Kontakte
			for (const Kontakt of Gleis.getElementsByTagName('Kontakt')) {
				// A track having a Kontakt is an "active" track
				if (!activeTracks[GleissystemID].includes(GleisID)) {
					 activeTracks[GleissystemID].push(GleisID);
				}
			}
		} // Gleise

		// Gleisverbindungen 
		trackConnections[GleissystemID] = [];
		const Gleisverbindungen = Gleissystem.getElementsByTagName('Gleisverbindung');
		for (const Gleisverbindung of Gleisverbindungen) {
			// <Gleisverbindung GleisID1="1" Anschluss1="Anfang" GleisID2="5" Anschluss2="Anfang"/>
			const GleisID1 		= Gleisverbindung.getAttribute('GleisID1');
			const GleisID2 		= Gleisverbindung.getAttribute('GleisID2');

			// Store relation GleisID1 -> GleisID2
			if (!trackConnections[GleissystemID][GleisID1]) {
				 trackConnections[GleissystemID][GleisID1] = [];
			}
			trackConnections[GleissystemID][GleisID1].push(GleisID2);

			// Store relation GleisID2 -> GleisID1
			if (!trackConnections[GleissystemID][GleisID2]) {
				 trackConnections[GleissystemID][GleisID2] = [];
			}
			trackConnections[GleissystemID][GleisID2].push(GleisID1);
		}
	}

	// Analyse Fuhrpark to identify "active" tracks
	global.Fuhrpark = sutrackp.getElementsByTagName('Fuhrpark')[0];
	for (const Zugverband of global.Fuhrpark.getElementsByTagName('Zugverband')) {
		// <Gleisort gleissystemID="3" gleisID="41" parameter="1177.944" ausrichtung="0"/>
		const Gleisort		= Zugverband.getElementsByTagName('Gleisort')[0];
		const GleissystemID	= Gleisort.getAttribute('gleissystemID');
		const GleisID		= Gleisort.getAttribute('gleisID');

		// A track with a Zugverband is an "active" track
		if (!activeTracks[GleissystemID].includes(GleisID)) {
			 activeTracks[GleissystemID].push(GleisID);
		}
	}

	// Add connected tracks as "active" tracks because they can be reached by trains as well 
	for (const GleissystemID in activeTracks) {
		const usedGleiseArray = activeTracks[GleissystemID];
		
		// Extend "active" tracks
		for (let i = 0; i < usedGleiseArray.length; i++){ // old-fashioned for statement because we need to extend the array within the loop
			const GleisID1 = usedGleiseArray[i];

			// Get connected tracks of "active" tracks
			const connectedTracks = trackConnections[GleissystemID][GleisID1]
			if (!connectedTracks) { continue; }
			for (const GleisID2 of connectedTracks) {
				// Add new connected tracks
				// These tracks will be processed, too
				if (!activeTracks[GleissystemID].includes(GleisID2)) {
					 activeTracks[GleissystemID].push(GleisID2);
				}
			}
		}
		
	}
	// Now we are able to mark all "active" tracks in the svg-output
	global.activeTracks = activeTracks;

	return initProgress(Gleissysteme.length).then(function() {
		let promise = null;
		for (const Gleissystem of Gleissysteme) {
			if (promise == null) {
				promise = process(Gleissystem);
			} else {
				promise = promise.then(function() { return process(Gleissystem); });
			}
		}
		return promise;

		function process(Gleissystem) {
			//console.log(Gleissystem)

			// Use attribute TrackSystemNumber instead of GleissystemID if available
			let GleissystemID 	= Gleissystem.getAttribute('TrackSystemNumber');
			if (!GleissystemID) {
				GleissystemID 	= Gleissystem.getAttribute('GleissystemID');
			}

			// Append groups to the root node; append other elements to these group nodes
<<<<<<< Updated upstream
			let svg_group_node = svgAppend(fragment, {
				svg_tag	: `g`,
				id		: `${GleissystemText[GleissystemID]}`,
			});
			//console.log(svg_group_node)
=======
			const svgGleissystemGroup = svgAppend(fragment, {
				svg_tag	: `g`,
				id		: `${GleissystemText[GleissystemID]}`,
			});
			//console.log(svgGleissystemGroup)
>>>>>>> Stashed changes

			const Gleise 			= Gleissystem.getElementsByTagName('Gleis');

			// Zeige die Checkbox zum ein-/ausblenden (und andere Elemente) nur dann an, wenn ein Gleissystem auch Gleise enthält
			if (Gleise.length > 0) {
				for (const ele of document.getElementsByClassName(GleissystemText[GleissystemID])) {
					ele.classList.remove('hidden');
				}
			}

			for (const Gleis of Gleise) {
			//console.log(Gleis)

			/* Example:
			<Gleis GleisID="1" clsid="2E25C8E2-ADCD-469A-942E-7484556FF932" data="0" scale="1" ElectSideS="0" ElectSideE="0" stil="1353" gsbname="\Gleisstile\Gleise\Beton2_Sch_C_LW1.3dm" LockEd="0">
				<Dreibein>
					<Vektor x="-12359.88" y="-1854.389" z="30">Pos</Vektor>
					<Vektor x="0.699066" y="-0.715057" z="0">Dir</Vektor>
					<Vektor x="0.715057" y="0.699066" z="0">Nor</Vektor>
					<Vektor x="-0" y="0" z="1">Bin</Vektor>
				</Dreibein>
				<Anfangsfuehrungsverdrehung Wert="0"/>
				<Charakteristik Kruemmung="0" Torsion="0" Fuehrungsverdrehung="-0" Kurve="0" Laenge="2580"/>
			</Gleis>
			*/

			/*
			Das Kordinatensystem von SVG ist gegenüber dem üblichen Koordinatensystem (also auch dem von EEP) an der x-Achse gespiegelt.
			Die Spiegelung ließe sich über CSS einfach zurücknehmen:
			svg { transform: scale(1,-1); }
			Damit würde allerdings auch der Text gespiegelt und müsste daher erneut gespiegelt und verschoben werden.
			Daher werden hier stattdessten alle y-Koordinaten und y-Winkel negativ angegeben (also z.Z. -PosY -DirY -NorY)
			Statt cm soll als Einheit m verwendet werden, daher wird Laenge, Kruemmung, PosX und PosY geeignet skaliert.
			*/

				const GleisID 	= Gleis.getAttribute('GleisID');
				const clsid 	= Gleis.getAttribute('clsid');		// Gleisart
				const stil 		= Gleis.getAttribute('stil');		// Gleisstil
				const gsbname 	= Gleis.getAttribute('gsbname');	// Dateiname
				const Key_Id	= Gleis.getAttribute('Key_Id'); 	// Id einer Weiche
				const GleisData	= Gleis.getAttribute('data'); 		// Bitfeld einer Weiche 
																	// 1: Oberleitung
																	// 18: DKW (Weichen und zentrale Gleise)
																	// 16: Zentrale Strecken einer Straßen-T-Kreuzung
																	// 20: Weichen einer Straßen-T-Kreuzung

				const Laenge	= Gleis.getElementsByTagName('Charakteristik')[0].getAttribute('Laenge') / 100;
				const Kruemmung	= Gleis.getElementsByTagName('Charakteristik')[0].getAttribute('Kruemmung') * 100;
				const PosX		= Gleis.getElementsByTagName('Dreibein')[0].getElementsByTagName('Vektor')[0].getAttribute('x') / 100;
				const PosY		= -Gleis.getElementsByTagName('Dreibein')[0].getElementsByTagName('Vektor')[0].getAttribute('y') / 100;
				const PosZ		= Gleis.getElementsByTagName('Dreibein')[0].getElementsByTagName('Vektor')[0].getAttribute('z') / 100;
				const DirX		= Gleis.getElementsByTagName('Dreibein')[0].getElementsByTagName('Vektor')[1].getAttribute('x');
				const DirY		= -Gleis.getElementsByTagName('Dreibein')[0].getElementsByTagName('Vektor')[1].getAttribute('y');
				const NorX		= Gleis.getElementsByTagName('Dreibein')[0].getElementsByTagName('Vektor')[2].getAttribute('x');
				const NorY		= -Gleis.getElementsByTagName('Dreibein')[0].getElementsByTagName('Vektor')[2].getAttribute('y');

				// Verwendeten Bereich der Anlage anpassen (mit zusätzlichen Platz in der Ebene für die Position der Endpunkte)
				usedArea.min.x = Math.min( usedArea.min.x, PosX - Laenge );
				usedArea.min.y = Math.min( usedArea.min.y, PosY - Laenge );
				usedArea.min.z = Math.min( usedArea.min.z, PosZ );

				usedArea.max.x = Math.max( usedArea.max.x, PosX + Laenge );
				usedArea.max.y = Math.max( usedArea.max.y, PosY + Laenge );
				usedArea.max.z = Math.max( usedArea.max.z, PosZ );

<<<<<<< Updated upstream
				let pathElement;
=======
				// Group node for Gleis
				const svgGleisGroup = svgAppend(svgGleissystemGroup, {
					svg_tag	: `g`,
					id		: `G${GleissystemID}-${GleisID}`,
					class	: Gleisart[clsid] + 
								' ' + (global.activeTracks[GleissystemID].includes(GleisID) ? 'active' : 'inactive') + 
								(unsichtbar.includes(parseInt(stil) && GleisData != 16) ? ' ' + 'unsichtbar' : ''),
				});

>>>>>>> Stashed changes
				let Winkel, DeltaX, DeltaY;
				if (Kruemmung == '0') {
			/*
			SVG: Gerades Gleis

			Alternativen (line erlaubt allerdings kein text-path, daher wird path verwendet)
			a) <line x1="0" y1="0" x2="Laenge" y2="0" transform="translate(PosX PosY) matrix(DirX DirY NorX NorY 0 0)"/>
			b) <line x1="0" y1="0" x2="Laenge" y2="0" transform="matrix(DirX DirY NorX NorY PosX PosY)"/>
			b) <path d="M 0 0 H Laenge" transform="matrix(DirX DirY NorX NorY PosX PosY)"/>
			*/
					Winkel 			= 0;
					DeltaX			= Laenge;
					DeltaY			= 0; 

<<<<<<< Updated upstream
					pathElement = svgAppend(svg_group_node, {
						svg_tag		: `path`,
						id			: `G${GleissystemID}-${GleisID}`,
						class		: `stil-${stil} ${Gleisart[clsid]}
										${global.activeTracks[GleissystemID].includes(GleisID) ? ' active' : ' inactive'}
										${unsichtbar.includes(parseInt(stil)) ? ' unsichtbar' : ''}`,
						d 			: `M 0 0 H ${Laenge}`,
						transform 	: `matrix(${DirX} ${DirY} ${NorX} ${NorY} ${PosX} ${PosY})`
					});


=======
					svgAppend(svgGleisGroup, {
						svg_tag				: `path`,
						class				: `stil-${stil}`,
						d 					: `M 0 0 H ${Laenge}`,
						transform 			: `matrix(${DirX} ${DirY} ${NorX} ${NorY} ${PosX} ${PosY})`
					});

>>>>>>> Stashed changes
				} else { // Kruemmung != 0
			/*
			SVG: Gebogenes Gleis

			Winkel (rad) = Kruemmung * Laenge
			ArcFlag = 0 für Winkel im Bereich -180° bis +180°, ansonsten 1
			SweepFlag = 1 für Winkel >= 0, 0 für Winkel < 0
			Radius = 1 / Kruemmung
			DeltaX = sin(Winkel) * Radius
			DeltaY = (1-cos(Winkel)) * Radius

			Kreisbogen als Spezialfall eines Ausschnittes einer allgenmeinen Ellipse:
			<path d="M PosX PosY A RadiusX RadiusY RotateX ArcFlag SweepFlag PosEndX PosEndY" />
			PosX = 0			x-Koordinate des Anfangpunktes
			PosY = 0			Y-Koordinate des Anfangpunktes
			RadiusX = Radius	Radius der x-Achse der Ellipse
			RadiusY	= Radius	Radius der y-Achse der Ellipse
			RotateX = 0 		Rotation der x-Achse der Ellipse in Grad (0: keine Rotation)
			ArcFlag = 0			large-arc-flag: kurzer Weg um die Ellipse: 0, langer Weg um die Ellipse: 1
			SweepFlag = ...		Zeichnung entgegen den Uhrzeigersinn: 0, Zeichnung mit dem Uhrzeigersinn: 1
			PosEndX = DeltaX	x-Koordinate des Endpunktes
			PosEndY = DeltaY	Y-Koordinate des Endpunktes

			Dies ergibt folgende vereinfachte Form:
			<path d="M 0 0 A Radius Radius 0 ArcFlag SweepFlag DeltaX DeltaY />
			*/
					Winkel 			= Kruemmung * Laenge;
					const ArcFlag 	= ( Winkel <= Math.PI && Winkel >= -Math.PI ? 0 : 1);
					const SweepFlag = ( Winkel >= 0 ? 1 : 0);
<<<<<<< Updated upstream
					const Radius 	= 1 / Kruemmung;
					DeltaX 	= Math.sin(Winkel) * Radius;
					DeltaY 	= (1 - Math.cos(Winkel)) * Radius;

					pathElement = svgAppend(svg_group_node, {
						svg_tag		: `path`,
						id			: `G${GleissystemID}-${GleisID}`,
						class		: `stil-${stil} 
										${Gleisart[clsid]}
										${global.activeTracks[GleissystemID].includes(GleisID) ? ' active' : ' inactive'}
										${unsichtbar.includes(parseInt(stil)) ? ' unsichtbar' : ''}`,
						d 			: `M 0 0 A ${Radius} ${Radius} 0 ${ArcFlag} ${SweepFlag} ${DeltaX} ${DeltaY}`,
						transform 	: `matrix(${DirX} ${DirY} ${NorX} ${NorY} ${PosX} ${PosY})`
=======
					const Radius	= 1 / Kruemmung;
					DeltaX 			= Math.sin(Winkel) * Radius;
					DeltaY 			= (1 - Math.cos(Winkel)) * Radius;

					svgAppend(svgGleisGroup, {
						svg_tag				: `path`,
						class				: `stil-${stil}`,
						d 					: `M 0 0 A ${Radius} ${Radius} 0 ${ArcFlag} ${SweepFlag} ${DeltaX} ${DeltaY}`,
						transform 			: `matrix(${DirX} ${DirY} ${NorX} ${NorY} ${PosX} ${PosY})`
>>>>>>> Stashed changes
					});

				}

<<<<<<< Updated upstream
				// special text/textPath element to show GleisID in the middle of the track
				svgAppendTextPath(svg_group_node, {
					//svg_tag			: `text`,
					href			: `#G${GleissystemID}-${GleisID}`,
					class			: `	${global.activeTracks[GleissystemID].includes(GleisID) ? ' active' : ' inactive'}
										${unsichtbar.includes(parseInt(stil)) ? ' unsichtbar' : ''}`,
					'text-anchor'	: `middle`,
					text 			: `${GleisID}`
				});

				if (Key_Id) {
					// Show text of Weiche
					svgAppend(svg_group_node, {
						svg_tag		: `text`,
						text		: `W${Key_Id}`,
						class		: `	${global.activeTracks[GleissystemID].includes(GleisID) ? ' active' : ' inactive'}
										${Gleisart[clsid]} Weiche ${unsichtbar.includes(parseInt(stil)) ? ' unsichtbar' : ''}`,
						x			: DeltaX,
						y			: -DeltaY,
						transform 	: `matrix(${DirX} ${DirY} ${NorX} ${NorY} ${PosX} ${PosY}) 
									   rotate(${Winkel*(180/Math.PI)} ${DeltaX} ${DeltaY}) 
									   scale(1 -1)`,
					});
=======
				if (Key_Id) {
					// Show text of Weiche at the end of the track
					let Code = 'W';
					if (GleisData == 18 || GleisData == 19) { Code = 'DWK' };
					if (GleisData == 20 || GleisData == 21) { Code = 'T-W' };
					svgAppend(svgGleisGroup, {
						svg_tag			: `text`,
						id				: `W${Key_Id}`,
						text			: `${Code}${Key_Id}`,
						'dy'			: '1em', 		// Shift text below the track
						class			: `WeicheText`,
						x				: DeltaX,
						y				: -DeltaY,
						transform 		: `matrix(${DirX} ${DirY} ${NorX} ${NorY} ${PosX} ${PosY}) 
										   rotate(${Winkel*(180/Math.PI)} ${DeltaX} ${DeltaY}) 
										   scale(1 -1)`,
					});
				}
					
				// show GleisID in the middle above the track
				if (Kruemmung == '0') {
					Winkel 			= 0;
					DeltaX			= Laenge / 2;
					DeltaY			= 0; 
				} else {
					Winkel 			= Kruemmung * Laenge / 2;
					const Radius	= 1 / Kruemmung;
					DeltaX 			= Math.sin(Winkel) * Radius;
					DeltaY 			= (1 - Math.cos(Winkel)) * Radius;
>>>>>>> Stashed changes
				}
				svgAppend(svgGleisGroup, {
					svg_tag				: `text`,
					text				: `${GleisID}`,
					'dy'				: '-0.1em', 	// Shift text up
					x					: DeltaX,
					y					: -DeltaY,
					transform 			: `matrix(${DirX} ${DirY} ${NorX} ${NorY} ${PosX} ${PosY}) 
										   rotate(${Winkel*(180/Math.PI)} ${DeltaX} ${DeltaY}) 
										   scale(1 -1)`,
				});
				// show Gleisstil in the middle below the track (right-adjusted)
				svgAppend(svgGleisGroup, {
					svg_tag				: `text`,
					text				: `${stil}`,
					'dy'				: '1em', 		// Shift text below the track
					class				: `Stil`,
					x					: DeltaX,
					y					: -DeltaY,
					transform 			: `matrix(${DirX} ${DirY} ${NorX} ${NorY} ${PosX} ${PosY}) 
										   rotate(${Winkel*(180/Math.PI)} ${DeltaX} ${DeltaY}) 
										   scale(1 -1)`,
				});					
				// show Hoehe in the middle below the track (left-adjusted)
				svgAppend(svgGleisGroup, {
					svg_tag				: `text`,
					text				: `[${PosZ.toFixed(2)}m]`,
					'dy'				: '1em', 		// Shift text below the track
					class				: `Hoehe`,
					x					: DeltaX,
					y					: -DeltaY,
					transform 			: `matrix(${DirX} ${DirY} ${NorX} ${NorY} ${PosX} ${PosY}) 
										   rotate(${Winkel*(180/Math.PI)} ${DeltaX} ${DeltaY}) 
										   scale(1 -1)`,
				});					

				// Signale
				// <Meldung Position="3449.492" ParaOderAnti="1" fireOnPara="1" fireOnAnti="0" name="PI5_HP02_Form_oVSig" Key_Id="5" >
				//     <KontaktZiel>6</KontaktZiel>
				//     <Signal stellung="1" wirkungsdistanz="10856.51"/>
				// </Meldung>
				for (const Meldung of Gleis.getElementsByTagName('Meldung')) {
					const SignalID		= Meldung.getAttribute('Key_Id');
					const Position		= Meldung.getAttribute('Position') / 100;
					const Distanz		= Meldung.getElementsByTagName('Signal')[0].getAttribute('wirkungsdistanz') / 100;
					const ParaOderAnti 	= Meldung.getAttribute('ParaOderAnti'); //Gleisrichtung: 0 = Ende -> Anfang, 1 = Anfang -> Ende 

					let Winkel, DeltaX, DeltaY;
					if (Kruemmung == '0') {
						Winkel 			= 0;
						DeltaX			= Position;
						DeltaY			= 0; 
					} else { // Kruemmung != 0
						Winkel 			= Kruemmung * Position;
						const Radius 	= 1 / Kruemmung;
						DeltaX 	= Math.sin(Winkel) * Radius;
						DeltaY 	= (1 - Math.cos(Winkel)) * Radius;
					}

<<<<<<< Updated upstream
					// Show marker for Signal
					svgAppend(svg_group_node, {
						svg_tag		: `circle`,
						id			: `S${SignalID}`,
						class		: `${Gleisart[clsid]} Signal 
										${global.activeTracks[GleissystemID].includes(GleisID) ? ' active' : ' inactive'}
										${unsichtbar.includes(parseInt(stil)) ? ' unsichtbar' : ''}`,
						cx			: DeltaX,
						cy			: DeltaY,
						r			: 1,
						transform 	: `matrix(${DirX} ${DirY} ${NorX} ${NorY} ${PosX} ${PosY})`
=======
					// Group node for Signal
					const svgSignalGroup = svgAppend(svgGleisGroup, {
						svg_tag	: `g`,
						id		: `S${SignalID}`,
						class	: `Signal`,
					});

					// Show circle at Signal
					/*
					svgAppend(svgSignalGroup, {
						svg_tag				: `circle`,
						//class				: `Signal`,
						cx					: DeltaX,
						cy					: DeltaY,
						r					: 3,
						transform 			: `matrix(${DirX} ${DirY} ${NorX} ${NorY} ${PosX} ${PosY})`
>>>>>>> Stashed changes
					});
					*/
					
					// Show symbol for Signal
					svgAppend(svgSignalGroup, {
						svg_tag				: `use`,
						//class				: `Signal`,
						'href'				: `#SymbolSignal`,
						x					: DeltaX,
						y					: -DeltaY,
						transform 			:	  ` matrix(${DirX} ${DirY} ${NorX} ${NorY} ${PosX} ${PosY})`
												+ ` rotate(${ParaOderAnti * 180} ${DeltaX} ${DeltaY})`
												+ ` rotate(${Winkel*(180/Math.PI)} 0 0)`
												+ ` translate(-10 0)` // required to move the origin to the signal position  
												,
					});
	
					// Show text of Signal
<<<<<<< Updated upstream
					svgAppend(svg_group_node, {
						svg_tag		: `text`,
						text		: `S${SignalID}`,
						class		: `${Gleisart[clsid]} Signal 
										${global.activeTracks[GleissystemID].includes(GleisID) ? ' active' : ' inactive'}
										${unsichtbar.includes(parseInt(stil)) ? ' unsichtbar' : ''}`,
						x			: DeltaX,
						y			: -DeltaY,
						transform 	: `matrix(${DirX} ${DirY} ${NorX} ${NorY} ${PosX} ${PosY}) 
									   rotate(${Winkel*(180/Math.PI)} ${DeltaX} ${DeltaY}) 
									   scale(1 -1)`,
=======
					svgAppend(svgSignalGroup, {
						svg_tag				: `text`,
						text				: `S${SignalID} ${Distanz.toFixed(0)}m`,
						//'dy'				: `${(ParaOderAnti == 0 ? '-2.3' : '1.3em')}`, 	// Shift text if not rotated to the side of the symbol
						'dy'				: `-2.3`, 										// Shift text if rotated to the side of the symbol
						class				: `Signal`,
						x					: DeltaX,
						y					: -DeltaY,
						transform 			: `matrix(${DirX} ${DirY} ${NorX} ${NorY} ${PosX} ${PosY})`
												+ ` rotate(${ParaOderAnti * 180} ${DeltaX} ${DeltaY})`	// Rotate text to the side of the symbol
												+ ` rotate(${Winkel*(180/Math.PI)} ${DeltaX} ${DeltaY})`
												+ ` scale(1 -1)`,
>>>>>>> Stashed changes
					});
 
				} // Signale

				// Kontakte
				for (const Kontakt of Gleis.getElementsByTagName('Kontakt')) {
					const Position		= Kontakt.getAttribute('Position') / 100;
					const ParaOderAnti 	= Kontakt.getAttribute('ParaOderAnti'); // Gleisrichtung 1: 0 = Ende -> Anfang, 1 = Anfang -> Ende  
					const fireOnPara  	= Kontakt.getAttribute('fireOnPara'); 	// Kontakt aktiv für Gleisrichtung 1
					const fireOnAnti  	= Kontakt.getAttribute('fireOnAnti'); 	// Kontakt aktiv für Gleisrichtung 2
					
					let Winkel, DeltaX, DeltaY;
					if (Kruemmung == '0') {
						Winkel 			= 0;
						DeltaX			= Position;
						DeltaY			= 0; 
					} else { // Kruemmung != 0
						Winkel 			= Kruemmung * Position;
						const Radius 	= 1 / Kruemmung;
						DeltaX 	= Math.sin(Winkel) * Radius;
						DeltaY 	= (1 - Math.cos(Winkel)) * Radius;
					}

<<<<<<< Updated upstream
					// Show marker for Kontakt
					svgAppend(svg_group_node, {
						svg_tag		: `rect`,
						class		: `${Gleisart[clsid]} Kontakt 
										${global.activeTracks[GleissystemID].includes(GleisID) ? ' active' : ' inactive'}
										${unsichtbar.includes(parseInt(stil)) ? ' unsichtbar' : ''}`,
						x			: DeltaX,
						y			: DeltaY,
						width		: 0.2,
						height		: 1,
						transform 	: `matrix(${DirX} ${DirY} ${NorX} ${NorY} ${PosX} ${PosY}) 
									   rotate(${Winkel*(180/Math.PI)} ${DeltaX} ${DeltaY})`
=======
					// Group node for Kontakt
					const svgKontaktGroup = svgAppend(svgGleisGroup, {
						svg_tag	: `g`,
						//id		: `???`,
						class	: `Kontakt`,
>>>>>>> Stashed changes
					});
 
					// Show circle at Kontakt
					/*
					svgAppend(svgKontaktGroup, {
						svg_tag				: `circle`,
						//class				: `Kontakt`,
						cx					: DeltaX,
						cy					: DeltaY,
						r					: 3,
						transform 			: `matrix(${DirX} ${DirY} ${NorX} ${NorY} ${PosX} ${PosY})`
					});
					*/
					
					// Show symbol for Kontakt
					if (fireOnPara == 1) {
						svgAppend(svgKontaktGroup, {
							svg_tag				: `use`,
							//class				: `Kontakt`,
							'href'				: `#SymbolKontakt`,
							x					: DeltaX,
							y					: -DeltaY,
							transform 			:	  ` matrix(${DirX} ${DirY} ${NorX} ${NorY} ${PosX} ${PosY})`
													+ ` rotate(${ParaOderAnti * 180} ${DeltaX} ${DeltaY})`
													+ ` rotate(${Winkel*(180/Math.PI)} 0 0)`
													+ ` translate(-10 0)` // required to move the origin to the signal position  
													,
						});
					}
					if (fireOnAnti == 1) {
						svgAppend(svgKontaktGroup, {
							svg_tag				: `use`,
							//class				: `Kontakt`,
							'href'				: `#SymbolKontakt`,
							x					: DeltaX,
							y					: -DeltaY,
							transform 			:	  ` matrix(${DirX} ${DirY} ${NorX} ${NorY} ${PosX} ${PosY})`
													+ ` rotate(${(1-ParaOderAnti) * 180} ${DeltaX} ${DeltaY})`
													+ ` rotate(${Winkel*(180/Math.PI)} 0 0)`
													+ ` translate(-10 0)` // required to move the origin to the signal position  
													,
						});
					}

				} // Kontakte

			} // Gleise

			return incrementProgress();
		}

	}).then(function() {
	
		// Show min/max height
		const text = (usedArea.min.z).toFixed(0) + ' .. ' + (usedArea.max.z).toFixed(0);
		document.getElementById('height_area').textContent = text;
	
		// Verwendeter Bereich der Anlage anpassen (nicht größer als die Anlage selber)
		usedArea.min.x = Math.max( usedArea.min.x, Area.min.x );
		usedArea.min.y = Math.max( usedArea.min.y, Area.min.y );
		usedArea.max.x = Math.min( usedArea.max.x, Area.min.x + Area.width  );
		usedArea.max.y = Math.min( usedArea.max.y, Area.min.y + Area.height );

		// Group for additional general elements
		let svg_group_node = svgAppend(fragment, {
			svg_tag	: `g`,
			id		: `general`,
		});

		// Box zur Anzeige der Groesse der Anlage
		// <rect class="box" x="-503" y="-303" width="1006" height="606" />
		svgAppend(svg_group_node, {
			svg_tag	: `rect`,
			class	: `box`,
			x		:  Area.min.x,
			y		:  Area.min.y,
			width	:  Area.width,
			height	:  Area.height,
		});
		// Box zur Anzeige des verwendeten Teils der Anlage
		// <rect class="box" x="-175" y="-140" width="382" height="305" />
		svgAppend(svg_group_node, {
			svg_tag	: `rect`,
			class	: `box`,
			x		:  usedArea.min.x,
			y		:  usedArea.min.y,
			width	:  usedArea.max.x - usedArea.min.x,
			height	:  usedArea.max.y - usedArea.min.y,
		});
		// Zusätzliche Markierung des Zentrums
		// <circle id="center" cx="0" cy="0" r="1" />
		svgAppend(svg_group_node, {
			svg_tag	: `circle`,
			id		: `center`,
			cx		:  `0`,
			cy		:  `0`,
			r		:  `1`,
		});

		// Now we can append the fragment to the svg node
		document.getElementById("sutrackp").appendChild(fragment);

		// Test: process all nodes recursivly
		//process_node(sutrackp);

		return usedArea;
	});
}

function process_node(node) {
//console.log(node.nodeName);

	bodyAppend("p", node.nodeName + '|' + node.nodeValue + '|' + node.nodeType);

	// Process child elements
	for(let i=0; i<node.childNodes.length; i++) {
		process_node(node.childNodes[i]);
	}
}

function bodyAppend(tagName, innerHTML) {
	var elm = document.createElement(tagName);
	elm.textContent = innerHTML;
	document.body.appendChild(elm);
}

function svgAppend(svg_node, obj) {
	const svgNS 	= "http://www.w3.org/2000/svg";
	//const xlinkNS	= "http://www.w3.org/1999/xlink";

	let element = document.createElementNS(svgNS, obj.svg_tag);

	// copy all attributes except the tag and the text
	for (const [key, value] of Object.entries(obj)) {
		if (key != 'svg_tag' && key != 'text') { element.setAttribute(key, value); }
	}

	if (obj.svg_tag == 'text') {
		const textNode 	= document.createTextNode(obj.text);
		element.appendChild(textNode);
		element.setAttribute('dy', '1em'); // Shift text below the track
	}

	svg_node.appendChild(element);
	return element;
}

function svgAppendTextPath(svg_node, obj) {
	const svgNS 	= "http://www.w3.org/2000/svg";
	const xlinkNS	= "http://www.w3.org/1999/xlink";

	// Create special element using attributes href, text, text-anchor (optional)
	// Example:
	// <text><textPath startOffset="50%" href="#G1-1">1</textPath></text>

	const textNode 	= document.createTextNode(obj.text);

	const textPath 	= document.createElementNS(svgNS, 'textPath');
	textPath.setAttribute('class', obj.class);
	if (obj['text-anchor'] == 'middle') {
		textPath.setAttribute('startOffset', '50%');
	}
	else if (obj['text-anchor'] == 'end') {
		textPath.setAttribute('startOffset', '90%'); // How to put the text exactly to the end?
	}
	textPath.setAttributeNS(xlinkNS, 'xlink:href', obj.href);
	textPath.appendChild(textNode);

	const text 		= document.createElementNS(svgNS, 'text');
	if (obj['text-anchor']) { text.setAttribute('text-anchor', obj['text-anchor']); }
	text.appendChild(textPath);
	text.setAttribute('dy', '-0.1em'); // Shift text up the track

	svg_node.appendChild(text);

	return text;
}

</script>

<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
<script src="https://ariutta.github.io/svg-pan-zoom/dist/svg-pan-zoom.min.js"></script>
<script> // svg-pan-zoom
// https://github.com/ariutta/svg-pan-zoom
function SvgPanZoom(usedArea) {

	const beforePan = function(oldPan, newPan) {
		msg();
		return; // Zoom-in near the border does not work well if we limt pan with fixed gutter

		// Limit pan to keep SVG content visible by not allowing panning over SVG borders.
		const gutterWidth = 100,
			  gutterHeight = 100;

		const sizes = this.getSizes();
		const leftLimit = -((sizes.viewBox.x + sizes.viewBox.width) * sizes.realZoom) + gutterWidth;
		const rightLimit = sizes.width - gutterWidth - (sizes.viewBox.x * sizes.realZoom);
		const topLimit = -((sizes.viewBox.y + sizes.viewBox.height) * sizes.realZoom) + gutterHeight;
		const bottomLimit = sizes.height - gutterHeight - (sizes.viewBox.y * sizes.realZoom);

		customPan = {};
		customPan.x = Math.max(leftLimit, Math.min(rightLimit,  newPan.x));
		customPan.y = Math.max(topLimit,  Math.min(bottomLimit, newPan.y));

		return customPan;
	};

	const onZoom = function(newZoom) {
		msg();
		show_area(this);
	};

	const onPan = function(newPan) {
		msg();
		show_area(this);
	};

	const panZoom = svgPanZoom('#svg', {
		viewportSelector: '.svg-pan-zoom_viewport' // Viewport selector. Can be querySelector string or SVGElement
		//, panEnabled: true // enable or disable panning (default enabled)
		, controlIconsEnabled: false // insert icons to give user an option in addition to mouse events to control pan/zoom (default disabled)
		// , zoomEnabled: true // enable or disable zooming (default enabled)
		// , dblClickZoomEnabled: true // enable or disable zooming by double clicking (default enabled)
		// , mouseWheelZoomEnabled: true // enable or disable zooming by mouse wheel (default enabled)
		// , preventMouseEventsDefault: true // enable or disable preventDefault for mouse events
		, zoomScaleSensitivity: 0.1 // Zoom sensitivity
		, minZoom: 0.1 // Minimum Zoom level
		, maxZoom: 100 // Maximum Zoom level
		// , fit: true // enable or disable viewport fit in SVG (default true)
		// , contain: false // enable or disable viewport contain the svg (default false)
		// , center: true // enable or disable viewport centering in SVG (default true)
		// , refreshRate: 'auto' // Maximum number of frames per second (altering SVG's viewport)
		// , beforeZoom: function(oldZoom, newZoom){return true;}
		// , onZoom: function(ZoomScale){}
		, onZoom: onZoom
		// , beforePan: function(oldPan, newPan){return customPan} // oldPan.x, oldPan.y, newPan.x, newPan.y
		, beforePan: beforePan
		// , onPan: function(newPan){}
		, onPan: onPan
		// , customEventsHandler: { init : function(options){}, destroy : function(options){} }
		, customEventsHandler: {
			init : function(options) {
				this.listeners = {
					mouseenter: function(ev) {
						show_position(options.instance, ev);
						show_area(options.instance, ev);
					},
					click: function(ev) {
						show_area(options.instance, ev);
						show_element(options.instance, ev);
					},
					mousemove: function(ev) {
						show_position(options.instance, ev);
					},
					mouseleave: function(ev) {
						document.getElementById('cursor_position').textContent = '';
					}
				};
				for (const eventName in this.listeners) {
					options.svgElement.addEventListener(eventName, this.listeners[eventName]);
				}
			},
			destroy: function(options) {
				for (const eventName in this.listeners) {
					options.svgElement.removeEventListener(eventName, this.listeners[eventName]);
				}
			}
		}
		// , eventsListenerElement: SVGElement
		, onUpdatedCTM: null
	});
	global.panZoom = panZoom;

	// Pan and zoom to used area
	showUsedArea(true);

	function showUsedArea(pan) {
		// Pan and zoom to used area
		// zoomAtPoint(scale, {x:0,y:0});   or   pan({x:0,y:0}); zoom(scale);
		const width 		= panZoom.getSizes().width;
		const height		= panZoom.getSizes().height;
		const usedwidth 	= usedArea.max.x - usedArea.min.x;
		const usedheight	= usedArea.max.y - usedArea.min.y;
		const realZoom		= panZoom.getSizes().realZoom;

		const panX 			= width/2  - ( usedArea.min.x + usedwidth/2  ) * realZoom;
		const panY 			= height/2 - ( usedArea.min.y + usedheight/2 ) * realZoom;
		const scale 		= Math.min( width  / usedwidth,
										height / usedheight ) / realZoom;

		if (pan) {
			panZoom.pan({x: panX, y: panY});
		}

		panZoom.zoom(scale);
	}

	// resize SvgPanZoom after resizing the window
	window.addEventListener('resize', function(ev) {
		msg();
		ev.preventDefault();
		// Resize content
		panZoom.resize();
		panZoom.fit();
		panZoom.center();
	});


	// Button swap
	document.getElementById('swap').addEventListener('click', function(ev) {
		msg();
		ev.preventDefault()
		// Toogle between flex-direction: column and flex-direction: row
		document.body.classList.toggle('column');
		document.body.classList.toggle('row');
		// Swapping changes the size of the svg element
		oldSizes = panZoom.getSizes();
		panZoom.resize();
		newSizes = panZoom.getSizes();
		// The top left point keeps its position. We need to pan to keep the center being centered.
		panZoom.panBy({
			x: (newSizes.width - oldSizes.width) 	/ 2 ,
			y: (newSizes.height - oldSizes.height)	/ 2 ,
		});
		show_area(panZoom);
	});

	// Button Zoom-In
	document.getElementById('zoom-in').addEventListener('click', function(ev) {
		msg();
		ev.preventDefault();
		panZoom.zoomIn();
	});
	// Button Zoom-Out
	document.getElementById('zoom-out').addEventListener('click', function(ev) {
		msg();
		ev.preventDefault();
		panZoom.zoomOut();
	});
	// Button Reset
	document.getElementById('reset').addEventListener('click', function(ev) {
		msg();
		ev.preventDefault()
		panZoom.fit();
		panZoom.center();
		panZoom.resetZoom();
		// Pan and zoom to used area
		showUsedArea(true);
	});
	// Button ResetZoom
	document.getElementById('resetzoom').addEventListener('click', function(ev) {
		msg();
		ev.preventDefault();
		panZoom.resetZoom();
		// Zoom to used area
		showUsedArea();
	});
	// Slider strokeWidth
	document.getElementById('strokeWidth').addEventListener('input', function(ev) {
		msg();
		ev.preventDefault();
		changeStrokeWidth(ev.target.value);
	});
	// Button 'enable controls'
/*
	document.getElementById('enable').addEventListener('click', function() {
		msg();
		ev.preventDefault();
		panZoom.enableControlIcons();
	})
*/
	// Button 'disable controls'
/*
	document.getElementById('disable').addEventListener('click', function() {
		msg();
		ev.preventDefault();
		panZoom.disableControlIcons();
	})
*/
	// Button savePNG
	document.getElementById('savePNG').addEventListener('click', function(ev) {
		msg();
		ev.preventDefault();
		savePNG();
	});
	// Button centerItem
	document.getElementById('centerItem').addEventListener('click', function(ev) {
		msg();
		ev.preventDefault();
		centerItem();
	});

	// Show cursor position
	function show_position(t, event) {
		const pan 	= t.getPan();	// (x y)
		const sizes = t.getSizes();	// width height of svg area
									// viewBox (x y width height)
									// realZoom = min(width/viewBox.width, height/viewBox.height)
		//const zoom 	= t.getZoom();	// zoom factor

		const posX	= ( event.offsetX - pan.x) / sizes.realZoom;
		const posY	= ( event.offsetY - pan.y) / sizes.realZoom;

		/* Show cursor position */
		const text = '(' + (posX).toFixed(0) + ' ' + (-posY).toFixed(0) + ')';
		document.getElementById('cursor_position').textContent = text;
	}

	// Show coordinates of visible area
	function show_area(t, event) {
		const pan 		= t.getPan();	// (x y)
		const sizes 	= t.getSizes();	// width height of svg area
									// viewBox (x y width height)
									// realZoom = min(width/viewBox.width, height/viewBox.height)
		const zoom 		= t.getZoom();	// zoom factor

		const minX		= (-pan.x) / sizes.realZoom;
		const minY		= (-pan.y) / sizes.realZoom;
		const centerX	= (-pan.x + sizes.width/2)  / sizes.realZoom;
		const centerY	= (-pan.y + sizes.height/2)	/ sizes.realZoom;
		const maxX		= (-pan.x + sizes.width)  	/ sizes.realZoom;
		const maxY		= (-pan.y + sizes.height) 	/ sizes.realZoom;

		/* Show coordinates of visible area */
		let text = '('  + (minX).toFixed(0) + ' ' + (-minY).toFixed(0) + ') .. ('
						+ (maxX).toFixed(0) + ' ' + (-maxY).toFixed(0) + ')';
		document.getElementById('visible_area').textContent = text;
		/* Show center position */
		text = '(' + (centerX).toFixed(0) + ' ' + (-centerY).toFixed(0) + ')';
		document.getElementById('center_position').textContent = text;
	}

	// Show element
	function show_element(t, event) {
		if (!event || event.target.id == 'svg') { return; };
/*
console.log('');

console.log( 
'target|' +
event.target.tagName + ':' + 
event.target.id + ':' + 
event.target.classList[0]
)
if (event.target.parentElement) {
	console.log( 
	'target.parentElement|' +
	event.target.parentElement.tagName + ':' + 
	event.target.parentElement.id  + ':' +
	event.target.parentElement.classList[0]
	)
}
if (event.rangeParent) {
	console.log( 
	'rangeParent|' +
	event.rangeParent.tagName + ':' + 
	event.rangeParent.id  + ':' +
	event.rangeParent.classList[0]
	)
	if (event.rangeParent.parentElement) {
		console.log( 
		'rangeParent.parentElement|' +
		event.rangeParent.parentElement.tagName + ':' + 
		event.rangeParent.parentElement.id  + ':' +
		event.rangeParent.parentElement.classList[0]
		)
	}
}
*/
/*
Track
target						|path::stil-1353
target.parentElement		|g:G1-3:Weiche
rangeParent					|g:G1-3:Weiche
rangeParent.parentElement	|g:Eisenbahn:undefined

Track text
target						|text::undefined
target.parentElement		|g:G1-51:Normal
rangeParent					|text::undefined
rangeParent.parentElement	|g:G1-51:Normal

Track stil
target|text::Stil
target.parentElement		|g:G1-51:Normal
rangeParent					|text::Stil
rangeParent.parentElement	|g:G1-51:Normal

Track Hoehe
target|text::Hoehe
target.parentElement		|g:G1-51:Normal
rangeParent					|text::Hoehe
rangeParent.parentElement	|g:G1-51:Normal

Weiche text
target						|text:W2:WeicheText
target.parentElement		|g:G1-17:Weiche
rangeParent					|text:W2:WeicheText
rangeParent.parentElement	|g:G1-17:Weiche


Signal text
target						|text::Signal
target.parentElement		|g:S39:Signal
rangeParent					|text::Signal
rangeParent.parentElement	|g:S39:Signal

Signal symbol
target						|use::undefined
target.parentElement		|g:S39:Signal
rangeParent					|symbol:SymbolSignal:undefined

Signal circle
target						|circle::undefined 
target.parentElement		|g:S39:Signal 
rangeParent					|g:S39:Signal 
rangeParent.parentElement	|g:G1-47:Normal


Kontakt symbol
target						|use::undefined
target.parentElement		|g::Kontakt

Kontakt circle
target						|circle::undefined
target.parentElement		|g:G1-47:Normal
rangeParent					|g:G1-47:Normal
rangeParent.parentElement	|g:Eisenbahn:undefined
*/
		
		if (event.target.parentElement.classList[0] == 'Signal') {	// Signal
			const SignalCode = event.target.parentElement.id;
			const SignalID = SignalCode.substring(1)
			msg('Signal ' + SignalID);
			
		} else if (event.target.parentElement.classList[0] == 'Kontakt') {	// Kontakt
			msg('Kontakt');
			
		} else if (event.target.classList[0] == 'WeicheText') { 	// Weiche
			const WeicheCode 	= event.target.id;
			const WeicheID 		= WeicheCode.substring(1)
			msg('Weiche ' + WeicheID);

		} else{ 													// Gleis
			const GleisCode = event.target.parentElement.id;
			const GleisTextArray 	= GleisCode.substring(1).split('-');
			const GleissystemID 	= GleisTextArray[0];
			const GleisID 			= GleisTextArray[1];
			msg(`${GleissystemText[GleissystemID]} ${GleisID}`);
		}

	}
}
</script>

<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
<script> // html page

// Toggle visibility of elements
function toggleElements(selector, visible) {
	msg();
	for (const ele of document.getElementById('svg').querySelectorAll(selector)) {
		if (visible) {
			ele.classList.remove('hidden');
		} else {
			ele.classList.add('hidden');
		}
	}
}

// Toggle visibility of marker
function toggleMarker(visible) {
	msg();
	toggleElements('#center', visible);

	// Modify svg css (nice, but only works in the browser, not during PNG export)
	/*
	const cssVariables = document.getElementById('css-marker-colors').sheet.rules[0].style;
	['Eisenbahn', 'Strassenbahn', 'Strasse', 'Wasserwege', 'Steuerstrecken', 'GBS'].forEach(function(name) {
		if (visible) {
			cssVariables.setProperty(`--${name}-marker-color`, `var(--${name}-color)`);
		} else {
			cssVariables.setProperty(`--${name}-marker-color`, `none`);
		}
	});
	*/
	
	// Modify svg css to use same setting during PNG export
	if (visible) {
		document.getElementById('css-marker-colors').textContent =
			`svg {
				--Eisenbahn-marker-color: var(--Eisenbahn-color);
				--Strassenbahn-marker-color: var(--Strassenbahn-color);
				--Strasse-marker-color: var(--Strasse-color);
				--Wasserwege-marker-color: var(--Wasserwege-color);
				--Steuerstrecken-marker-color: var(--Steuerstrecken-color);
				--GBS-marker-color: var(--GBS-color);
			}`;
	} else {
		document.getElementById('css-marker-colors').textContent =
			`svg {
				--Eisenbahn-marker-color: none;
				--Strassenbahn-marker-color: none;
				--Strasse-marker-color: none;
				--Wasserwege-marker-color: none;
				--Steuerstrecken-marker-color: none;
				--GBS-marker-color: none;
			}`;
	}	
}

// save current svg area to png
function savePNG() {

	// Get file name without extension
	const filename = document.getElementById('filename').textContent;

	// Get target size of the raster graphic (png)
	const sizePNG = Number(document.getElementById('sizePNG').value);

	// Read svg
	const svg 		= document.getElementById('svg');
	const svgSize 	= svg.getBoundingClientRect();	// Firefox requires explicit sizes for XMLSerializer ..
	svg.setAttribute("width", svgSize.width);
	svg.setAttribute("height", svgSize.height);
	const svgString	= new XMLSerializer().serializeToString(svg);
	svg.removeAttribute("width");					// .. but SvgPanZoom manages the size by itself, therefore we have to remove the size again
	svg.removeAttribute("height");
	const svgBlob 	= new Blob([svgString], {type: 'image/svg+xml;charset=utf-8'});

	// Create object url
	const DOMURL = self.URL || self.webkitURL || self;
	const url = DOMURL.createObjectURL(svgBlob);

	// Create canvas
	const canvas = document.createElement('canvas');

	// Set size of canvas
	const ratio = svgSize.width / svgSize.height;
	if (ratio > 1) {
		canvas.width 	= sizePNG;
		canvas.height 	= sizePNG / ratio;
	} else {
		canvas.width 	= sizePNG / ratio;
		canvas.height 	= sizePNG;
	}

	const ctx = canvas.getContext('2d');

	// Create image from object url
	const img = new Image();
	img.onload = function() {
		// Paint image into canvas
		ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

		// Convert canvas to png
		// Firefox might raise exception NS_ERROR_FAILURE
		let png;
		try{
			png = canvas.toDataURL('image/png');
		} catch(err){
			console.log(err);
			msg('Zu groß: PNG-Export nicht möglich (toDataURL)');
			return;
		}
		// We might get a very short result which is another type of error
		if ( png.length <= 6 ) {
			msg('Zu groß, PNG-Export nicht möglich (png.length)')
			return;
		}

		// Create download link and click it
		const link = document.createElement('a');
		link.setAttribute('href', png);
		link.setAttribute('download', filename + '.png');
		link.setAttribute('target', '_blank');
		link.style.display = 'none';
		document.body.appendChild(link);
		// Download
		try{
			link.click(); // We might get a network error in case of very huge results (but it's not possible to catch the error)
		} catch(err){
			console.log(err);
			msg('Zu groß: PNG-Export nicht möglich (link.click)');
			document.body.removeChild(link);
			DOMURL.revokeObjectURL(png);
			return; 
		}
		// Remove temporary data
		document.body.removeChild(link);
		DOMURL.revokeObjectURL(png);
	};
	// Load img
	img.src = url;
}

function centerItem() {

	// Get the element from a set with a specific attribute value
	function getElement(Set, Attribute, ID) {
		for (const Element of Set) {
			if (Element.getAttribute(Attribute) == ID) return Element;
		}
	}

	// Get input values
	const o 	= document.getElementById('select');
	const sel 	= o.options[o.selectedIndex].value;			// e.g. 1-6, W, S, K
	//const text 	= o.options[o.selectedIndex].text;		// e.g. Eisenbahn
	const val 	= Number(document.getElementById('number').value);

	if (sel >= '1' && sel <= '6') { // Gleissystem

		const GleissystemID = Number(sel);
		const GleisID 		= val;
		const Gleissystem	= getElement(global.sutrackp.getElementsByTagName('Gleissystem'), 'GleissystemID', GleissystemID);
		if (!Gleissystem) {
			msg(`Gleissystem ${GleissystemID} existiert nicht`);
			return false;
		}

		const Gleis 		= getElement(Gleissystem.getElementsByTagName('Gleis'), 'GleisID', GleisID);
		if (!Gleis) {
			msg(`${GleissystemText[GleissystemID]} ${GleisID} existiert nicht`);
			return false;
		}

		centerGleis(Gleis);
		msg(`Positionierung auf ${GleissystemText[GleissystemID]} ${GleisID}`);
//console.log(`Gleis ${GleissystemID}-${GleisID} Pos: (${PosX} ${PosY}) Pan: (${panX} ${panY})`)
		return true;

	} else if (sel == 'I') {		// Signal/Weiche (Nummern übergreifend über alle Gleissysteme)
		// Gleis.getAttribute('Key_Id') bzw. Gleis.getAttribute('Meldung').getAttribute('Key_Id')
		const ID 		= val;

		// Suche das Signal bzw. die Weiche auf allen Gleisen
		const Gleissysteme 	= global.sutrackp.getElementsByTagName('Gleissystem');
		for (const Gleissystem of Gleissysteme) {

			const Gleise = Gleissystem.getElementsByTagName('Gleis');
			for (const Gleis of Gleise) {

				const GleissystemID = Gleissystem.getAttribute('GleissystemID');
				const GleisID = Gleis.getAttribute('GleisID');
				const Key_Id	= Gleis.getAttribute('Key_Id'); 	// Id einer Weiche
					if (Key_Id == ID) {
						// Signal gefunden
						centerGleis(Gleis);
						msg(`Die Weiche ${ID} befindet sich auf ${GleissystemText[GleissystemID]} ${GleisID}`);
//console.log(`Gleis ${GleissystemID}-${GleisID} Pos: (${PosX} ${PosY}) Pan: (${panX} ${panY})`)
						return true;
					}

				const Meldungen = Gleis.getElementsByTagName('Meldung');
				for (const Meldung of Meldungen) {

					const Key_Id	= Meldung.getAttribute('Key_Id'); 	// Id eines Signals
					if (Key_Id == ID) {
						// Signal gefunden
						centerGleis(Gleis);
						msg(`Das Signal ${ID} befindet sich auf ${GleissystemText[GleissystemID]} ${GleisID}`);
//console.log(`Gleis ${GleissystemID}-${GleisID} Pos: (${PosX} ${PosY}) Pan: (${panX} ${panY})`)
						return true;
					}

				} // ´Meldungen
			} // Gleise
		} // Gleissysteme
		msg(`Signal/Weiche ${ID} existiert nicht`);
		return false; // Signal nicht gefunden

	} else if (sel == 'K') {		// Kontakt
		//...
	}
	return false;
}

function centerGleis(Gleis) {
	const PosX		= Gleis.getElementsByTagName('Dreibein')[0].getElementsByTagName('Vektor')[0].getAttribute('x') / 100;
	const PosY		= -Gleis.getElementsByTagName('Dreibein')[0].getElementsByTagName('Vektor')[0].getAttribute('y') / 100;

	const width 	= global.panZoom.getSizes().width;
	const height	= global.panZoom.getSizes().height;
	const realZoom	= global.panZoom.getSizes().realZoom;

	const panX 		= width/2	- PosX * realZoom;
	const panY 		= height/2	- PosY * realZoom;

	global.panZoom.pan({x: panX, y: panY});
}

function msg(text) {
	if (text) {
		document.getElementById('message').textContent = text; // Text only therefore we do not need to use innerHTML
	} else {
		document.getElementById('message').textContent = '';
	}
}

function changeStrokeWidth(value) {
	// Use exponential function to convert the slider value into range [0.11 .. 2.12] with f(75) = 1
	// f = 0.1054 * exp(0.03 * v)
	const factor = 0.1054 * Math.exp(0.03 * value);

	// Modify svg css (nice, but only works in the browser, not during PNG export)
	// (we maybe could use calc(4 * var(--font-size-factor, 1) * 1px) as well to avoid the constants here)
	/*
	const cssVariables = document.getElementById('css-size-variables').sheet.rules[0].style;
	cssVariables.setProperty('--normal-font-size', `${4 * factor}px`);
	cssVariables.setProperty('--normal-stroke-width', `${0.5 * factor}px`);
	cssVariables.setProperty('--narrow-stroke-width', `${0.25 * factor}px`);
	*/
	
	// Modify svg css to use same setting during PNG export
	document.getElementById('css-size-variables').textContent =
		`svg {
			--normal-font-size: ${4 * factor}px;
			--normal-stroke-width: ${0.5 * factor}px;
			--narrow-stroke-width: ${0.25 * factor}px;
		}`	
}
</script>

<style> /* html page */

/* margins */

html, body {
	margin: 0;
	padding: 0;
}

#header {
	margin: 5px;
}

/* flex */

body {
	height: 100vh;
}

body.column {
	display: flex;				/* top level flex */
	flex-direction: column; 	/* vertically stacked */
}
body.column #header {
	flex: 0;					/* shrink as much as possible */
	margin-bottom: 0px;
}
body.column #container {
	flex: 1;					/* grow as much as possible */

	display: flex;				/* second level flex for svg */
}
body.column #controls {
	display: flex;				/* second level flex for div within header */
	flex-direction: row; 		/* horizontally */
	flex-wrap: wrap;
	justify-content: space-between;
	margin-left: 0px;
	margin-right: 0px;
}
body.column #controls .group {
	flex: 1;
	margin: 0px;
	border-right: 1px dotted;
	padding-left: 5px;
	padding-right: 5px;
}

body.row {
	display: flex;
	flex-direction: row; 		/* side by side */
}
body.row #header {
	flex: 1;					/* 1/5 = width: 20% */
}
body.row #container {
	flex: 4;					/* 4/5 = width: 80% */

	display: flex;				/* second level flex for svg */
}
body.row #controls {
	display: flex;				/* second level flex for div within header */
	flex-direction: column; 	/* vertically */
	flex-wrap: wrap;
	justify-content: space-between;
}
body.row #controls .group {
	flex: 1;
	margin: 5px;
}

#svg {
	flex: 1;
	height: 100%;
}

/* other styles */

.hidden {
	display: none;
}

#loading {						/* progress bar */
	text-align: center;
}

input[type='number']#number, input[type='number']#sizePNG {
	width:60px;
}


.fieldset {
	border-width: 0;
	margin-inline-start: 0;
	margin-inline-end: 0;
	padding-block-start: 0;
	padding-inline-start: 0;
	padding-inline-end: 0;
	padding-block-end: 0;
}
.fieldset .item {
	white-space: nowrap;		/* keep checkbox and label together */
	display:inline;				/* but do no add extra line breaks per item */
}

</style>

</head>

<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
<body class='column'>

<div id='header'> <!-- The header contains the initial selection screen and the html part of the output sceen -->

<div id='fileselector'>
<h3>EEP Gleisplan</h3>
<form action='#' onsubmit="return false;"> <!-- better not to use inline listener, explizit register is better -->
	<label for="fileinput">Wähle und lade eine EEP-Anlage-Datei (.anl3)</label>
	<input type='file' id='fileinput' accept='.anl3' onchange="loadFile(this.files && this.files[0])">
	<!-- An extra button is not neccessary -->
	<!-- <input type='button' id='btnLoad' value='Load' onclick='loadFile();'> -->
</form>

<p><small><strong>Mausfunktionen</strong><br/>
Verschieben: Klick+Halten+Bewegen<br/>
An der Stelle des Cursors hineinzoomen: Doppelklick<br/>
Herauszoomen: Umschalttaste+Doppelklick</small></p>

<p><small><strong>Interaktive Funktionen</strong><br/>
Wechsel zwischen vertikaler und horizontaler Ausrichtung (Fullscreen mit F11)<br/>
Zoom-in, -out, -reset<br/>
Auswahl der anzuzeigenden Gleissysteme<br/>
Aktuelle Darstellung als png-Bild speichern<br/>
Graphik auf bestimmtes Gleis oder Signal positionieren</small></p>

<p><small><strong>Referenzen / verwandte Programme</strong><br/>
Diskussionbeitrag im <a href='https://www.eepforum.de/forum/thread/26770-eep-gleisplan-im-browser-anzeigen-javascript-projekt' target='_blank'>EEP-Forum</a><br/>
Entwicklungsprojekt auf <a href='https://github.com/FrankBuchholz/EEP_convert_anl3_file' target='_blank'>GitHub</a><br/>
Anzeige einer <a href='https://frankbuchholz.github.io/EEP_convert_anl3_file/EEP_Inventar.html' target='_blank'>Inventarliste</a> zu einer EEP-Anlage</small></p>

<p><small><strong>Technische Beschreibung</strong><br/>
Dieses Programm nutzt die Javascript-Funktion <a href='https://www.w3schools.com/xml/xml_parser.asp' target='_blank'>DOMParser</a> um eine <i>.anl</i>-Datei von EEP, die aus <a href='https://www.w3schools.com/xml/xml_tree.asp' target='_blank'>XML</a> aufgebaut ist, zu interpretieren und in das <a href='https://www.w3schools.com/xml/xml_dom.asp' target='_blank'>Document Object Model (DOM)</a> umzuwandeln.<br/>
Anschließend wird dynamisch mit Javascript die Graphik des Gleisplanes mit <a href='https://www.w3schools.com/html/html5_svg.asp' target='_blank'>SVG</a>-Befehlen aufgebaut. Die Formatierung der graphischen Elemente erfolgt getrennt von der Definition der Graphik mit der SVG-Variante von <a href='https://www.w3schools.com/html/html_css.asp' target='_blank'>CSS</a>.<br/>
Der Browser kann solche SVG-Graphiken direkt anzeigen. Zusätzlich wird die Bibliothek <a href='https://github.com/ariutta/svg-pan-zoom' target='_blank'>svg-pan-zoom</a> verwendet, um interaktive Funktionen zum Verschieben und Zoomen anzubieten.<br/>
Das Programm läuft in Google Chome und Firefox, nicht jedoch im Internet Explorer.</small></p>

<p><small>(c) Frank Buchholz, 2019, mit Unterstützung von <a href='https://github.com/campersau' target='_blank'>campersau</a> und <a href='https://github.com/EEP-Benny' target='_blank'>Benny</a></small></p>
</div> <!-- fileselector -->

<div id='loading' class='hidden'>
	Lade... <progress id='progress' class='hidden' max='100'></progress>
</div>

<div id='controls' class='hidden'>
<div class='group'> <!-- Heading -->
<h3 id='filename'>EEP Gleisplan</h3>
</div>

<div class='group'> <!-- Buttons -->
<button id="swap">swap</button> |
<input type='number' id='sizePNG' value='3000' min='1'>
<button id='savePNG'>save PNG</button>
<br/>
<button id="zoom-in">+</button>
<button id="zoom-out">-</button>
<button id="resetzoom">reset zoom</button>
<button id="reset">reset all</button>
<!-- enable/disable of controls of SvgPanZoom within the graphic
	<button id="enable">enable controls</button>
	<button id="disable">disable controls</button>
-->
<br/>
Stärke <input type='range' min='1' max='100' value='75' name='strokeWidth' id='strokeWidth' autocomplete='off' />
</div>

<div class='group'> <!-- Auswahl des im Zentrum anzuzeigendes Objektes -->
<select id='select' >
	<option value='1'>Eisenbahn</option>
	<option value='2'>Strassenbahn</option>
	<option value='3'>Strasse</option>
	<option value='4'>Wasserwege</option>
	<option value='5'>Steuerstrecken</option>
	<option value='6'>GBS</option>
	<option value='I'>Signal/Weiche</option>
<!--
	<option value='K'>Kontakt</option>
-->
</select>
<input type='number' id='number' value='1' min='1'>
<button id='centerItem'>Zeige Objekt </button>
<div id='message'></div>
</div>

<div class='group'> <!-- Status line -->
Min/Max Höhe der Anlage: <span id="height_area"> </span><br/>
Sichtbarer Bereich: <span id="visible_area"> </span><br/>
Zentrum des Bereichs: <span id="center_position"> </span><br/>
Cursor: <span id="cursor_position"> </span>
</div>

<div class='group'> <!-- Auswahl der anzuzeigenden Objekte. class=hidden wird für diese Objekte enfernt wenn eine Checkbox aktiv ist -->
<fieldset class='fieldset'>
	<!-- Firefox keeps the status of the checkbox between page loadsby default. -->
	<div class="item"><label class='Eisenbahn hidden'>
	<input type='checkbox' name='Gleissystem' checked autocomplete='off' onchange="toggleElements('#Eisenbahn', this.checked)">Eisenbahn</label></div>
	<div class="item"><label class='Strassenbahn hidden'>
	<input type='checkbox' name='Gleissystem' checked autocomplete='off' onchange="toggleElements('#Strassenbahn', this.checked)">Strassenbahn</label></div>
	<div class="item"><label class='Strasse hidden'>
	<input type='checkbox' name='Gleissystem' checked autocomplete='off' onchange="toggleElements('#Strasse', this.checked)">Strasse</label></div>
	<div class="item"><label class='Wasserwege hidden'>
	<input type='checkbox' name='Gleissystem' checked autocomplete='off' onchange="toggleElements('#Wasserwege', this.checked)">Wasserwege</label></div>
	<div class="item"><label class='Steuerstrecken hidden'>
	<input type='checkbox' name='Gleissystem' checked autocomplete='off' onchange="toggleElements('#Steuerstrecken', this.checked)">Steuerstrecken</label></div>
	<div class="item"><label class='GBS hidden'>
	<input type='checkbox' name='Gleissystem' checked autocomplete='off' onchange="toggleElements('#GBS', this.checked)">GBS</label></div>
	<div class="item"><label class='Text'>
	<input type='checkbox' name='Gleissystem' checked autocomplete='off' onchange="toggleElements('text', this.checked)">Text</label></div>
	<div class="item"><label class='Stil'>
	<input type='checkbox' name='Gleissystem' checked autocomplete='off' onchange="toggleElements('.Stil', this.checked)">Stil</label></div>
	<div class="item"><label class='Hoehe'>
	<input type='checkbox' name='Gleissystem' checked autocomplete='off' onchange="toggleElements('.Hoehe', this.checked)">Hoehe</label></div>
	<div class="item"><label class='WeicheText'>
	<input type='checkbox' name='Gleissystem' checked autocomplete='off' onchange="toggleElements('.WeicheText', this.checked)">Weichen</label></div>
	<div class="item"><label class='Signal'>
	<input type='checkbox' name='Gleissystem' checked autocomplete='off' onchange="toggleElements('.Signal', this.checked)">Signale</label></div>
	<div class="item"><label class='Kontakt'>
	<input type='checkbox' name='Gleissystem' checked autocomplete='off' onchange="toggleElements('.Kontakt', this.checked)">Kontakte</label></div>
	<div class="item"><label class='active'>
	<input type='checkbox' name='Gleissystem' checked autocomplete='off' onchange="toggleElements('.active', this.checked)">aktiv</label></div>
	<div class="item"><label class='inactive'>
	<input type='checkbox' name='Gleissystem' checked autocomplete='off' onchange="toggleElements('.inactive', this.checked)">inaktiv</label></div>
	<div class="item"><label class='unsichtbar'>
	<input type='checkbox' name='Gleissystem' checked autocomplete='off' onchange="toggleElements('.unsichtbar', this.checked)">unsichtbar</label></div>
	<div class="item"><label class='Marker'>
	<input type='checkbox' name='Gleissystem' checked autocomplete='off' onchange="toggleMarker(this.checked)">Marker</label></div>
</fieldset>
</div>

</div> <!-- controls -->

</div>  <!-- header -->

<div id='container' class='hidden'> <!-- The container takes the remainig part of the screen to show the graphic -->
<svg id='svg' xmlns='http://www.w3.org/2000/svg' version='1.1'>

<title>EEP Gleisplan</title>
<desc>EEP Gleisplan</desc>
<defs> <!-- style -->
	<style type="text/css"> /* color per track type */
	/* <![CDATA[ */
svg {
	--Eisenbahn-color: red;
	--Strassenbahn-color: darkgray;
	--Strasse-color: grey;
	--Wasserwege-color: blue;
	--Steuerstrecken-color: purple;
	--GBS-color: brown;
}
	/* ]]> */
	</style>

	<style type="text/css" id='css-marker-colors'> /* dynamic update via Javascript to hide/show markers */
	/* <![CDATA[ */
svg {
	--Eisenbahn-marker-color: var(--Eisenbahn-color);
	--Strassenbahn-marker-color: var(--Strassenbahn-color);
	--Strasse-marker-color: var(--Strasse-color);
	--Wasserwege-marker-color: var(--Wasserwege-color);
	--Steuerstrecken-marker-color: var(--Steuerstrecken-color);
	--GBS-marker-color: var(--GBS-color);
}
	/* ]]> */
	</style>

	<style type="text/css" id='css-size-variables'> /* dynamic update via Javascript to adjust font and line size */
	/* <![CDATA[ */
svg {
	--normal-font-size: 4px;
	--normal-stroke-width: 0.5px;
	--narrow-stroke-width: 0.25px;
}
	/* ]]> */
	</style>

	<style type="text/css">
	/* <![CDATA[ */
svg {
	background: white;
	border: 1px dotted #3983ab;
	padding: 0;
	box-sizing: border-box;
	/* transform: scale(1,-1);     		not useful as it would mirror the text, too */
}

<<<<<<< Updated upstream
/* unsichtbare Gleisstile */
.unsichtbar {
	stroke-dasharray: 1;
}

=======
>>>>>>> Stashed changes
/* Texte für Signale, Weichen etc. */
text {
	font-size: var(--normal-font-size);
	font-family: Arial;
	stroke-width: 0;
	text-anchor	: middle;
}

/* Gleisnummern in der Mitte des Gleises */
textPath {
}

text.WeicheText {
	text-anchor	: end;
}

text.Signal  {
}

text.Stil {
	text-anchor	: end;
	font-style: italic;
}

text.Hoehe {
	text-anchor	: start;
	font-style: italic;
}

/* Box zur Anzeige der verwendeten Groesse der Anlage */
.box {
	stroke-width: 0.1;
	stroke: black;
	fill:   none;
	stroke-dasharray: 1;
}

/* Zusätzliche Markierung des Zentrums */
#center {
	stroke-width: 0;
	stroke: #cc0000;
	fill:   #cc0000;
}

/* Individuelle Formatierung je Gleissystem */

#Eisenbahn {
	stroke-width: var(--normal-stroke-width);
	stroke: var(--Eisenbahn-color);
	fill:   none;
	marker-start: url(#EisenbahnMarkerCircle);
	marker-end:   url(#EisenbahnMarkerArrow);
}
#EisenbahnMarkerCircle, #EisenbahnMarkerArrow {
	fill: var(--Eisenbahn-marker-color);
}
#Eisenbahn text {
	fill: var(--Eisenbahn-color);
}

#Strassenbahn {
	stroke-width: var(--normal-stroke-width);
	stroke: var(--Strassenbahn-color);
	fill:   none;
	marker-start: url(#StrassenbahnMarkerCircle);
	marker-end:   url(#StrassenbahnMarkerArrow);
}
#StrassenbahnMarkerCircle, #StrassenbahnMarkerArrow {
	fill: var(--Strassenbahn-marker-color) ;
}
#Strassenbahn text {
	fill: var(--Strassenbahn-color) ;
}

#Strasse {
	stroke-width: var(--normal-stroke-width);
	stroke: var(--Strasse-color);
	fill:   none;
	marker-start: url(#StrasseMarkerCircle);
	marker-end:   url(#StrasseMarkerArrow);
}
#StrasseMarkerCircle, #StrasseMarkerArrow {
	fill: var(--Strasse-marker-color);
}
#Strasse text {
	fill: var(--Strasse-color);
}

#Wasserwege {
	stroke-width: var(--narrow-stroke-width);
	stroke: var(--Wasserwege-color);
	fill:   none;
	marker-start: url(#WasserwegeMarkerCircle);
	marker-end:   url(#WasserwegeMarkerArrow);
}
#WasserwegeMarkerCircle, #WasserwegeMarkerArrow {
	fill: var(--Wasserwege-marker-color);
}
#Wasserwege text {
	fill: var(--Wasserwege-color);
}

#Steuerstrecken {
	stroke-width: var(--narrow-stroke-width);
	stroke: var(--Steuerstrecken-color);
	fill:   none;
	marker-start: url(#SteuerstreckenMarkerCircle);
	marker-end:   url(#SteuerstreckenMarkerArrow);
}
#SteuerstreckenMarkerCircle, #SteuerstreckenMarkerArrow {
	fill: var(--Steuerstrecken-marker-color);
}
#Steuerstrecken text {
	fill: var(--Steuerstrecken-color);
}

#GBS {
	stroke-width: var(--narrow-stroke-width);
	stroke: var(--GBS-color);
	fill:   none;
	marker-start: url(#GBSMarkerCircle);
	marker-end:   url(#GBSMarkerArrow);
}
#GBSMarkerCircle, #GBSMarkerArrow {
	fill: var(--GBS-marker-color);
}
#GBS text {
	fill: var(--GBS-color);
}

.Prellbock {
	marker-end:   url(#Prellbock);
}

/* Symbole */

#SymbolSignal, #SymbolKontakt {
	marker-start: none;
	marker-end:   none;
	stroke-width: var(--narrow-stroke-width);
	fill:   none;
}

/* Individuelle Formatierung je Gleisstil */

.stil-1353 { 	/* Gleis mit Betonschwellen */
}

.stil-5146 { 	/* Farm track */
	stroke: brown;
}

.unsichtbar {	/* unsichtbare Gleisstile */
	stroke-dasharray: 1;
}

.inactive {		/* inaktive Gleisstile */
	stroke-opacity: 0.5;
}

.hidden {		/* versteckte Elemente */
	display: none !important;
}
	/* ]]> */
	</style>
</defs>

<defs> <!-- Symbols and Markers -->
	<!-- Use of symbols requires translate(-10 0) to move the origin M 0 0 to the correct position --> 
	<symbol id='SymbolSignal' width='20' height='10' viewBox='-10 0 20 10'>
		<!-- <path d='M 0 0 L 4 3 A 12 12  0 0 1  -4 3 z' /> 								<!-- Kreissegment --> 
		<!-- <path d='M 0 0 L 0 1.2 L 4.8 1.2 L 4.8 5.8 L -4.8 5.8 L -4.8 1.2 L 0 1.2' /> 	<!-- Box --> 
		<path d='M 0 0 L 0 0.9' /><circle cx='0' cy='1.5' r='0.6' />  						<!-- Linie mit Kreis --> 
	</symbol>
		<symbol id='SymbolKontakt' width='20' height='10' viewBox='-10 0 20 10'>
		<path d='M 0 0 L 0 0.9 L 0.7 2 L -0.7 2 L 0 0.9' />									<!-- Linie mit Dreieck --> 
	</symbol>

	<!-- Prellbock: Querbalken --> 
	<marker id="Prellbock" 	markerWidth="2" markerHeight="4" refX="2" refY="2" orient="auto">
		<rect x="0" y="0" width="2" height="4"/>
	</marker>

	<!-- We need individual markers to be able to apply CSS -->
	<marker id="EisenbahnMarkerCircle" 		markerWidth="5" markerHeight="5" refX="2" refY="3">
		<circle cx="3" cy="3" r="1" />
	</marker>
	<marker id="StrassenbahnMarkerCircle"	markerWidth="5" markerHeight="5" refX="2" refY="3">
		<circle cx="3" cy="3" r="1" />
	</marker>
	<marker id="StrasseMarkerCircle" 		markerWidth="5" markerHeight="5" refX="2" refY="3">
		<circle cx="3" cy="3" r="1" />
	</marker>
	<marker id="WasserwegeMarkerCircle" 	markerWidth="5" markerHeight="5" refX="2" refY="3">
		<circle cx="3" cy="3" r="1" />
	</marker>
	<marker id="SteuerstreckenMarkerCircle" markerWidth="5" markerHeight="5" refX="2" refY="3">
		<circle cx="3" cy="3" r="1" />
	</marker>
	<marker id="GBSMarkerCircle" 			markerWidth="5" markerHeight="5" refX="2" refY="3">
		<circle cx="3" cy="3" r="1" />
	</marker>

	<marker id="EisenbahnMarkerArrow" 		markerWidth="5" markerHeight="5" refX="2" refY="3" orient="auto">
		<path d="M0,1 L0,5 L3,3 L0,1" />
	</marker>
	<marker id="StrassenbahnMarkerArrow" 	markerWidth="5" markerHeight="5" refX="2" refY="3" orient="auto">
		<path d="M0,1 L0,5 L3,3 L0,1" />
	</marker>
	<marker id="StrasseMarkerArrow" 		markerWidth="5" markerHeight="5" refX="2" refY="3" orient="auto">
		<path d="M0,1 L0,5 L3,3 L0,1" />
	</marker>
	<marker id="WasserwegeMarkerArrow" 		markerWidth="5" markerHeight="5" refX="2" refY="3" orient="auto">
		<path d="M0,1 L0,5 L3,3 L0,1" />
	</marker>
	<marker id="SteuerstreckenMarkerArrow" 	markerWidth="5" markerHeight="5" refX="2" refY="3" orient="auto">
		<path d="M0,1 L0,5 L3,3 L0,1" />
	</marker>
	<marker id="GBSMarkerArrow" 			markerWidth="5" markerHeight="5" refX="2" refY="3" orient="auto">
		<path d="M0,1 L0,5 L3,3 L0,1" />
	</marker>

</defs>

<g id="sutrackp" class="svg-pan-zoom_viewport">
<!-- hier werden dynamisch die weiteren svg-Elemente der EEP Anlage eingefügt -->
</g> <!-- sutrackp -->

</svg>
</div> <!-- container -->
</body>
</html>
