<!DOCTYPE html>
<html lang="de">
<head>
<title>Demo: File System API</title>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />

<style>
body {
  font-family: helvetica, arial, sans-serif;
  margin: 2em;
}

h1 {
  font-style: italic;
  color: #373fff;
}
</style>	

<script> // File System API
/* 
https://wicg.github.io/file-system-access/
This experiment is based on:
https://github.com/GoogleChromeLabs/browser-fs-access
*/
(async function (api) {
// public api
api.fileOpen = fileOpen;
api.directoryOpen = directoryOpen;
api.fileSave = fileSave;

const getFileWithHandle = async (handle) => {
  const file = await handle.getFile();
  file.handle = handle;
  return file;
};

// Opens a file from disk using the File System Access API.
async function fileOpen (options = {}) {
  const accept = {};
  if (options.mimeTypes) {
    options.mimeTypes.map((mimeType) => {
      accept[mimeType] = options.extensions || [];
    });
  } else {
    accept['*/*'] = options.extensions || [];
  }
  const handleOrHandles = await window.showOpenFilePicker({
    types: [
      {
        description: options.description || '',
        accept: accept,
      },
    ],
    multiple: options.multiple || false,
  });
  const files = await Promise.all(handleOrHandles.map(getFileWithHandle));
  if (options.multiple) {
    return files;
  }
  return files[0];
};

async function getFiles (dirHandle, recursive, path = dirHandle.name) {
  const dirs = [];
  const files = [];
  for await (const entry of dirHandle.values()) {
    const nestedPath = `${path}/${entry.name}`;
    if (entry.kind === 'file') {
      files.push(
        entry.getFile().then((file) =>
          Object.defineProperty(file, 'webkitRelativePath', {
            configurable: true,
            enumerable: true,
            get: () => nestedPath,
          })
        )
      );
    } else if (entry.kind === 'directory' && recursive) {
      dirs.push(getFiles(entry, recursive, nestedPath));
    }
  }
  return [...(await Promise.all(dirs)).flat(), ...(await Promise.all(files))];
};

// Opens a directory using the File System Access API.
async function directoryOpen (options = {}) {
  options.recursive = options.recursive || false;
  const handle = await window.showDirectoryPicker();
  return getFiles(handle, options.recursive);
};

// Saves file to disk using the File System Access API.
async function fileSave (blob, options = {}, handle = null) {
  options.fileName = options.fileName || 'Untitled';
  const accept = {};
  if (options.mimeTypes) {
    options.mimeTypes.push(blob.type);
    options.mimeTypes.map((mimeType) => {
      accept[mimeType] = options.extensions || [];
    });
  } else {
    accept[blob.type] = options.extensions || [];
  }
  handle =
    handle ||
    (await window.showSaveFilePicker({
      suggestedName: options.fileName,
      types: [
        {
          description: options.description || '',
          accept: accept,
        },
      ],
    }));
  const writable = await handle.createWritable();
  await writable.write(blob);
  await writable.close();
  return handle;
};

})(this); // end module
</script>

<script> // image-to-blob.mjs
/**
 * Converts an image to a Blob.
 * @param {HTMLImageElement} img - Image element.
 * @return {Blob} Resulting Blob.
 */
async function imageToBlob (img) {
  return new Promise((resolve) => {
    const canvas = document.createElement('canvas');
    canvas.width = img.naturalWidth;
    canvas.height = img.naturalHeight;
    const ctx = canvas.getContext('2d');
    ctx.drawImage(img, 0, 0);
    canvas.toBlob((blob) => {
      resolve(blob);
    });
  });
};
</script>
</head>

<body>
<h1><img src="./images/favicon.ico" alt="Floppy disk"/>Demo: File System API</h1>
<button id="open" disabled type="button">Open File</button>
<button id="open-multiple" disabled type="button">Open Files</button>
<button id="open-directory" disabled type="button">Open Directory</button>
<!-- 
<button id="save" disabled type="button">Save File</button>
-->
<pre></pre>

<div id="fileName"></div>
<pre id="fileContent"></pre>

<script> // Main
(async () => {
  const openButton 			= document.querySelector('#open');
  const openMultipleButton 	= document.querySelector('#open-multiple');
  const openDirectoryButton	= document.querySelector('#open-directory');
  //const saveButton		= document.querySelector('#save');

  const pre 				= document.querySelector('pre');
  const fileName 			= document.querySelector('#fileName');
  const fileContent 		= document.querySelector('#fileContent');

  // Process file: show it
  async function processFile (file) {
    fileName.textContent = file.name + " " + file.size;
	const content = await file.text();
    fileContent.textContent = content;
  };

  // Process image file: show it
  const processImage = (image) => {
    const img = document.createElement('img');
    img.src = URL.createObjectURL(image);
    document.body.append(img);
    img.onload = img.onerror = () => URL.revokeObjectURL(img.src);
  };

  // Process directory: list it
  const processDirectory = (directory) => {
    let fileStructure = '';
    directory
      .sort((a, b) => a.webkitRelativePath.localeCompare(b))
      .forEach((directory) => {
        // The File System Access API currently reports the `webkitRelativePath`
        // as empty string `''`.
        fileStructure += `${directory.webkitRelativePath}\n`;
      });
    pre.textContent += fileStructure;

	  
	  const tid = setInterval(
		() => {

    directory
      .filter((directory) => {
        return directory.type.startsWith('');
      })
      .forEach((file) => {
        processFile(file);
      });
	  
		}, 
		1000
	  );
	  
	  
  };

  // Button events
  openButton.addEventListener('click', async () => {
    try {
      const file = await fileOpen({
        //mimeTypes: ['image/jpg', 'image/png', 'image/gif', 'image/webp'],
        //extensions: ['.jpg', '.jpeg', '.png', '.gif', '.webp'],
        multiple: false,
      });
	  
	  const tid = setInterval(
		() => {
			processFile(file);
		}, 
		1000
	  );

    } catch (err) {
      if (err.name !== 'AbortError') {
        console.error(err);
      }
    }
  });
  openButton.disabled = false;

  openMultipleButton.addEventListener('click', async () => {
    try {
      const files = await fileOpen({
        //mimeTypes: ['image/jpg', 'image/png', 'image/gif', 'image/webp'],
        //extensions: ['.jpg', '.jpeg', '.png', '.gif', '.webp'],
        multiple: true,
      });
      for (const file of files) {
        processFile(file);
      }
    } catch (err) {
      if (err.name !== 'AbortError') {
        console.error(err);
      }
    }
  });
  openMultipleButton.disabled = false;

  openDirectoryButton.addEventListener('click', async () => {
    try {
      const directory = await directoryOpen({
	    recursive: false,
	  });
      processDirectory(directory);
    } catch (err) {
      if (err.name !== 'AbortError') {
        console.error(err);
      }
    }
  });
  openDirectoryButton.disabled = false;

/*
  saveButton.addEventListener('click', async () => {
    const blob = await imageToBlob(document.querySelector('img'));
    try {
      await fileSave(blob, {
        fileName: 'floppy.png',
        extensions: ['.png'],
      });
    } catch (err) {
      if (err.name !== 'AbortError') {
        console.error(err);
      }
    }
  });
  saveButton.disabled = false;
*/
})();
</script>

</body>
</html>